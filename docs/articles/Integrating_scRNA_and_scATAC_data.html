<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells) • rliger2</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)">
<meta property="og:description" content="rliger2">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rliger2</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.99.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="dropdown-header">Installation</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Introductory Vignettes</li>
    <li class="dropdown-header">Integrating Multiple scRNAseq Data</li>
    <li class="dropdown-header">Integrating On-Disk (HDF5 Based) Data</li>
    <li class="divider">
    </li>
<li class="dropdown-header">Data structure and access</li>
    <li class="dropdown-header">Outer container - liger object</li>
    <li class="dropdown-header">Dataset container - ligerDataset object and subclasses</li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Documentation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Data</a>
      <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Import Data</li>
      </ul>
</li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">NEWS</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/welch-lab/liger" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Joint definition of cell types from single-cell
gene expression and chromatin accessibility data (human bone marrow
mononuclear cells)</h1>
                        <h4 data-toc-skip class="author">Jialin Liu and
Joshua Welch</h4>
            
            <h4 data-toc-skip class="date">3/27/2020</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/welch-lab/liger/blob/HEAD/vignettes/Integrating_scRNA_and_scATAC_data.Rmd" class="external-link"><code>vignettes/Integrating_scRNA_and_scATAC_data.Rmd</code></a></small>
      <div class="hidden name"><code>Integrating_scRNA_and_scATAC_data.Rmd</code></div>

    </div>

    
    
<blockquote>
<p>NOTE: The old version of this tutorial has been archived. The users
can access it from <a href="https://macoskolab.github.io/liger/walkthrough_rna_atac.html" class="external-link">here</a>.</p>
</blockquote>
<p>In this tutorial, we will demonstrate LIGER’s ability to jointly
define cell types by leveraging multiple single-cell modalities. For
example, the integration of single-cell RNA-seq and single-cell ATAC-seq
enables cell type definitions that incorporate both gene expression and
chromatin accessibility data. Such joint analysis allows not only the
taxonomic categorization of cell types, but also a deeper understanding
of their underlying regulatory networks. The pipeline for jointly
analyzing scRNA-seq and scATAC-seq is similar to that for integrating
multiple scRNA-seq datasets in that both rely on joint matrix
factorization and quantile normalization. The main differences are: (1)
scATAC-seq data needs to be processed into gene-level values; (2) gene
selection is performed on the scRNA-seq data only; and (3) downstream
analyses can use both gene-level and intergenic information.</p>
<div class="section level2">
<h2 id="stage-i-preprocessing-and-normalization-40---50-minutes">Stage I: Preprocessing and Normalization (40 - 50 minutes)<a class="anchor" aria-label="anchor" href="#stage-i-preprocessing-and-normalization-40---50-minutes"></a>
</h2>
<p>In order to jointly analyze scRNA and scATAC-seq data, we first need
to transform the scATAC-seq data–a genome-wide epigenomic
measurement–into gene-level counts which are comparable to gene
expression data from scRNA-seq. Most previous single-cell studies have
used an approach inspired by traditional bulk ATAC-seq analysis:
identifying chromatin accessibility peaks, then summing together all
peaks that overlap each gene. This strategy is also appealing because
the 10X CellRanger pipeline, a commonly used commercial package,
automatically outputs such peak counts. However, we find this strategy
less desirable because: (1) peak calling is performed using all cells,
which biases against rare cell populations; (2) gene body accessibility
is often more diffuse than that of specific regulatory elements, and
thus may be missed by peak calling algorithms; and (3) information from
reads outside of peaks is discarded, further reducing the amount of data
in the already sparse measurements. Instead of summing peak counts, we
find that the simplest possible strategy seems to work well: counting
the total number of ATAC-seq reads within the gene body and promoter
region (typically 3 kb upstream) of each gene in each cell.</p>
<p>For convenience, we have prepared the pre-processed data which are
ready to use.</p>
<ul>
<li><a href="https://figshare.com/ndownloader/files/40054858" class="external-link">GSM4138872_scRNA_BMMC_D1T1.rds</a></li>
<li><a href="https://figshare.com/ndownloader/files/40054861" class="external-link">GSM4138873_scRNA_BMMC_D1T2.rds</a></li>
<li><a href="https://figshare.com/ndownloader/files/40054891" class="external-link">GSM4138888_scATAC_BMMC_D5T1.RDS</a></li>
<li><a href="https://figshare.com/ndownloader/files/40054864" class="external-link">GSM4138888_scATAC_BMMC_D5T1_peak_counts.RDS</a></li>
<li><a href="https://figshare.com/ndownloader/files/40054870" class="external-link">hg19_genes.bed</a></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/welch-lab/liger" class="external-link">rliger2</a></span><span class="op">)</span></span>
<span><span class="va">D5T1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"GSM4138888_scATAC_BMMC_D5T1.RDS"</span><span class="op">)</span></span>
<span><span class="va">rna1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"GSM4138872_scRNA_BMMC_D1T1.rds"</span><span class="op">)</span></span>
<span><span class="va">rna2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"GSM4138873_scRNA_BMMC_D1T2.rds"</span><span class="op">)</span></span>
<span><span class="va">bmmc.rna</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">rna1</span>,<span class="va">rna2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/rm.html" class="external-link">rm</a></span><span class="op">(</span><span class="va">rna1</span>, <span class="va">rna2</span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="start-from-cellranger-output">Start from CellRanger output<a class="anchor" aria-label="anchor" href="#start-from-cellranger-output"></a>
</h3>
<p>You can also follow the following tutorial if you would like to start
from the very beginning. Note that in this part, we included the details
of running this preprocessing workflow for only one sample. Users should
re-run this counting step multiple times if for more than one scATAC-seq
sample.</p>
<p>Note also that several commands need to be run through the Command
Line Interface instead of the R Console or IDE (RStudio). We also employ
the bedmap command from the BEDOPS tool to make a list of cell barcodes
that overlap each gene and promoter. The gene body and promoter indexes
are .bed files, which indicate gene and promoter coordinates. Since
bedmap expects sorted inputs, the fragment output from CellRanger, gene
body and promoter indexes should all be sorted.</p>
<p>We show below how to perform these steps for scATAC data generated by
the 10X Chromium system, the most widely used scATAC-seq protocol. The
starting input for this process is the file fragments.tsv output by
CellRanger, which contains all ATAC reads that passed filtering
steps.</p>
<details><summary><b>Detailed CellRanger output preprocessing</b></summary><p><strong>1.</strong> We must first sort fragments.tsv by chromosome,
start, and end position using the sort command line utility. The
<code>-k</code> option lets the user sort the file on a certain column;
including multiple <code>-k</code> options allows sorting by multiple
columns simultaneously. The <code>n</code> behind <code>-k</code> stands
for “numeric ordering”. Here the sorted BED file order is defined first
by lexicographic chromosome order (using the parameter
<code>-k1,1</code>), then by ascending integer start coordinate order
(using parameter <code>-k2,2n</code>), and finally by ascending integer
end coordinate order (using parameter <code>-k3,3n</code>). Note that
this step may take a while, since the input fragment file is usually
very large (for example, a typical fragment file of 4-5 GB can take
about 40 minutes).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sort <span class="sc">-</span>k1,<span class="dv">1</span> <span class="sc">-</span>k2,2n <span class="sc">-</span>k3,3n GSM4138888_scATAC_BMMC_D5T1.fragments.tsv <span class="sc">&gt;</span> atac_fragments.sort.bed</span></code></pre></div>
<p>Gene body and promoter indexes should also be sorted using the same
strategy for sorting fragments output files:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>sort <span class="sc">-</span>k <span class="dv">1</span>,<span class="dv">1</span> <span class="sc">-</span>k2,2n <span class="sc">-</span>k3,3n hg19_genes.bed <span class="sc">&gt;</span> hg19_genes.sort.bed</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>sort <span class="sc">-</span>k <span class="dv">1</span>,<span class="dv">1</span> <span class="sc">-</span>k2,2n <span class="sc">-</span>k3,3n hg19_promoters.bed <span class="sc">&gt;</span> hg19_promoters.sort.bed</span></code></pre></div>
<p><strong>2.</strong> Use <code>bedmap</code> command to calculate
overlapping elements between indexes and fragment output files:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>bedmap <span class="sc">--</span>ec <span class="sc">--</span>delim <span class="st">"</span><span class="sc">\t</span><span class="st">"</span> <span class="sc">--</span>echo <span class="sc">--</span>echo<span class="sc">-</span>map<span class="sc">-</span>id hg19_promoters.sort.bed atac_fragments.sort.bed <span class="sc">&gt;</span> atac_promoters_bc.bed</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>bedmap <span class="sc">--</span>ec <span class="sc">--</span>delim <span class="st">"</span><span class="sc">\t</span><span class="st">"</span> <span class="sc">--</span>echo <span class="sc">--</span>echo<span class="sc">-</span>map<span class="sc">-</span>id hg19_genes.sort.bed atac_fragments.sort.bed <span class="sc">&gt;</span> atac_genes_bc.bed</span></code></pre></div>
<p>Important flags of <code>bedmap</code> command are as follows:</p>
<ul>
<li>
<code>--delim</code>. This changes output delimiter from ‘|’ to
indicated delimiter between columns, which in our case is “\t”.</li>
<li>
<code>--ec</code>. Adding this will check all problematic input
files.</li>
<li>
<code>--echo</code>. Adding this will print each line from reference
file in output. The reference file in our case is gene or promoter
index.</li>
<li>
<code>--echo-map-id</code>. Adding this will list IDs of all
overlapping elements from mapping files, which in our case are cell
barcodes from fragment files.</li>
</ul>
<p><strong>3.</strong> We then import the bedmap outputs into the R
Console or RStudio. Note that the as.is option in
<code><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table()</a></code> is specified to prevent the conversion of
character columns to factor columns:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">genes.bc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table</a></span><span class="op">(</span>file <span class="op">=</span> <span class="st">"atac_genes_bc.bed"</span>, sep <span class="op">=</span> <span class="st">"\t"</span>, as.is <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">7</span><span class="op">)</span>, header <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">promoters.bc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table</a></span><span class="op">(</span>file <span class="op">=</span> <span class="st">"atac_promoters_bc.bed"</span>, sep <span class="op">=</span> <span class="st">"\t"</span>, as.is <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">7</span><span class="op">)</span>, header <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>Cell barcodes are then split and extracted from the outputs. We
recommend the user to filter out those barcodes which have a total
number of reads lower than a certain threshold, for example, 1500. This
threshold can be adjusted according to the size and quality of the
samples.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bc</span> <span class="op">&lt;-</span> <span class="va">genes.bc</span><span class="op">[</span>,<span class="fl">7</span><span class="op">]</span></span>
<span><span class="va">bc_split</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/strsplit.html" class="external-link">strsplit</a></span><span class="op">(</span><span class="va">bc</span>,<span class="st">";"</span><span class="op">)</span></span>
<span><span class="va">bc_split_vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">bc_split</span><span class="op">)</span></span>
<span><span class="va">bc_unique</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">bc_split_vec</span><span class="op">)</span></span>
<span><span class="va">bc_counts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">bc_split_vec</span><span class="op">)</span></span>
<span><span class="va">bc_filt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">bc_counts</span><span class="op">)</span><span class="op">[</span><span class="va">bc_counts</span> <span class="op">&gt;</span> <span class="fl">1500</span><span class="op">]</span></span>
<span><span class="va">barcodes</span> <span class="op">&lt;-</span> <span class="va">bc_filt</span></span></code></pre></div>
<p><strong>4.</strong> We can then use LIGER’s
<code><a href="../reference/makeFeatureMatrix.html">makeFeatureMatrix()</a></code> function to calculate accessibility
counts for gene body and promoter individually. This function takes the
output from <code>bedmap</code> and efficiently counts the number of
fragments overlapping each gene and promoter. We could count the genes
and promoters in a single step, but choose to calculate them separately
in case it is necessary to look at gene or promoter accessibility
individually in downstream analyses.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/JEFworks/liger" class="external-link">liger</a></span><span class="op">)</span></span>
<span><span class="va">gene.counts</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/makeFeatureMatrix.html">makeFeatureMatrix</a></span><span class="op">(</span><span class="va">genes.bc</span>, <span class="va">barcodes</span><span class="op">)</span></span>
<span><span class="va">promoter.counts</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/makeFeatureMatrix.html">makeFeatureMatrix</a></span><span class="op">(</span><span class="va">promoters.bc</span>, <span class="va">barcodes</span><span class="op">)</span></span></code></pre></div>
<p>Next, these two count matrices need to be re-sorted by gene symbol.
We then add the matrices together, yielding a single matrix of gene
accessibility counts in each cell.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gene.counts</span> <span class="op">&lt;-</span> <span class="va">gene.counts</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">gene.counts</span><span class="op">)</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="va">promoter.counts</span> <span class="op">&lt;-</span> <span class="va">promoter.counts</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">promoter.counts</span><span class="op">)</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="va">D5T1</span> <span class="op">&lt;-</span> <span class="va">gene.counts</span> <span class="op">+</span> <span class="va">promoter.counts</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">D5T1</span><span class="op">)</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"D5T1_"</span>,<span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">D5T1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><strong>5.</strong> Once the gene-level scATAC-seq counts are
generated, the <code><a href="../reference/read10X.html">read10X()</a></code> function from LIGER can be used to
read scRNA-seq count matrices output by CellRanger. You can pass in a
directory (or a list of directories) containing raw outputs (for
example, <code>"/Sample_1/outs/filtered_feature_bc_matrix"</code>) to
the parameter <code>sample.dirs</code>. Next, a vector of names to use
for the sample (or samples, corresponding to <code>sample.dirs</code>)
should be passed to parameter <code>sample.names</code> as well. LIGER
can also use data from any other protocol, as long as it is provided in
a genes x cells R matrix format.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bmmc.rna</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read10X.html">read10X</a></span><span class="op">(</span>sample.dirs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"/path_to_sample"</span><span class="op">)</span>, sample.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"rna"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
</details><br>
</div>
<div class="section level3">
<h3 id="liger-preprocessing">LIGER preprocessing<a class="anchor" aria-label="anchor" href="#liger-preprocessing"></a>
</h3>
<p><strong>6.</strong> We can now create a LIGER object with the
<code><a href="../reference/createLiger.html">createLiger()</a></code> function. We also remove unneeded variables
to conserve memory.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bmmc.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>atac <span class="op">=</span> <span class="va">D5T1</span>, rna <span class="op">=</span> <span class="va">bmmc.rna</span><span class="op">)</span></span>
<span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/createLiger.html">createLiger</a></span><span class="op">(</span><span class="va">bmmc.data</span>, modal <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"atac"</span>, <span class="st">"rna"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/rm.html" class="external-link">rm</a></span><span class="op">(</span><span class="va">genes.bc</span>, <span class="va">promoters.bc</span>, <span class="va">gene.counts</span>, <span class="va">promoter.counts</span>, <span class="va">D5T1</span>, <span class="va">bmmc.rna</span>, <span class="va">bmmc.data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/gc.html" class="external-link">gc</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">int.bmmc</span></span></code></pre></div>
<p><strong>7.</strong> Preprocessing steps are needed before running
iNMF. Each dataset is normalized to account for differences in total
gene-level counts across cells using the normalize function. Next,
highly variable genes from each dataset are identified and combined for
use in downstream analysis. Note that by setting the parameter
<code>datasets.use = 2</code>, genes will be selected only from the
scRNA-seq dataset (the second dataset) by the <code><a href="../reference/selectGenes.html">selectGenes()</a></code>
function. We recommend not using the ATAC-seq data for variable gene
selection because the statistical properties of the ATAC-seq data are
very different from scRNA-seq, violating the assumptions made by the
statistical model we developed for selecting genes from RNA data.
Finally, the <code><a href="../reference/scaleNotCenter.html">scaleNotCenter()</a></code> function scales normalized
datasets without centering by the mean, giving the non-negative input
data required by iNMF.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/normalize.html">normalize</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span></span>
<span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/selectGenes.html">selectGenes</a></span><span class="op">(</span><span class="va">int.bmmc</span>, datasets.use <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scaleNotCenter.html">scaleNotCenter</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="stage-ii-joint-matrix-factorization-3---10-minutes">Stage II: Joint Matrix Factorization (3 - 10 minutes)<a class="anchor" aria-label="anchor" href="#stage-ii-joint-matrix-factorization-3---10-minutes"></a>
</h2>
<p><strong>8.</strong> We next perform joint matrix factorization (iNMF)
on the normalized and scaled RNA and ATAC data. This step calculates
metagenes–sets of co-expressed genes that distinguish cell
populations–containing both shared and dataset-specific signals. The
cells are then represented in terms of the “expression level” of each
metagene, providing a low-dimensional representation that can be used
for joint clustering and visualization. To run iNMF on the scaled
datasets, we use the <code><a href="../reference/optimizeALS.html">optimizeALS()</a></code> function with proper
hyperparameter settings.</p>
<p>To run iNMF on the scaled datasets, use <code><a href="../reference/optimizeALS.html">optimizeALS()</a></code>
function with proper hyperparameters setting:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/optimizeALS.html">optimizeALS</a></span><span class="op">(</span><span class="va">int.bmmc</span>, k <span class="op">=</span> <span class="fl">20</span>, maxIter <span class="op">=</span> <span class="fl">30</span><span class="op">)</span></span></code></pre></div>
<p>Important parameters are as follows:</p>
<ul>
<li>
<em>k</em>. Integer value specifying the inner dimension of
factorization, or number of factors. Higher <code>k</code> is
recommended for datasets with more substructure. We find that a value of
<code>k</code> in the range 20 - 40 works well for most datasets.
Because this is an unsupervised, exploratory analysis, there is no
single “right” value for <code>k</code>, and in practice, users choose
<code>k</code> from a combination of biological prior knowledge and
other information.</li>
<li>
<em>lambda</em>. This is a regularization parameter. Larger values
penalize dataset-specific effects more strongly, causing the datasets to
be better aligned, but possibly at the cost of higher reconstruction
error. The default value is <code>5</code>. We recommend using this
value for most analyses, but find that it can be lowered to 1 in cases
where the dataset differences are expected to be relatively small, such
as scRNA-seq data from the same tissue but different individuals.</li>
<li>
<em>thresh</em>. This sets the convergence threshold. Lower values
cause the algorithm to run longer. The default is
<code>1e-6</code>.</li>
<li>
<em>maxIter</em>. This variable sets the maximum number of
iterations to perform. The default value is <code>30</code>.</li>
</ul>
</div>
<div class="section level2">
<h2 id="stage-iii-quantile-normalization-and-joint-clustering-1-minute">Stage III: Quantile Normalization and Joint Clustering (1
minute)<a class="anchor" aria-label="anchor" href="#stage-iii-quantile-normalization-and-joint-clustering-1-minute"></a>
</h2>
<p><strong>9.</strong> Using the metagene factors calculated by iNMF, we
then assign each cell to the factor on which it has the highest loading,
giving joint clusters that correspond across datasets. We then perform
quantile normalization by dataset, factor, and cluster to fully
integrate the datasets. To perform this analysis, typing in:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/quantileNorm.html">quantileNorm</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span></span></code></pre></div>
<p>Important parameters of <code><a href="../reference/quantileNorm.html">quantileNorm()</a></code> are as
follows:</p>
<ul>
<li>
<code>nNeighbors</code>. This sets the number of nearest neighbors
for within-dataset KNN graph. The default is <code>20</code>.</li>
<li>
<code>quantiles</code>. This sets the number of quantiles to use for
quantile normalization. The default is <code>50</code>.</li>
<li>
<code>minCells</code>. This indicates the minimum number of cells to
consider a cluster as shared across datasets. The default is
<code>20</code>.</li>
<li>
<code>useDims</code>. This sets the indices of factors to use for
quantile normalization. The user can pass in a vector of indices
indicating specific factors. This is helpful for excluding factors
capturing biological signals such as the cell cycle or technical signals
such as mitochondrial genes. The default is all <code>k</code> of the
factors.</li>
<li>
<code>center</code>. This indicates whether to center the data when
scaling factors. The default is <code>FALSE</code>. This option should
be set to <code>TRUE</code> when metagene loadings have a mean above
zero, as with dense data such as DNA methylation.</li>
<li>
<code>maxSample</code>. This sets the maximum number of cells used
for quantile normalization of each cluster and factor. The default is
<code>1000</code>.</li>
<li>
<code>refineKNN</code>. This indicates whether to increase
robustness of cluster assignments using KNN graph. The default is
<code>TRUE</code>.</li>
<li>
<code>eps</code>. This sets the error bound of the nearest neighbor
search. The default is <code>0.9</code>. Lower values give more accurate
nearest neighbor graphs but take much longer to computer.</li>
<li>
<code>reference</code>. This indicates the name of the dataset to be
used as a reference for quantile normalization. By default, the dataset
with the largest number of cells is used.</li>
</ul>
<p><strong>10.</strong> The <code><a href="../reference/quantileNorm.html">quantileNorm()</a></code> function gives
joint clusters that correspond across datasets, which are often
completely satisfactory and sufficient for downstream analyses. However,
if desired, after quantile normalization, users can additionally run the
Leiden algorithm for community detection, which is widely used in
single-cell analysis and excels at merging small clusters into broad
cell classes. This can be achieved by running the
<code><a href="../reference/clustering.html">runLeidenCluster()</a></code> function. Several tuning parameters,
including <code>resolution</code>, <code>nNeighbors</code>, and
<code>prune</code> control the number of clusters produced by this
function. For this dataset, we use a resolution of <code>0.2</code>,
which yields 26 clusters (see below).</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/clustering.html">runLeidenCluster</a></span><span class="op">(</span><span class="va">int.bmmc</span>, nNeighbors <span class="op">=</span> <span class="fl">30</span>, resolution <span class="op">=</span> <span class="fl">0.2</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="stage-iv-visualization-2---3-minutes-and-downstream-analysis-30---40-minutes">Stage IV: Visualization (2 - 3 minutes) and Downstream Analysis (30
- 40 minutes)<a class="anchor" aria-label="anchor" href="#stage-iv-visualization-2---3-minutes-and-downstream-analysis-30---40-minutes"></a>
</h2>
<p><strong>11.</strong> In order to visualize the clustering results,
the user can use two dimensionality reduction methods supported by
LIGER: t-SNE and UMAP. We find that often for datasets containing
continuous variation such as cell differentiation, UMAP better preserves
global relationships, whereas t-SNE works well for displaying discrete
cell types, such as those in the brain. The UMAP algorithm (called by
the <code><a href="../reference/runUMAP.html">runUMAP()</a></code> function) scales readily to large datasets.
The <code><a href="../reference/runTSNE.html">runTSNE()</a></code> function also includes an option to use
“FFtSNE”, a highly scalable implementation of t-SNE that can efficiently
process huge datasets. For the BMMC dataset, we expect to see continuous
lineage transitions among the differentiating cells, so we use UMAP to
visualize the data in two dimensions:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/runUMAP.html">runUMAP</a></span><span class="op">(</span><span class="va">int.bmmc</span>, distance <span class="op">=</span> <span class="st">'cosine'</span>, nNeighbors <span class="op">=</span> <span class="fl">30</span>, minDist <span class="op">=</span> <span class="fl">0.3</span><span class="op">)</span></span></code></pre></div>
<p><strong>12.</strong> We can then visualize each cell, colored by
cluster or dataset.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>ligerDotSize <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plotDimRed.html">plotByDatasetAndCluster</a></span><span class="op">(</span><span class="va">int.bmmc</span>, labelTextSize <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="Integrating_scRNA_and_scATAC_data_files/figure-html/unnamed-chunk-4-1.png" width="960" style="display: block; margin: auto;"></p>
<p><strong>13.</strong> LIGER employs the Wilcoxon rank-sum test to
identify marker genes that are differentially expressed in each cell
type using the following settings. We provide parameters that allow the
user to select which datasets to use (<code>useDatasets</code>) and
whether to compare across clusters or across datasets within each
cluster (<code>method</code> with options <code>"clusters"</code> or
<code>"datasets"</code>). To identify marker genes for each cluster
combining scATAC and scRNA profiles, typing in:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc.wilcoxon</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/runWilcoxon.html">runWilcoxon</a></span><span class="op">(</span><span class="va">int.bmmc</span>, method <span class="op">=</span> <span class="st">'clusters'</span><span class="op">)</span></span></code></pre></div>
<p>Important parameters of runWilcoxon are as follows:</p>
<ul>
<li>
<code>useDatasets</code>. This selects which dataset(s) to be
included. By default all datasets are included.</li>
<li>
<code>method</code>. This indicates whether to compare across
clusters or across datasets with each cluster. Setting
<code>method = "clusters"</code> compares each feature’s (genes, peaks,
etc.) loading between clusters combining all datasets, which gives us
the most specific features for each cluster. On the other hand, setting
<code>method = "datasets"</code> gives us the most differentially loaded
features for every cluster between datasets.</li>
</ul>
<p><strong>14.</strong> The number of marker genes identified by
<code><a href="../reference/runWilcoxon.html">runWilcoxon()</a></code> varies and depends on the datasets used. The
function outputs a data.frame that the user can then filter to select
markers which are statistically and biologically significant. For
example, one strategy is to filter the output by taking markers which
have <code>padj</code> (Benjamini-Hochberg adjusted p-value) less than
0.05 and <code>logFC</code> (log fold change between observations in
group versus out) larger than 3:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc.wilcoxon</span> <span class="op">&lt;-</span> <span class="va">int.bmmc.wilcoxon</span><span class="op">[</span><span class="va">int.bmmc.wilcoxon</span><span class="op">$</span><span class="va">padj</span> <span class="op">&lt;</span> <span class="fl">0.05</span>,<span class="op">]</span></span>
<span><span class="va">int.bmmc.wilcoxon</span> <span class="op">&lt;-</span> <span class="va">int.bmmc.wilcoxon</span><span class="op">[</span><span class="va">int.bmmc.wilcoxon</span><span class="op">$</span><span class="va">logFC</span> <span class="op">&gt;</span> <span class="fl">3</span>,<span class="op">]</span></span></code></pre></div>
<p>You can then re-sort the markers by its <code>padj</code> value in
ascending order and choose the top 100 for each cell type. For example,
we can subset and re-sort the output for Cluster 1 and take the top 20
markers by typing these commands:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wilcoxon.cluster_1</span> <span class="op">&lt;-</span> <span class="va">int.bmmc.wilcoxon</span><span class="op">[</span><span class="va">int.bmmc.wilcoxon</span><span class="op">$</span><span class="va">group</span> <span class="op">==</span> <span class="fl">1</span>, <span class="op">]</span></span>
<span><span class="va">wilcoxon.cluster_1</span> <span class="op">&lt;-</span> <span class="va">wilcoxon.cluster_1</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">wilcoxon.cluster_1</span><span class="op">$</span><span class="va">padj</span><span class="op">)</span>, <span class="op">]</span></span>
<span><span class="va">markers.cluster_1</span> <span class="op">&lt;-</span> <span class="va">wilcoxon.cluster_1</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, <span class="op">]</span></span></code></pre></div>
<p><strong>15.</strong> We also provide functions to check these markers
by visualizing their expression and gene loadings across datasets. You
can use the <code><a href="../reference/plotDimRed.html">plotGeneDimRed()</a></code> to visualize the expression or
accessibility of a marker gene, which is helpful for visually confirming
putative marker genes or investigating the distribution of known markers
across the cell sequenced. Such plots can also confirm that divergent
datasets are properly aligned.</p>
<p>For instance, we can plot S100A9, which the Wilcoxon test identified
as a marker for Cluster 1, and MS4A1, a marker for Cluster 4:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plots</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/plotDimRed.html">plotGeneDimRed</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"S100A9"</span>, <span class="st">"MS4A1"</span><span class="op">)</span>, splitBy <span class="op">=</span> <span class="st">"dataset"</span>, </span>
<span>                        titles <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">cowplot</span><span class="fu">::</span><span class="fu"><a href="https://wilkelab.org/cowplot/reference/plot_grid.html" class="external-link">plot_grid</a></span><span class="op">(</span>plotlist <span class="op">=</span> <span class="va">plots</span>, nrow <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Integrating_scRNA_and_scATAC_data_files/figure-html/unnamed-chunk-8-1.png" width="700" style="display: block; margin: auto;"></p>
<p>These plots indicate that S100A9 and MS4A1 are indeed specific
markers for Cluster 1 and Cluster 4, respectively, with high values in
these cell groups and low values elsewhere. Furthermore, we can see that
the distributions are strikingly similar between the RNA and ATAC
datasets, indicating that LIGER has properly aligned the two data
types.</p>
<p><strong>16.</strong> A key advantage of using iNMF instead of other
dimensionality reduction approaches such as PCA is that the dimensions
are individually interpretable. For example, a particular cell type is
often captured by a single dimension of the space. Furthermore, iNMF
identifies both shared and dataset-specific features along each
dimension, giving insight into exactly how corresponding cells across
datasets are both similar and different. Too visualize this information,
users need to run <code><a href="../reference/getFactorMarkers.html">getFactorMarkers()</a></code> first in order to have
the statistics prepared for ranking the factor loading. The function
<code><a href="../reference/plotGeneLoadings.html">plotGeneLoadings()</a></code> then creates visualization for the
exploration. For example, we can visualize the factor loading of Factor
7 typing in:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">factorMarker</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFactorMarkers.html">getFactorMarkers</a></span><span class="op">(</span><span class="va">int.bmmc</span>, dataset1 <span class="op">=</span> <span class="st">"atac"</span>, dataset2 <span class="op">=</span> <span class="st">"rna"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plotGeneLoadings.html">plotGeneLoadings</a></span><span class="op">(</span><span class="va">int.bmmc</span>, markerTable <span class="op">=</span> <span class="va">factorMarker</span>, useFactor <span class="op">=</span> <span class="fl">7</span>, nLabel <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span></code></pre></div>
<p><img src="Integrating_scRNA_and_scATAC_data_files/figure-html/unnamed-chunk-9-1.png" width="700" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plots</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/plotDimRed.html">plotGeneDimRed</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"CCR6"</span>, <span class="st">"NCF1"</span><span class="op">)</span>, splitBy <span class="op">=</span> <span class="st">"dataset"</span>,</span>
<span>                        titles <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">cowplot</span><span class="fu">::</span><span class="fu"><a href="https://wilkelab.org/cowplot/reference/plot_grid.html" class="external-link">plot_grid</a></span><span class="op">(</span>plotlist <span class="op">=</span> <span class="va">plots</span>, nrow <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Integrating_scRNA_and_scATAC_data_files/figure-html/unnamed-chunk-10-1.png" width="700" style="display: block; margin: auto;"></p>
<p>These plots confirm that the expression and accessibility of these
genes show clear differences. CCR6 shows nearly ubiquitous chromatin
accessibility but is expressed only in clusters 2 and 4. The
accessibility is highest in these clusters, but the ubiquitous
accessibility suggests that the expression of CCR6 is somewhat decoupled
from its accessibility, likely regulated by other factors. Conversely,
NCF1 shows high expression in clusters 1, 6, 9, 10, 12, 14 and 16,
despite no clear enrichment in chromatin accessibility within these
clusters. This may again indicate decoupling between the expression and
chromatin accessibility of NCF1. Another possibility is that the
difference is due to technical effects–the gene body of NCF1 is short
(~15KB), and short genes are more difficult to capture in scATAC-seq
than in scRNA-seq because there are few sites for the ATAC-seq
transposon to insert.</p>
<p><strong>17.</strong> Single-cell measurements of chromatin
accessibility and gene expression provide an unprecedented opportunity
to investigate epigenetic regulation of gene expression. Ideally, such
investigation would leverage paired ATAC-seq and RNA-seq from the same
cells, but such simultaneous measurements are not generally available.
However, using LIGER, it is possible to computationally infer
“pseudo-multi-omic” profiles by linking scRNA-seq profiles–using the
jointly inferred iNMF factors–to the most similar scATAC-seq profiles.
After this imputation step, we can perform downstream analyses as if we
had true single-cell multi-omic profiles. For example, we can identify
putative enhancers by correlating the expression of a gene with the
accessibility of neighboring intergenic peaks across the whole set of
single cells.</p>
<blockquote>
<p>For convenience, we have prepared the pre-processed peak-level count
data which is ready to use. The data can be downloaded <a href="https://www.dropbox.com/sh/5e9cy4qabs89kc8/AADy3jDxHx94j6A57t7A42u3a?dl=0" class="external-link">here</a>.</p>
</blockquote>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"GSM4138888_scATAC_BMMC_D5T1_peak_counts.RDS"</span><span class="op">)</span></span></code></pre></div>
<p>You can also expand the following tutorial to start from the
beginning.</p>
<details><summary><b>Detailed CellRanger peak count preprocessing</b></summary><p>To achieve this, we first need a matrix of accessibility counts
within intergenic peaks. The CellRanger pipeline for scATAC-seq outputs
such a matrix by default, so we will use this as our starting point. The
count matrix, peak genomic coordinates, and source cell barcodes output
by CellRanger are stored in a folder named
<code>filtered_peak_matrix/</code> in the output directory. The user can
load these and convert them into a peak-level count matrix by typing
these commands:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">barcodes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table</a></span><span class="op">(</span><span class="st">'/outs/filtered_peak_bc_matrix/barcodes.tsv'</span>, sep <span class="op">=</span> <span class="st">'\t'</span>, header <span class="op">=</span> <span class="cn">FALSE</span>, as.is <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">V1</span></span>
<span><span class="va">peak.names</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table</a></span><span class="op">(</span><span class="st">'/outs/filtered_peak_bc_matrix/peaks.bed'</span>, sep <span class="op">=</span> <span class="st">'\t'</span>, header <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">peak.names</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="va">peak.names</span><span class="op">$</span><span class="va">V1</span>, <span class="st">':'</span>, <span class="va">peak.names</span><span class="op">$</span><span class="va">V2</span>, <span class="st">'-'</span>, <span class="va">peak.names</span><span class="op">$</span><span class="va">V3</span><span class="op">)</span></span>
<span><span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu">readMM</span><span class="op">(</span><span class="st">'/outs/filtered_peak_bc_matrix/matrix.mtx'</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html" class="external-link">dimnames</a></span><span class="op">(</span><span class="va">pmat</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">peak.names</span>, <span class="va">barcodes</span><span class="op">)</span></span></code></pre></div>
</details><br><p><strong>18.</strong> The peak-level count matrix is usually large,
containing hundreds of thousands of peaks. We next filter this set of
peaks to identify those showing cell-type-specific accessibility. To do
this, we perform the Wilcoxon rank-sum test and pick those peaks which
are differentially accessible within a specific cluster. Before running
the test, however, we need to make sure:</p>
<ol style="list-style-type: decimal">
<li>The peak-level count matrix includes the same cells as the
gene-level counts matrix</li>
<li>Peak count matrix is normalized to sum to 1 within each cell.</li>
</ol>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/peak.html">rawPeak</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="st">"atac"</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">pmat</span></span>
<span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/normalize.html">normalizePeak</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span></span></code></pre></div>
<blockquote>
<p>Recall that we set <code>modal</code> argument when intiating the
object with <code><a href="../reference/createLiger.html">createLiger()</a></code>. This creates “ligerATACDataset”
class object as the dataset-specific container for the ATAC-seq data.
Only in this way can we insert the peak count matrix to its designated
slot with <code>rawPeak&lt;-()</code> method.</p>
</blockquote>
<p>Now we can perform the Wilcoxon test on the peak counts with setting
<code>usePeak = TRUE</code>:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">peak.wilcoxon</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/runWilcoxon.html">runWilcoxon</a></span><span class="op">(</span><span class="va">int.bmmc</span>, useDatasets <span class="op">=</span> <span class="st">"atac"</span>, usePeak <span class="op">=</span> <span class="cn">TRUE</span>, method <span class="op">=</span> <span class="st">'clusters'</span><span class="op">)</span></span></code></pre></div>
<p><strong>19.</strong> We can now use the results of the Wilcoxon test
to retain only peaks showing differential accessibility across our set
of joint clusters. Here we kept peaks with Benjamini-Hochberg adjusted
p-value &lt; 0.05 and log fold change &gt; 2.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">peak.wilcoxon</span> <span class="op">&lt;-</span> <span class="va">peak.wilcoxon</span><span class="op">[</span><span class="va">peak.wilcoxon</span><span class="op">$</span><span class="va">padj</span> <span class="op">&lt;</span> <span class="fl">0.05</span>,<span class="op">]</span></span>
<span><span class="va">peak.wilcoxon</span> <span class="op">&lt;-</span> <span class="va">peak.wilcoxon</span><span class="op">[</span><span class="va">peak.wilcoxon</span><span class="op">$</span><span class="va">logFC</span> <span class="op">&gt;</span> <span class="fl">2</span>,<span class="op">]</span></span>
<span><span class="va">peaks.sel</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">peak.wilcoxon</span><span class="op">$</span><span class="va">feature</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/peak.html">rawPeak</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="st">"atac"</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/peak.html">rawPeak</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="st">"atac"</span><span class="op">)</span><span class="op">[</span><span class="va">peaks.sel</span>,<span class="op">]</span></span>
<span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/normalize.html">normalizePeak</a></span><span class="op">(</span><span class="va">int.bmmc</span><span class="op">)</span></span></code></pre></div>
<p><strong>20.</strong> Using this set of differentially accessible
peaks, we now impute a set of “pseudo-multi-omic” profiles by inferring
the intergenic peak accessibility for scRNA-seq profiles based on their
nearest neighbors in the joint LIGER space. LIGER provides a function
named <code><a href="../reference/imputeKNN.html">imputeKNN()</a></code> that performs this task, yielding a set
of profiles containing both gene expression and chromatin accessibility
measurements for the same single cells:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">int.bmmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/imputeKNN.html">imputeKNN</a></span><span class="op">(</span><span class="va">int.bmmc</span>, reference <span class="op">=</span> <span class="st">'atac'</span>, queries <span class="op">=</span> <span class="st">"rna"</span><span class="op">)</span></span></code></pre></div>
<p>Important parameters of <code><a href="../reference/imputeKNN.html">imputeKNN()</a></code> are as follows:</p>
<ul>
<li>
<code>reference</code>. Dataset containing values to impute into
query dataset(s). For example, setting <code>reference = "atac"</code>
uses the values in dataset “atac” to predict chromatin accessibility
values for scRNA-seq profiles.</li>
<li>
<code>queries</code>. Dataset to be augmented by imputation. For
example, setting <code>query = "rna"</code> predicts chromatin
accessibility values for scRNA-seq profiles.</li>
<li>
<code>nNeighbors</code>. The maximum number of nearest neighbors to
use for imputation. The imputation algorithm simply builds a k-nearest
neighbor graph using the aligned LIGER latent space, then averages
values from the reference dataset across neighboring cells. The default
value is <code>20</code>.</li>
<li>
<code>norm</code>. This indicates whether to normalize data after
imputation. The default is <code>TRUE</code>.</li>
<li>
<code>scale</code>. This indicates whether to scale data after
imputation. The default is <code>FALSE</code>.</li>
</ul>
<blockquote>
<p>Under the hook, <code><a href="../reference/imputeKNN.html">imputeKNN()</a></code> converts the
dataset-specific container object for scRNA-seq data to
“ligerATACDataset” class, which allows storing the predicted chromatin
accessibility values while retaining the gene expression.</p>
</blockquote>
<blockquote>
<p>Old versions of LIGER worked in a way that the predicted
accessibility value occupies the space where the original gene
expression is stored. This usually led to the creation of a new object
when running the imputation. Now both types of features are allowed to
exist together, so users do not need to create a new object anymore.</p>
</blockquote>
<p><strong>21.</strong> Now that we have both the (imputed) peak-level
counts matrix and the (observed) gene expression counts matrix for the
same cells, we can evaluate the relationships between pairs of genes and
peaks, linking genes to putative regulatory elements. We use a simple
strategy to identify such gene-peak links: Calculate correlation between
gene expression and peak accessibility of all peaks within 500 KB of a
gene, then retain all peaks showing statistically significant
correlation with the gene. The <code><a href="../reference/linkGenesAndPeaks.html">linkGenesAndPeaks()</a></code> function
performs this analysis:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">regnet</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/linkGenesAndPeaks.html">linkGenesAndPeaks</a></span><span class="op">(</span><span class="va">int.bmmc</span>, useDataset <span class="op">=</span> <span class="st">"rna"</span>, pathToCoords <span class="op">=</span> <span class="st">"hg19_genes.bed"</span>, method <span class="op">=</span> <span class="st">"spearman"</span>, alpha <span class="op">=</span> <span class="fl">0.05</span>, useGenes <span class="op">=</span> , verbose <span class="op">=</span> , path_to_coords <span class="op">=</span> , genes.list <span class="op">=</span> , dist <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<p>Important parameters of linkGenesAndPeaks are as follows:</p>
<ul>
<li>
<code>useGenes</code>. A vector of the genes to be tested. If not
specified, this function will use all available genes in the dataset
specified by <code>useDataset</code> by default.</li>
<li>
<code>method</code>. This specifies the type of correlation to
calculate – one of <code>"spearman"</code> (default),
<code>"pearson"</code>, or <code>"kendall"</code>.</li>
<li>
<code>alpha</code>. Significance threshold for correlation p-value.
Peak-gene correlations with p-values below this threshold are considered
significant. The default is <code>0.05</code>.</li>
<li>
<code>pathToCoords</code>. The path to the gene coordinates file (in
BED format). We recommend passing in the same BED file used for making
barcode list in <strong>Step 1</strong> (need to expand the CellRanger
preprocessing block).</li>
</ul>
<p><strong>22.</strong> The output of this function is a sparse matrix
with peak names as rows and gene symbols as columns, with each element
indicating the correlation between peak <em>i</em> and gene <em>j</em>.
The value would be 0 if the corresponding gene and peak are not
significantly linked. For example, we can subset the results for marker
gene S100A9, which is highly expressed in cluster 6, 8, 9, 10 and
12:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">S100A9</span> <span class="op">&lt;-</span> <span class="va">regnet</span><span class="op">[</span>, <span class="st">'S100A9'</span><span class="op">]</span></span>
<span><span class="va">S100A9</span> <span class="op">&lt;-</span> <span class="va">S100A9</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">S100A9</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/View.html" class="external-link">View</a></span><span class="op">(</span><span class="va">S100A9</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">S100A9</span><span class="op">)</span>, decreasing <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>We also provide a function to transform the peaks-gene correlation
matrix into an Interact Track supported by UCSC Genome Browser for
visualizing the calculated linkage between genes and correlated peaks.
To do this, tying in:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/exportInteractTrack.html">exportInteractTrack</a></span><span class="op">(</span><span class="va">regnet</span>, useGenes <span class="op">=</span> <span class="st">"S100A9"</span>, pathToCoords <span class="op">=</span> <span class="st">"hg19_genes.bed"</span><span class="op">)</span></span></code></pre></div>
<p>Important parameters of makeInteractTrack are as follows:</p>
<ul>
<li>
<code>corrMat</code>. A peaks x genes sparse matrix containing
inferred gene-peak links, the output of
<code><a href="../reference/linkGenesAndPeaks.html">linkGenesAndPeaks()</a></code>.</li>
<li>
<code>useGenes</code>. A vector of the gene symbols to be included
in the output Interact Track file. If not specified, this function will
use all the gene symbols from <code>corrMat</code> by default.</li>
<li>
<code>pathToCoords</code>. The path to the gene coordinates file (in
BED format). We recommend passing in the same BED file path as used for
<code><a href="../reference/linkGenesAndPeaks.html">linkGenesAndPeaks()</a></code>.</li>
<li>
<code>outputPath</code>. The path to the directory in which the
Interact Track file will be stored. The default is the working
directory.</li>
</ul>
<p>The output of this function will be a UCSC Interact Track file named
‘Interact_Track.bed’ containing linkage information of the specified
genes and correlated peaks stored in given directory. The user can then
upload this file as a custom track using this page <a href="https://genome.ucsc.edu/cgi-bin/hgCustom" class="external-link uri">https://genome.ucsc.edu/cgi-bin/hgCustom</a> and display it
in the UCSC Genome browser.</p>
<p>As an example, the three peaks most correlated to S100A9 expression
are shown below in the UCSC genome browser. One of the peaks overlaps
with the TSS of S100A8, a neighboring gene that is co-expressed with
S100A9, while another peak overlaps with the TSS of S100A9 itself. The
last peak, chr1:153358896-153359396, does not overlap with a gene body
and shows strong H3K27 acetylation across ENCODE cell lines, indicating
that this is likely an intergenic regulatory element.</p>
<p><img src="img/S100A9_link.png"></p>
<p>If we plot the accessibility of this peak and the expression of
S100A9, we can see that the two are indeed very correlated and show
strong enrichment in clusters 1 and 3. Thus, the intergenic peak likely
serves as a cell-type-specific regulator of S100A9.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">S100A9</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/plotDimRed.html">plotGeneDimRed</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="st">"S100A9"</span>, splitBy <span class="op">=</span> <span class="st">"dataset"</span><span class="op">)</span></span>
<span><span class="va">peak1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/plotDimRed.html">plotPeakDimRed</a></span><span class="op">(</span><span class="va">int.bmmc</span>, <span class="st">"chr1:153358896-153359396"</span><span class="op">)</span></span>
<span><span class="fu">cowplot</span><span class="fu">::</span><span class="fu"><a href="https://wilkelab.org/cowplot/reference/plot_grid.html" class="external-link">plot_grid</a></span><span class="op">(</span><span class="va">peak1</span>, <span class="va">S100A9</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>, nrow <span class="op">=</span> <span class="fl">2</span>, align <span class="op">=</span> <span class="st">"v"</span>, axis <span class="op">=</span> <span class="st">"lr"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Integrating_scRNA_and_scATAC_data_files/figure-html/unnamed-chunk-20-1.png" width="576" style="display: block; margin: auto;"></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Joshua Welch, Chao Gao, Jialin Liu, Joshua Sodicoff, Velina Kozareva, Evan Macosko, Yichen Wang.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
