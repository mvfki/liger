[{"path":[]},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"loading-data","dir":"Articles","previous_headings":"Stage I: Preprocessing and Normalization","what":"1. Loading data","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"first portion protocol, integrating data control interferon-stimulated PBMCs Kang et al, 2017. data can found Gene Expression Omnibus, Series GSE96583. dataset originally form output 10X Cellranger pipeline, though directly load downsampled versions control stimulated DGEs . convenience, prepared pre-processed data ready use. two datasets: PBMC control PBMC interferon-stimulated. provided ready--use liger object, can easily loaded importPBMC(). creating liger object raw counts data types source, please refer detailed tutorial importing data.","code":"library(rliger) pbmcLiger <- importPBMC()"},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"preprocess","dir":"Articles","previous_headings":"Stage I: Preprocessing and Normalization","what":"2. Preprocess","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"can run iNMF datasets, must run several preprocessing steps normalize expression data account differences sequencing depth efficiency cells, identify variably expressed genes, scale data gene variance. Note nonnegative matrix factorization requires positive values, center data subtracting mean. also log transform data.","code":"pbmcLiger <- pbmcLiger %>%     normalize() %>%     selectGenes() %>%     scaleNotCenter()"},{"path":[]},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"determine-parameters-and-perform-inmf-integration","dir":"Articles","previous_headings":"Stage II: Integration with Joint Matrix Factorization","what":"3. Determine parameters and perform iNMF integration","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"now able run integrative non-negative matrix factorization (iNMF) normalized scaled datasets. key parameter analysis k, number matrix factors (analogous number principal components PCA). general, find value k 20 40 suitable analyses results robust choice k. LIGER unsupervised, exploratory approach, single “right” value k. practice, users choose k combination biological prior knowledge information. tutorial, set k = 20. Starting rliger 2.0.0, use optimized implementation iNMF. deprecated parameter thresh stands convergence detecter order speed algorithm iteration omitting calculation objective error. factorization yields several lower dimension matrices, including \\(H\\) matrices metagene loadings cell, \\(W\\) matrix shared factor loadings \\(V\\) matrices dataset-specific factor loadings. Please refer liger object documentation access . time consumption step dependent size datasets, terms number cells, number variable genes selected, value k. implementation supports OpenMP multi-threading, using machine number cores allocated helps speeding .","code":"pbmcLiger <- runIntegration(pbmcLiger, k = 20)"},{"path":[]},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"align-the-factors","dir":"Articles","previous_headings":"Stage III: Quantile Normalization and Joint Clustering","what":"4. Align the factors","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"can now use resulting factors jointly cluster cells perform quantile normalization dataset, factor, cluster fully integrate datasets. functionality encapsulated within quantileNorm() function, uses max factor assignment followed refinement using k-nearest neighbors graph.","code":"pbmcLiger <- quantileNorm(pbmcLiger)"},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"clustering","dir":"Articles","previous_headings":"Stage III: Quantile Normalization and Joint Clustering","what":"5. Clustering","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"quantileNorm() procedure produces joint clustering assignments low-dimensional representation integrates datasets together. joint clusters directly iNMF can used downstream analyses (see ). Alternatively, can also run Louvain community detection, algorithm commonly used single-cell data, normalized cell factors. Louvain algorithm excels merging small clusters broad cell classes thus may desirable cases maximum factor assignments produced directly iNMF. Starting rliger 2.0.0, cluster labeling stored cell metadata, can accessed cellMeta(pbmcLiger). Use argument clusterName specify unique variable names result can enable storing multiple cluster labeling variables time.","code":"pbmcLiger <- runCluster(pbmcLiger, resolution = 0.25, nNeighbors = 30)"},{"path":[]},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"generate-dimensionality-reduced-embedding","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"6. Generate dimensionality reduced embedding","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"visualize clustering cells graphically, can project normalized cell factors two three dimensions. LIGER supports UMAP t-SNE purpose. Starting rliger 2.0.0, dimensionality reduction matrices stored cell metadata, can accessed cellMeta(pbmcLiger). Use argument dimredName specify unique variable names result can enable storing multiple low-dimensional representation matrices variables time.","code":"pbmcLiger <- runUMAP(pbmcLiger, n_neighbors = 30, min_dist = 0.3)"},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"create-plots","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"7. Create plots","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"provide variety utilities visualization analysis clustering, gene expression across datasets, comparisons cluster assignments. demonstrate several commonly used examples. plotByDatasetAndCluster() returns two graphs, generated t-SNE UMAP previous step. first colors cells dataset origin, second cluster determined previous clustering step. plots provide visual confirmation datasets well aligned clusters consistent shape data revealed UMAP. two subplots can individually generated plotDatasetDimRed() plotClusterDimRed(), respectively.  directly study impact factors clustering determine genes load highly factor, use plotGeneLoadings() function, returns plots factor loading dimensionality reduction highly loaded genes dataset factor.","code":"plotByDatasetAndCluster(pbmcLiger) factorMarkers <- getFactorMarkers(pbmcLiger, dataset1 = \"ctrl\", dataset2 = \"stim\") plotGeneLoadings(pbmcLiger, markerTable = factorMarkers, useFactor = 11)"},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"differential-expression","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"8. Differential expression","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"Using runMarkerDEG() function, can next identify gene markers clusters. can also compare expression within cluster across datasets, case reveals markers interferon-beta stimulation. function returns table data allows us determine significance gene’s differential expression, including log fold change, area curve (auc) p-value. default parameters performs Wilcoxon rank-sum test cluster level: Alternatively, also helpful identify dataset specific markers within cluster. example tutorial, can split data cluster labeling, within cluster, find markers interferon-stimulated cells. number significant genes identified runMarkerDEG() varies depends datasets used. raw output function contains statistics tested genes groups (clusters). order pick top markers cluster, strongly suggest using package “dplyr”, provides user-friendly interface data table manipulation. following code chunk first filters markers statistically biologically significant. example, filter output taking markers padj (Benjamini-Hochberg adjusted p-value) less 0.05 logFC (log fold change observations group versus ) larger 3. cluster, sort markers primarily padj value ascending order. Given mathematically, lowest padj values rounded 0 small, genes tying metric, sort markers logFC descending order. Finally, select top 20 markers cluster. can visualize expression profiles individual genes, differentially expressed genes just identified. allows us visually confirm cluster- dataset-specific expression patterns marker genes. plotGeneDimRed() returns graphs gene loading dimensionality reduced graph dataset.  can also plot gene expression dataset.  can also use plotGeneDimRed() compare loading cluster markers within datasets.","code":"cluster.results <- runMarkerDEG(pbmcLiger) head(cluster.results) ##     feature group     avgExpr        logFC statistic       auc          pval ## 1 LINC00115     0  0.06548765 -0.006831338  19062921 0.4998240  7.853272e-01 ## 2     NOC2L     0  0.42171394 -0.918042058  17940417 0.4703922  1.451809e-33 ## 3    KLHL17     0  0.01231308 -0.009050681  19059126 0.4997245  4.088815e-01 ## 4   PLEKHN1     0  0.18786561  0.141525882  19248732 0.5046959  3.409058e-11 ## 5      HES4     0  4.77875763  3.499327819  23294848 0.6107838 3.386982e-241 ## 6     ISG15     0 13.53868172  2.108323599  25067656 0.6572663 7.671903e-185 ##            padj      pct_in    pct_out ## 1  8.183645e-01  0.43184885  0.4662910 ## 2  1.239673e-32  2.80701754  8.5583835 ## 3  4.694960e-01  0.08097166  0.1360016 ## 4  1.313878e-10  1.24156545  0.3011463 ## 5 1.329469e-239 30.47233468  8.1212357 ## 6 2.522435e-183 71.39001350 64.4744511 datasets.results <- runMarkerDEG(pbmcLiger, conditionBy = \"dataset\", splitBy = \"leiden_cluster\") head(datasets.results$`0`) # Note that the first cluster is \"0\" ##     feature group    avgExpr        logFC statistic          auc          pval ## 1 LINC00115  ctrl 0.07166558   0.01145033 1706331.0 0.5003471841  7.481448e-01 ## 2     NOC2L  ctrl 0.66238229   0.44606115 1755645.5 0.5148076676  5.381518e-08 ## 3    KLHL17  ctrl 0.02674089   0.02674089 1708145.5 0.5008792497  6.078022e-02 ## 4   PLEKHN1  ctrl 0.09743044  -0.16761495 1686271.0 0.4944649933  2.425606e-03 ## 5      HES4  ctrl 0.18860594  -8.50750976  777066.5 0.2278590937 7.338249e-270 ## 6     ISG15  ctrl 6.06724941 -13.84775223    2253.0 0.0006606469  0.000000e+00 ##            padj     pct_in     pct_out ## 1  8.307976e-01  0.4689332   0.4002001 ## 2  3.399928e-07  4.3962485   1.4507254 ## 3  1.222348e-01  0.1758499   0.0000000 ## 4  7.540483e-03  0.6447831   1.7508754 ## 5 1.330165e-267  1.2309496  55.4277139 ## 6  0.000000e+00 37.8663540 100.0000000 library(dplyr) cluster.results.sort <- cluster.results %>%     filter(padj < 0.05, logFC > 3) %>%     group_by(group) %>%     arrange(padj, -logFC, .by_group = TRUE) %>%     top_n(20)# rank by logFC from high to low  # Show the markers for cluster 3 cluster.results.sort %>% filter(group == 3) ## # A tibble: 20 × 10 ## # Groups:   group [1] ##    feature  group avgExpr logFC statistic   auc      pval      padj pct_in ##    <chr>    <fct>   <dbl> <dbl>     <dbl> <dbl>     <dbl>     <dbl>  <dbl> ##  1 HLA-DRA  3        17.3  8.39 14100526. 0.799 0         0           97.7 ##  2 CD74     3        17.9  6.98 16152993  0.916 0         0           99   ##  3 HLA-DPA1 3        14.5  7.73 13702221  0.777 1.20e-300 8.06e-298   87.1 ##  4 RPS5     3        17.0  3.20 13758954. 0.780 9.82e-261 5.22e-258   98.2 ##  5 HLA-DPB1 3        13.5  6.70 13268518. 0.752 2.85e-250 1.35e-247   81.1 ##  6 HLA-DRB1 3        15.3  7.20 13211092. 0.749 4.07e-230 1.53e-227   90   ##  7 CCR7     3        14.0  7.13 13007309  0.737 1.68e-223 5.63e-221   82.9 ##  8 RPL10A   3        16.2  3.85 12703108  0.720 1.63e-163 3.42e-161   95   ##  9 EEF1B2   3        13.1  4.34 12423802. 0.704 9.61e-151 1.75e-148   80   ## 10 RPLP0    3        15.5  3.55 12478185  0.707 1.10e-145 1.78e-143   92.4 ## 11 HSP90AB1 3        12.4  3.64 12326966. 0.699 1.64e-143 2.55e-141   74.7 ## 12 RPL5     3        14.5  4.01 12303018. 0.698 4.56e-135 6.39e-133   87.2 ## 13 RPSA     3        14.8  3.95 12264988. 0.695 2.63e-131 3.46e-129   89   ## 14 CXCR4    3        12.9  3.79 12112580. 0.687 4.18e-126 4.98e-124   76   ## 15 RPL7A    3        14.9  3.02 12189771  0.691 5.58e-124 6.35e-122   89.6 ## 16 RAN      3        10.9  3.43 11846094. 0.672 1.83e-113 1.82e-111   66.6 ## 17 RPL4     3        13.8  3.25 11916704. 0.676 3.40e-107 2.93e-105   83.3 ## 18 NPM1     3        12.2  3.75 11808654. 0.669 3.96e-106 3.34e-104   73.6 ## 19 CREM     3        10.1  3.36 11180874. 0.634 1.56e- 73 8.82e- 72   61.6 ## 20 GLTSCR2  3        10.2  3.24 11121632  0.631 1.34e- 68 6.96e- 67   63.3 ## # ℹ 1 more variable: pct_out <dbl> plotGeneDimRed(pbmcLiger, \"PRF1\") prf1List <- plotGeneDimRed(pbmcLiger, \"PRF1\", splitBy = \"dataset\") cowplot::plot_grid(plotlist = prf1List, labels = names(prf1List)) IFIT3 <- plotGeneDimRed(pbmcLiger, \"IFIT3\", splitBy = \"dataset\") IFITM3 <- plotGeneDimRed(pbmcLiger, \"IFITM3\", splitBy = \"dataset\") cowplot::plot_grid(IFIT3[[1]], IFIT3[[2]], IFITM3[[1]], IFITM3[[2]], ncol = 2, labels = c(\"ctrl\", \"stim\", \"ctrl\", \"stim\"))"},{"path":"/articles/Integrating_multi_scRNA_data.html","id":"r-session-info","dir":"Articles","previous_headings":"","what":"R Session Info","title":"Joint definition of cell types from multiple scRNA-seq datasets","text":"","code":"## R version 4.3.2 RC (2023-10-30 r85440) ## Platform: aarch64-apple-darwin20 (64-bit) ## Running under: macOS Sonoma 14.4 ##  ## Matrix products: default ## BLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib  ## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## time zone: America/Detroit ## tzcode source: internal ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] dplyr_1.1.4   rliger_1.99.1 ##  ## loaded via a namespace (and not attached): ##  [1] sass_0.4.8          utf8_1.2.4          generics_0.1.3      ##  [4] stringi_1.8.3       lattice_0.22-5      digest_0.6.34       ##  [7] magrittr_2.0.3      evaluate_0.23       grid_4.3.2          ## [10] fastmap_1.1.1       jsonlite_1.8.8      Matrix_1.6-5        ## [13] ggrepel_0.9.5       scattermore_1.2     purrr_1.0.2         ## [16] fansi_1.0.6         viridisLite_0.4.2   scales_1.3.0        ## [19] codetools_0.2-19    textshaping_0.3.7   jquerylib_0.1.4     ## [22] cli_3.6.2           rlang_1.1.3         RcppAnnoy_0.0.22    ## [25] uwot_0.1.16         cowplot_1.1.3       munsell_0.5.0       ## [28] withr_3.0.0         RANN_2.6.1          cachem_1.0.8        ## [31] yaml_2.3.8          parallel_4.3.2      tools_4.3.2         ## [34] memoise_2.0.1       colorspace_2.1-0    ggplot2_3.4.4       ## [37] sccore_1.0.4        BiocGenerics_0.48.1 vctrs_0.6.5         ## [40] R6_2.5.1            stats4_4.3.2        lifecycle_1.0.4     ## [43] stringr_1.5.1       S4Vectors_0.40.2    fs_1.6.3            ## [46] irlba_2.3.5.1       ragg_1.2.7          leidenAlg_1.1.2     ## [49] pkgconfig_2.0.3     desc_1.4.3          pkgdown_2.0.7       ## [52] bslib_0.6.1         pillar_1.9.0        gtable_0.3.4        ## [55] glue_1.7.0          Rcpp_1.0.12         systemfonts_1.0.5   ## [58] highr_0.10          xfun_0.41           tibble_3.2.1        ## [61] tidyselect_1.2.0    rstudioapi_0.15.0   knitr_1.45          ## [64] farver_2.1.1        igraph_2.0.1.1      htmltools_0.5.7     ## [67] labeling_0.4.3      rmarkdown_2.25      RcppPlanc_1.0.0     ## [70] compiler_4.3.2"},{"path":[]},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"loading-data","dir":"Articles","previous_headings":"Stage I: Preprocessing and Normalization","what":"1. Loading data","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"order jointly analyze scRNA scATAC-seq data, first need transform scATAC-seq data–genome-wide epigenomic measurement–gene-level counts comparable gene expression data scRNA-seq. previous single-cell studies used approach inspired traditional bulk ATAC-seq analysis: identifying chromatin accessibility peaks, summing together peaks overlap gene. strategy also appealing 10X CellRanger pipeline, commonly used commercial package, automatically outputs peak counts. However, find strategy less desirable : (1) peak calling performed using cells, biases rare cell populations; (2) gene body accessibility often diffuse specific regulatory elements, thus may missed peak calling algorithms; (3) information reads outside peaks discarded, reducing amount data already sparse measurements. Instead summing peak counts, find simplest possible strategy seems work well: counting total number ATAC-seq reads within gene body promoter region (typically 3 kb upstream) gene cell. convenience, prepared pre-processed data ready use, provided GreenleafLab. GSM4138872_scRNA_BMMC_D1T1.rds GSM4138873_scRNA_BMMC_D1T2.rds GSM4138888_scATAC_BMMC_D5T1.RDS GSM4138888_scATAC_BMMC_D5T1_peak_counts.RDS hg19_genes.bed","code":"library(rliger) if (!file.exists(\"liger_BMMC_rna_D1T1.rds\"))     download.file(\"https://figshare.com/ndownloader/files/40054858\",                   destfile = \"liger_BMMC_rna_D1T1.rds\") D1T1 <- readRDS(\"liger_BMMC_rna_D1T1.rds\")  if (!file.exists(\"liger_BMMC_rna_D1T2.rds\"))     download.file(\"https://figshare.com/ndownloader/files/40054861\",                   destfile = \"liger_BMMC_rna_D1T2.rds\") D1T2 <- readRDS(\"liger_BMMC_rna_D1T2.rds\")  if (!file.exists(\"liger_BMMC_atac_D5T1.rds\"))     download.file(\"https://figshare.com/ndownloader/files/40054891\",                   destfile = \"liger_BMMC_atac_D5T1.rds\") D5T1 <- readRDS(\"liger_BMMC_atac_D5T1.rds\")"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"start-from-cellranger-output","dir":"Articles","previous_headings":"Stage I: Preprocessing and Normalization > 1. Loading data","what":"Start from CellRanger output","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"can also follow following tutorial like start beginning. Note part, included details running preprocessing workflow one sample. Users re-run counting step multiple times one scATAC-seq sample. Note also several commands need run Command Line Interface instead R Console IDE (RStudio). also employ bedmap command BEDOPS tool make list cell barcodes overlap gene promoter. gene body promoter indexes .bed files, indicate gene promoter coordinates. Since bedmap expects sorted inputs, fragment output CellRanger, gene body promoter indexes sorted. show perform steps scATAC data generated 10X Chromium system, widely used scATAC-seq protocol. starting input process file fragments.tsv output CellRanger, contains ATAC reads passed filtering steps. Note: 1. don’t provide actual example input data demonstration block. Users need try data. 2. Part preprocessing steps carried command-line interface (cmd/terminal). 3. Please pay attention file directory paths left placeholders. Users replace paths. 1. must first sort fragments.tsv chromosome, start, end position using sort command line utility. -k option lets user sort file certain column; including multiple -k options allows sorting multiple columns simultaneously. n behind -k stands “numeric ordering”. sorted BED file order defined first lexicographic chromosome order (using parameter -k1,1), ascending integer start coordinate order (using parameter -k2,2n), finally ascending integer end coordinate order (using parameter -k3,3n). Note step may take , since input fragment file usually large (example, typical fragment file 4-5 GB can take 40 minutes). Gene body promoter indexes also sorted using strategy sorting fragments output files: 2. Use bedmap command calculate overlapping elements indexes fragment output files: Important flags bedmap command follows: --delim. changes output delimiter ‘|’ indicated delimiter columns, case “\\t”. --ec. Adding check problematic input files. --echo. Adding print line reference file output. reference file case gene promoter index. --echo-map-id. Adding list IDs overlapping elements mapping files, case cell barcodes fragment files. 3. import bedmap outputs R Console RStudio. Note .option read.table() specified prevent conversion character columns factor columns: Cell barcodes split extracted outputs. recommend user filter barcodes total number reads lower certain threshold, example, 1500. threshold can adjusted according size quality samples. 4. can use LIGER’s makeFeatureMatrix() function calculate accessibility counts gene body promoter individually. function takes output bedmap efficiently counts number fragments overlapping gene promoter. count genes promoters single step, choose calculate separately case necessary look gene promoter accessibility individually downstream analyses. Next, two count matrices need re-sorted gene symbol. add matrices together, yielding single matrix gene accessibility counts cell. 5. gene-level scATAC-seq counts generated, read10X() function LIGER can used read scRNA-seq count matrices output CellRanger. can pass directory (list directories) containing raw outputs (example, \"/Sample_1/outs/filtered_feature_bc_matrix\") parameter sample.dirs. Next, vector names use sample (samples, corresponding sample.dirs) passed parameter sample.names well. LIGER can also use data protocol, long provided genes x cells R matrix format.","code":"# shell sort -k1,1 -k2,2n -k3,3n GSM4138888_scATAC_BMMC_D5T1.fragments.tsv > atac_fragments.sort.bed # shell sort -k 1,1 -k2,2n -k3,3n hg19_genes.bed > hg19_genes.sort.bed sort -k 1,1 -k2,2n -k3,3n hg19_promoters.bed > hg19_promoters.sort.bed # shell bedmap --ec --delim \"\\t\" --echo --echo-map-id hg19_promoters.sort.bed atac_fragments.sort.bed > atac_promoters_bc.bed bedmap --ec --delim \"\\t\" --echo --echo-map-id hg19_genes.sort.bed atac_fragments.sort.bed > atac_genes_bc.bed # R genes.bc <- read.table(file = \"atac_genes_bc.bed\", sep = \"\\t\", as.is = c(4,7), header = FALSE) promoters.bc <- read.table(file = \"atac_promoters_bc.bed\", sep = \"\\t\", as.is = c(4,7), header = FALSE) # R bc <- genes.bc[,7] bc_split <- strsplit(bc,\";\") bc_split_vec <- unlist(bc_split) bc_unique <- unique(bc_split_vec) bc_counts <- table(bc_split_vec) bc_filt <- names(bc_counts)[bc_counts > 1500] barcodes <- bc_filt # R library(rliger) gene.counts <- makeFeatureMatrix(genes.bc, barcodes) promoter.counts <- makeFeatureMatrix(promoters.bc, barcodes) # R gene.counts <- gene.counts[order(rownames(gene.counts)),] promoter.counts <- promoter.counts[order(rownames(promoter.counts)),] D5T1 <- gene.counts + promoter.counts colnames(D5T1)=paste0(\"D5T1_\",colnames(D5T1)) # R bmmc.rna <- read10X(path = \"/path_to/filtered_feature_barcode_matrix\", sampleNames = \"rna\")"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"preprocessing","dir":"Articles","previous_headings":"Stage I: Preprocessing and Normalization","what":"2. preprocessing","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"can now create LIGER object createLiger() function. also remove unneeded variables conserve memory. Additionally, merge two RNA datasets one. Preprocessing steps needed running iNMF. dataset normalized account differences total gene-level counts across cells using normalize function. Next, highly variable genes dataset identified combined use downstream analysis. Note setting parameter useDataset = \"rna\", genes selected scRNA-seq dataset (second dataset) selectGenes() function. recommend using ATAC-seq data variable gene selection statistical properties ATAC-seq data different scRNA-seq, violating assumptions made statistical model developed selecting genes RNA data. Finally, scaleNotCenter() function scales normalized datasets without centering mean, giving non-negative input data required iNMF.","code":"bmmc.rna <- cbind(D1T1, D1T2) bmmcLiger <- createLiger(list(atac = D5T1, rna = bmmc.rna),                         modal = c(\"atac\", \"rna\")) bmmcLiger <- bmmcLiger %>%     normalize() %>%     selectGenes(useDatasets = \"rna\") %>%     scaleNotCenter()"},{"path":[]},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"determine-parameters-and-perform-inmf-integration","dir":"Articles","previous_headings":"Stage II: Joint Matrix Factorization","what":"3. Determine parameters and perform iNMF integration","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"next perform joint matrix factorization (iNMF) normalized scaled RNA ATAC data. step calculates metagenes–sets co-expressed genes distinguish cell populations–containing shared dataset-specific signals. cells represented terms “expression level” metagene, providing low-dimensional representation can used joint clustering visualization. run iNMF scaled datasets, use runIntegration() function proper hyperparameter settings.","code":"bmmcLiger <- runIntegration(bmmcLiger, k = 20)"},{"path":[]},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"align-the-factors","dir":"Articles","previous_headings":"Stage III: Quantile Normalization and Joint Clustering","what":"4. Align the factors","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"Using metagene factors calculated iNMF, assign cell factor highest loading, giving joint clusters correspond across datasets. perform quantile normalization dataset, factor, cluster fully integrate datasets. perform analysis, typing :","code":"bmmcLiger <- quantileNorm(bmmcLiger)"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"clustering","dir":"Articles","previous_headings":"Stage III: Quantile Normalization and Joint Clustering","what":"5. Clustering","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"quantileNorm() function gives joint clusters correspond across datasets, often completely satisfactory sufficient downstream analyses. However, desired, quantile normalization, users can additionally run Leiden algorithm community detection, widely used single-cell analysis excels merging small clusters broad cell classes. can achieved running runCluster() function. Several tuning parameters, including resolution, nNeighbors, prune control number clusters produced function. dataset, use resolution 0.2. Starting rliger 2.0.0, cluster labeling stored cell metadata, can accessed cellMeta(bmmcLiger). Use argument clusterName specify unique variable names result can enable storing multiple cluster labeling variables time.","code":"bmmcLiger <- runCluster(bmmcLiger, nNeighbors = 30, resolution = 0.2)"},{"path":[]},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"generate-dimensionality-reduced-embedding","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"6. Generate dimensionality reduced embedding","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"order visualize clustering results, user can use two dimensionality reduction methods supported LIGER: t-SNE UMAP. find often datasets containing continuous variation cell differentiation, UMAP better preserves global relationships, whereas t-SNE works well displaying discrete cell types, brain. UMAP algorithm (called runUMAP() function) scales readily large datasets. runTSNE() function also includes option use “FFtSNE”, highly scalable implementation t-SNE can efficiently process huge datasets. BMMC dataset, expect see continuous lineage transitions among differentiating cells, use UMAP visualize data two dimensions: Starting rliger 2.0.0, dimensionality reduction matrices stored cell metadata, can accessed cellMeta(bmmcLiger). Use argument dimredName specify unique variable names result can enable storing multiple low-dimensional representation matrices variables time.","code":"bmmcLiger <- runUMAP(bmmcLiger, nNeighbors = 30, minDist = 0.3)"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"create-plots","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"7. Create plots","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"provide variety utilities visualization analysis clustering, gene expression across datasets, comparisons cluster assignments. demonstrate several commonly used examples. plotByDatasetAndCluster() returns two graphs, generated t-SNE UMAP previous step. first colors cells dataset origin, second cluster determined previous clustering step. plots provide visual confirmation datasets well aligned clusters consistent shape data revealed UMAP. two subplots can individually generated plotDatasetDimRed() plotClusterDimRed(), respectively.","code":"options(ligerDotSize = 0.5) plotByDatasetAndCluster(bmmcLiger)"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"differential-expression","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"8. Differential expression","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"LIGER employs Wilcoxon rank-sum test identify marker genes differentially expressed cell type using following settings. provide parameters allow user select datasets use (useDatasets) whether compare across clusters across datasets within cluster (method options \"clusters\" \"datasets\"). identify marker genes cluster combining scATAC scRNA profiles, typing : number significant genes identified runMarkerDEG() varies depends datasets used. raw output function contains statistics tested genes groups (clusters). order pick top markers cluster, strongly suggest using package “dplyr”, provides user-friendly interface data table manipulation. following code chunk first filters markers statistically biologically significant. example, filter output taking markers padj (Benjamini-Hochberg adjusted p-value) less 0.05 logFC (log fold change observations group versus ) larger 3. cluster, sort markers primarily padj value ascending order. Given mathematically, lowest padj values rounded 0 small, genes tying metric, sort markers logFC descending order. Finally, select top 20 markers cluster. can view selected top 20 markers cluster 1 : also provide functions check markers visualizing expression gene loadings across datasets. can use plotGeneDimRed() visualize expression accessibility marker gene, helpful visually confirming putative marker genes investigating distribution known markers across cell sequenced. plots can also confirm divergent datasets properly aligned. instance, can plot S100A9, Wilcoxon test identified marker Cluster 1, MS4A1, marker Cluster 4:  plots indicate S100A9 MS4A1 indeed specific markers Cluster 1 Cluster 4, respectively, high values cell groups low values elsewhere. Furthermore, can see distributions strikingly similar RNA ATAC datasets, indicating LIGER properly aligned two data types.","code":"marker.cluster <- runMarkerDEG(bmmcLiger) library(dplyr) marker.cluster <- marker.cluster %>%     filter(padj < 0.05, logFC > 3) %>%     group_by(group) %>%     arrange(padj, -logFC, .by_group = TRUE) %>%     top_n(20) marker.cluster %>% filter(group == 3) ## # A tibble: 20 × 10 ## # Groups:   group [1] ##    feature  group avgExpr logFC statistic   auc      pval      padj pct_in ##    <chr>    <fct>   <dbl> <dbl>     <dbl> <dbl>     <dbl>     <dbl>  <dbl> ##  1 HLA-DRB5 3       11.5   6.36 14408466. 0.741 2.43e-238 8.84e-236   71.8 ##  2 POU2F2   3        9.53  5.22 13466692  0.692 1.17e-167 1.96e-165   62.0 ##  3 CD74     3       16.2   4.62 13878368  0.713 2.95e-143 3.65e-141   93.3 ##  4 PRDM2    3        9.24  4.32 13119802  0.674 1.43e-128 1.56e-126   60.6 ##  5 LYN      3        9.55  4.49 13071810. 0.672 4.92e-124 5.10e-122   62.3 ##  6 BACH2    3        8.40  4.37 12795575  0.658 1.48e-119 1.44e-117   55.0 ##  7 ISG20    3       10.9   4.72 13137522  0.675 1.67e-116 1.53e-114   70.8 ##  8 ADK      3        8.10  3.90 12594115  0.647 7.23e-102 5.46e-100   53.3 ##  9 PLEKHA2  3        7.95  3.75 12508320. 0.643 7.47e- 96 5.27e- 94   52.7 ## 10 PRKCB    3       11.8   3.45 12868230. 0.662 4.15e- 88 2.49e- 86   76.3 ## 11 SNX2     3        7.90  3.34 12324160. 0.634 1.65e- 80 8.41e- 79   51.3 ## 12 EZR      3       10.1   3.49 12571052. 0.646 1.98e- 79 9.84e- 78   65.7 ## 13 ANKRD44  3        9.65  3.43 12485332  0.642 3.24e- 77 1.51e- 75   62.6 ## 14 PDE4B    3        8.85  3.41 12287756. 0.632 4.68e- 71 1.93e- 69   58.1 ## 15 IQSEC1   3        7.94  3.19 12166120  0.625 5.95e- 70 2.40e- 68   52.0 ## 16 SMAP2    3        9.94  3.22 12352735  0.635 2.08e- 67 8.05e- 66   65.0 ## 17 DGKD     3        7.23  3.06 11926322. 0.613 2.59e- 61 8.85e- 60   48.1 ## 18 ZBTB20   3        7.55  3.04 11938390  0.614 1.30e- 59 4.28e- 58   49.6 ## 19 STK17A   3        7.90  3.01 11987136. 0.616 3.12e- 59 1.02e- 57   51.7 ## 20 FAM53B   3        7.09  3.02 11781407  0.606 4.61e- 55 1.38e- 53   47.1 ## # ℹ 1 more variable: pct_out <dbl> plots <- plotGeneDimRed(bmmcLiger, c(\"S100A9\", \"MS4A1\"), splitBy = \"dataset\",                         titles = c(names(bmmcLiger), names(bmmcLiger))) cowplot::plot_grid(plotlist = plots, nrow = 2)"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"interpret-the-factors","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"9. Interpret the factors","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"key advantage using iNMF instead dimensionality reduction approaches PCA dimensions (factors) individually interpretable. example, particular cell type often captured single dimension space. Furthermore, iNMF identifies shared dataset-specific features along dimension, giving insight exactly corresponding cells across datasets similar different. visualize information, users need run getFactorMarkers() first order statistics prepared ranking factor loading. function plotGeneLoadings() creates visualization exploration. example, can visualize factor loading Factor 7 typing :   plots confirm expression accessibility genes show clear differences. CCR6 shows nearly ubiquitous chromatin accessibility expressed clusters 2 4. accessibility highest clusters, ubiquitous accessibility suggests expression CCR6 somewhat decoupled accessibility, likely regulated factors. Conversely, NCF1 shows high expression clusters 1, 6, 9, 10, 12, 14 16, despite clear enrichment chromatin accessibility within clusters. may indicate decoupling expression chromatin accessibility NCF1. Another possibility difference due technical effects–gene body NCF1 short (~15KB), short genes difficult capture scATAC-seq scRNA-seq sites ATAC-seq transposon insert.","code":"factorMarker <- getFactorMarkers(bmmcLiger, dataset1 = \"atac\", dataset2 = \"rna\") plotGeneLoadings(bmmcLiger, markerTable = factorMarker, useFactor = 12, nLabel = 15) plots <- plotGeneDimRed(bmmcLiger, c(\"CCR6\", \"NCF1\"), splitBy = \"dataset\",                         titles = c(names(bmmcLiger), names(bmmcLiger))) cowplot::plot_grid(plotlist = plots, nrow = 2)"},{"path":"/articles/Integrating_scRNA_and_scATAC_data.html","id":"inferring-linkage-between-atac-and-rna-data","dir":"Articles","previous_headings":"Stage IV: Visualization and Downstream Analysis","what":"10. Inferring linkage between ATAC and RNA data","title":"Joint definition of cell types from single-cell gene expression and chromatin accessibility data (human bone marrow mononuclear cells)","text":"Single-cell measurements chromatin accessibility gene expression provide unprecedented opportunity investigate epigenetic regulation gene expression. Ideally, investigation leverage paired ATAC-seq RNA-seq cells, simultaneous measurements generally available. However, using LIGER, possible computationally infer “pseudo-multi-omic” profiles linking scRNA-seq profiles–using jointly inferred iNMF factors–similar scATAC-seq profiles. imputation step, can perform downstream analyses true single-cell multi-omic profiles. example, can identify putative enhancers correlating expression gene accessibility neighboring intergenic peaks across whole set single cells. can also expand following tutorial start beginning. achieve , first need matrix accessibility counts within intergenic peaks. CellRanger pipeline scATAC-seq outputs matrix default, use starting point. count matrix, peak genomic coordinates, source cell barcodes output CellRanger stored folder named filtered_peak_matrix/ output directory. user can load convert peak-level count matrix typing commands: peak-level count matrix usually large, containing hundreds thousands peaks. next filter set peaks identify showing cell-type-specific accessibility. , perform Wilcoxon rank-sum test pick peaks differentially accessible within specific cluster. running test, however, need make sure: peak-level count matrix includes cells gene-level counts matrix Peak count matrix normalized sum 1 within cell. Recall set modal argument intiating object createLiger(). creates “ligerATACDataset” class object dataset-specific container scATAC data. way can insert peak count matrix designated slot rawPeak<-() method. Now can perform Wilcoxon test peak counts setting usePeak = TRUE: can now use results Wilcoxon test retain peaks showing differential accessibility across set joint clusters. kept peaks Benjamini-Hochberg adjusted p-value < 0.05 log fold change > 2. Using set differentially accessible peaks, now impute set “pseudo-multi-omic” profiles inferring intergenic peak accessibility scRNA-seq profiles based nearest neighbors joint LIGER space. LIGER provides function named imputeKNN() performs task, yielding set profiles containing gene expression chromatin accessibility measurements single cells: hook, imputeKNN() converts dataset-specific container object scRNA-seq data “ligerATACDataset” class, allows storing predicted chromatin accessibility values retaining gene expression. Old versions LIGER worked way predicted accessibility value occupies space original gene expression stored. usually led creation new object running imputation. Now types features allowed exist together, users need create new object anymore. Now (imputed) peak-level counts matrix (observed) gene expression counts matrix cells, can evaluate relationships pairs genes peaks, linking genes putative regulatory elements. use simple strategy identify gene-peak links: Calculate correlation gene expression peak accessibility peaks within 500 KB gene, retain peaks showing statistically significant correlation gene. linkGenesAndPeaks() function performs analysis: output function sparse matrix peak names rows gene symbols columns, element indicating correlation peak gene j. value 0 corresponding gene peak significantly linked. example, can subset results marker gene S100A9, highly expressed cluster 6, 8, 9, 10 12: also provide function transform peaks-gene correlation matrix Interact Track supported UCSC Genome Browser visualizing calculated linkage genes correlated peaks. , tying : output function UCSC Interact Track file named ‘Interact_Track.bed’ containing linkage information specified genes correlated peaks stored given directory. user can upload file custom track using page https://genome.ucsc.edu/cgi-bin/hgCustom display UCSC Genome browser. example, three peaks correlated S100A9 expression shown UCSC genome browser. One peaks overlaps TSS S100A8, neighboring gene co-expressed S100A9, another peak overlaps TSS S100A9 . last peak, chr1:153358896-153359396, overlap gene body shows strong H3K27 acetylation across ENCODE cell lines, indicating likely intergenic regulatory element.  plot accessibility peak expression S100A9, can see two indeed correlated show strong enrichment clusters 1 3. Thus, intergenic peak likely serves cell-type-specific regulator S100A9.","code":"peak <- read10XATAC(\"/path/to/filtered_peak_barcode_matrix\", sampleNames = \"atac\") if (!file.exists(\"liger_BMMC_atac_D5T1_peak.rds\"))     download.file(\"https://figshare.com/ndownloader/files/40054864\",                   destfile = \"liger_BMMC_atac_D5T1_peak.rds\") D5T1.peak <- readRDS(\"liger_BMMC_atac_D5T1_peak.rds\")  rawPeak(bmmcLiger, \"atac\") <- D5T1.peak bmmcLiger <- normalizePeak(bmmcLiger) peak.wilcoxon <- runWilcoxon(bmmcLiger, useDatasets = \"atac\", usePeak = TRUE) peak.wilcoxon <- peak.wilcoxon %>% filter(padj < 0.05, logFC > 2) peaks.sel <- unique(peak.wilcoxon$feature) rawPeak(bmmcLiger, \"atac\") <- rawPeak(bmmcLiger, \"atac\")[peaks.sel,] bmmcLiger <- normalizePeak(bmmcLiger) bmmcLiger <- imputeKNN(bmmcLiger, reference = 'atac', queries = \"rna\") if (!file.exists(\"hg19_genes.bed\"))     download.file(\"https://figshare.com/ndownloader/files/40054870\",                   destfile = \"hg19_genes.bed\")  regnet <- linkGenesAndPeaks(bmmcLiger, useDataset = \"rna\", pathToCoords = \"hg19_genes.bed\", method = \"spearman\", alpha = 0.05) S100A9 <- regnet[, 'S100A9'] S100A9 <- S100A9[abs(S100A9) > 0] S100A9[order(abs(S100A9), decreasing = TRUE)] exportInteractTrack(regnet, useGenes = \"S100A9\", pathToCoords = \"hg19_genes.bed\") S100A9 <- plotGeneDimRed(bmmcLiger, \"S100A9\", splitBy = \"dataset\") peak1 <- plotPeakDimRed(bmmcLiger, \"chr1:153358896-153359396\") cowplot::plot_grid(peak1, S100A9$S100A9.rna, nrow = 2, align = \"v\", axis = \"lr\")"},{"path":"/articles/SNAREseq_walkthrough.html","id":"step-1-load-data","dir":"Articles","previous_headings":"","what":"Step 1: Load data","title":"UINMF integration of Dual-omics data","text":"","code":"library(rliger)  rna <- readRDS(\"SNAREseq_data/SNAREseq_RNA.RDS\") atac_shared <- readRDS(\"SNAREseq_data/SNAREseq_chromatin_accessibility_shared.RDS\") atac_unshared <- readRDS(\"SNAREseq_data/SNARE_seq_unshared_chromatin_features.RDS\")"},{"path":"/articles/SNAREseq_walkthrough.html","id":"step-2-preprocessing","dir":"Articles","previous_headings":"","what":"Step 2: Preprocessing","title":"UINMF integration of Dual-omics data","text":"Integrative non-negative matrix factorization unshared features (UINMF) performs factorization using shared feature matrix datasets includes unshared features dataset(s) information. tutorial, plan use variable feature selected scRNA dataset. Since prepared gene-centric matrix scATAC dataset, genes can accounted shared features. unshared features, normally select variable genes intersection gene sets datasets. tutorial, directly use peaks identified variable. Therefore, special processing needed compared UINMF tutorials.","code":""},{"path":"/articles/SNAREseq_walkthrough.html","id":"create-liger-object-for-shared-genes","dir":"Articles","previous_headings":"Step 2: Preprocessing","what":"2.1: Create liger object for shared genes","title":"UINMF integration of Dual-omics data","text":"","code":"lig <- createLiger(list(rna = rna, atac = atac_shared))"},{"path":"/articles/SNAREseq_walkthrough.html","id":"normalize-and-select-shared-variable-features","dir":"Articles","previous_headings":"Step 2: Preprocessing","what":"2.2: Normalize and select shared variable features","title":"UINMF integration of Dual-omics data","text":"","code":"lig <- normalize(lig) %>%     selectGenes(useDatasets = \"rna\", thresh = 0.1) %>%     scaleNotCenter()"},{"path":"/articles/SNAREseq_walkthrough.html","id":"step-3-selecting-the-unshared-features","dir":"Articles","previous_headings":"","what":"Step 3: Selecting the unshared features","title":"UINMF integration of Dual-omics data","text":"selecting unshared features UINMF integration, critical consider type data working . unshared features gene-centric, user follow feature selection process outlined ‘Integrating unshared features UINMF’ tutorial. However, dealing features gene-centric (case binned intergenic peak counts), must select variable features using appropriate method. , opt use Seurat’s FindVariableFeatures() function. First, normalize unshared features: select top 2,000 variable features Seurat VST method: scale, center unshared features Add unshared features properly selected, added genes cells matrix.","code":"unshareNormed <- normalize(atac_unshared) library(Seurat)  se <- CreateSeuratObject(unshareNormed) se <- FindVariableFeatures(se, selection.method = \"vst\", nfeatures = 2000) top2000 <- VariableFeatures(se) unshareScaled <- scaleNotCenter(unshareNormed[top2000,]) varUnsharedFeatures(lig, \"atac\") <- top2000 scaleUnsharedData(lig, \"atac\") <- unshareScaled"},{"path":"/articles/SNAREseq_walkthrough.html","id":"step-4-joint-matrix-factorization","dir":"Articles","previous_headings":"","what":"Step 4: Joint Matrix Factorization","title":"UINMF integration of Dual-omics data","text":"factorize datasets include unshared datasets, set useUnshared = TRUE.","code":"lig <- runUINMF(lig, k = 30, nIteration = 30)"},{"path":"/articles/SNAREseq_walkthrough.html","id":"step-5-quantile-normalization-and-joint-clustering","dir":"Articles","previous_headings":"","what":"Step 5: Quantile Normalization and Joint Clustering","title":"UINMF integration of Dual-omics data","text":"factorization, resulting Liger object can used downstream LIGER functions without adjustment. default reference dataset quantile normalization larger dataset, user select higher quality dataset reference dataset, even smaller dataset.","code":"lig <- quantileNorm(lig) lig <- runCluster(lig, resolution = 0.8, nNeighbors = 30)"},{"path":"/articles/SNAREseq_walkthrough.html","id":"step-6-visualizations-and-downstream-processing","dir":"Articles","previous_headings":"","what":"Step 6: Visualizations and Downstream processing","title":"UINMF integration of Dual-omics data","text":"Next, can visualize returned factorized object dataset check alignment datasets, well cluster determined factorization.","code":"lig <- runUMAP(lig, nNeighbors = 30) options(ligerDotSize = 0.5) plotDatasetDimRed(lig) plotClusterDimRed(lig, legendNCol = 2)"},{"path":"/articles/STARmap_dropviz_vig.html","id":"step-1-load-the-data","dir":"Articles","previous_headings":"","what":"Step 1: Load the data","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"datasets provided presented “dgCMatrix” class, common form sparse matrix R. can create liger object named list matrices. unshared features subsetted , submitted separately. Rather, included matrix submitted dataset. helps ensure proper normalization. Different UINMF tutorials, set modality dataset argument modal, way, slot spatial coordinates preserved STARmap dataset.","code":"library(rliger)  dropviz <- readRDS(\"starmap_data/Dropviz_starmap_vig.RDS\") starmap <- readRDS(\"starmap_data/STARmap_vig.RDS\")  lig <- createLiger(list(starmap = starmap, dropviz = dropviz),                    modal = c(\"spatial\", \"rna\"))"},{"path":[]},{"path":"/articles/STARmap_dropviz_vig.html","id":"normalization","dir":"Articles","previous_headings":"Step 2: Preprocessing","what":"2.1 Normalization","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"Liger simply normalizes matrices library size, without multiplying scale factor applying “log1p” transformation.","code":"lig <- normalize(lig)"},{"path":"/articles/STARmap_dropviz_vig.html","id":"select-variable-genes","dir":"Articles","previous_headings":"Step 2: Preprocessing","what":"2.2 Select variable genes","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"Given STARmap dataset 28 genes available also presented Dropviz dataset, directly set shared variable genes. Please use varFeatures<-() method accessing shared variable genes. Dropviz dataset, select variable genes unshared part . enable selection unshared genes, users need specify name(s) dataset(s) unshared genes chosen useUnsharedDatasets.","code":"lig <- selectGenes(lig, thresh = 0.3, useUnsharedDatasets = \"dropviz\", unsharedThresh = 0.3) ## ℹ Selecting variable features for dataset \"starmap\" ## ✔ ... 0 features selected out of 28 shared features. ## ℹ Selecting variable features for dataset \"dropviz\" ## ✔ ... 19 features selected out of 28 shared features. ## ✔ ... 2775 features selected out of 28338 unshared features. ## ✔ Finally 19 shared variable features are selected. varFeatures(lig) <- rownames(dataset(lig, \"starmap\"))"},{"path":"/articles/STARmap_dropviz_vig.html","id":"scale-not-center","dir":"Articles","previous_headings":"Step 2: Preprocessing","what":"2.3 Scale not center","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"scale dataset. Three new matrices created hook, two containing 28 shared variable genes datasets, one unshared variable genes Dropviz data. Note LIGER center data scaling iNMF/UINMF methods require non-negative input.","code":"lig <- scaleNotCenter(lig)"},{"path":"/articles/STARmap_dropviz_vig.html","id":"step-3-joint-matrix-factorization","dir":"Articles","previous_headings":"","what":"Step 3: Joint Matrix Factorization","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"Unshared Integrative Non-negative Matrix Factorization (UINMF) can applied runIntegration(..., method = \"UINMF\"). standalone function runUINMF() also provided detailed documentation initialization setup. step produces factor gene loading matrices shared genes: \\(W\\) shared information across datasets, \\(V\\) dataset specific information. Specific UINMF method, additional factor gene loading matrix unshared features, \\(U\\) also produced. \\(H\\) matrices, cell factor loading matrices produced dataset can interpreted low-rank representation cells. tutorial, set dataset specific lambda (regularization parameter) values penalize dataset specific effect differently. Another noteworthy advantage UINMF able use larger number factors shared features. captilize changing default value k 40.","code":"lig <- runUINMF(lig, k = 40, lambda = c(10, 1))"},{"path":[]},{"path":"/articles/STARmap_dropviz_vig.html","id":"quantile-normalization","dir":"Articles","previous_headings":"Step 4: Quantile Normalization and Joint Clustering","what":"4.1 Quantile normalization","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"default reference dataset quantile normalization larger dataset, users select higher quality dataset reference dataset, even smaller dataset. case, Dropviz dataset considered higher quality STARmap dataset, set Dropviz dataset reference dataset. step, low-rank cell factor loading matrices, \\(H\\), aligned ready cluster definition.","code":"lig <- quantileNorm(lig, reference = \"dropviz\")"},{"path":"/articles/STARmap_dropviz_vig.html","id":"leiden-clustering","dir":"Articles","previous_headings":"Step 4: Quantile Normalization and Joint Clustering","what":"4.2 Leiden clustering","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"aligned cell factor loading information, next apply Leiden community detection algorithm identify cell clusters.","code":"lig <- runCluster(lig)"},{"path":[]},{"path":"/articles/STARmap_dropviz_vig.html","id":"dimensionality-reduction","dir":"Articles","previous_headings":"Step 5: Visualizations and Downstream processing","what":"5.1 Dimensionality reduction","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"create UMAP quantile normalized cell factor loading.","code":"lig <- runUMAP(lig)"},{"path":"/articles/STARmap_dropviz_vig.html","id":"plot-umap","dir":"Articles","previous_headings":"Step 5: Visualizations and Downstream processing","what":"5.2 Plot UMAP","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"Next, can visualize factorized object dataset check integration datasets, also cluster labeling global population.   can also use Dropviz labels help us annotate clusters. Link downloading page labeling data provided top page.  cellMeta()<- method feature partial insertion implemented great adding dataset specific metadata new variable. unsure order given variable cells object, argument cellIdx can used precise locating. Users might use different strategies creating index depending different situation.","code":"plotDatasetDimRed(lig) plotClusterDimRed(lig, legendNCol = 2) mouse_annies <- readRDS(\"starmap_data/Dropviz_general_annotations.RDS\") dropviz_id <- paste0(\"dropviz_\", names(mouse_annies)) cellMeta(lig, \"dropviz_ann\", cellIdx = dropviz_id) <- factor(mouse_annies) plotClusterDimRed(lig, \"dropviz_ann\", legendNCol = 1)"},{"path":"/articles/STARmap_dropviz_vig.html","id":"step-6-visualization-with-spatial-information","dir":"Articles","previous_headings":"","what":"Step 6: Visualization with spatial information","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"demonstrate use annotation labels derived analysis within context 3D space. provide annotation labels sake simplicity. link download page provided top page. labels generated using high quality Dropviz annotations re-annotate STARmap cells completing analysis. provided exact annotations colors used publication interested user may captilize 3D dimensional sample space.","code":"starmap_annies <- readRDS(\"starmap_data/STARmap_3D_Annotations.RDS\") dplyr::glimpse(starmap_annies) ## Rows: 29,163 ## Columns: 9 ## $ Cell_Barcode       <chr> \"starmap_11\", \"starmap_30\", \"starmap_51\", \"starmap_… ## $ Cluster            <fct> 15, 15, 15, 13, 15, 15, 13, 13, 15, 15, 1, 1, 15, 1… ## $ Cluster_Annotation <chr> \"Layer 5A\", \"Layer 5A\", \"Layer 5A\", \"Layer 5A\", \"La… ## $ Coord1             <int> 12, 46, 81, 87, 92, 105, 117, 123, 128, 133, 170, 1… ## $ Coord2             <int> 937, 152, 76, 967, 948, 951, 284, 1004, 217, 319, 1… ## $ Coord3             <int> 8, 12, 7, 8, 8, 6, 7, 6, 6, 9, 6, 6, 7, 9, 6, 6, 6,… ## $ Cell_Type_Color    <chr> \"plum\", \"plum\", \"plum\", \"plum\", \"plum\", \"plum\", \"pl… ## $ General_Class      <chr> \"Neuron\", \"Neuron\", \"Neuron\", \"Neuron\", \"Neuron\", \"… ## $ Sub_Color          <chr> \"#0066FF\", \"#0066FF\", \"#0066FF\", \"#0066FF\", \"#0066F…"},{"path":"/articles/STARmap_dropviz_vig.html","id":"manage-ligerspatialdataset-class-optional","dir":"Articles","previous_headings":"Step 6: Visualization with spatial information","what":"6.1 Manage ligerSpatialDataset class (Optional)","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"Recall set “modal” STARmap dataset “spatial” created liger object, can insert coordinate information object. LIGER yet analysis method incorporate spatial coordinate information. Given spatial transcriptomics technologies support 2D spatial information, LIGER 2D plotting (See plotSpatial2D()) method implemented spatial coordinate point.","code":"coords <- as.matrix(starmap_annies[, c(\"Coord1\", \"Coord2\", \"Coord3\")]) rownames(coords) <- starmap_annies$Cell_Barcode coordinate(lig, \"starmap\") <- coords"},{"path":"/articles/STARmap_dropviz_vig.html","id":"d-visualization","dir":"Articles","previous_headings":"Step 6: Visualization with spatial information","what":"6.2 3D visualization","title":"Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF","text":"STARmap technology work tutorial special 3D information. LIGER provide function visualization 3D coordinates, provide simple guide using package rgl. code chunk shows create 3D view cells. can see , cells different types can located different depth (z-axis) can interfere observation . next show visualize neuronal cells.","code":"library(rgl)  # Set the perspective parameters rgl.viewpoint(theta = 25, phi = 5, zoom = 0.7) # Generate scatter plot in 3D space plot3d(x = starmap_annies$Coord1,         y = starmap_annies$Coord2,         z = starmap_annies$Coord3,         xlab = \"\", ylab = \"\", zlab = \"\",        col = starmap_annies$Cell_Type_Color,         size = 2, axes= FALSE, labels = FALSE) aspect3d(1.7, 1.4, 0.1) first = c(0) second = c(0) # Set background color to black bg3d(\"black\", labels = FALSE) axes3d(edges = \"bbox\",col = 'white', labels = FALSE, tick = FALSE) # Subset annotation data to only Neurons neuronal_cells <- starmap_annies[starmap_annies$General_Class == \"Neuron\",] # Create 3D scatter plot with the subset plot3d(x = neuronal_cells$Coord1,         y = neuronal_cells$Coord2,         z = neuronal_cells$Coord3,         xlab = \"\", ylab = \"\", zlab = \"\",         col = neuronal_cells$Sub_Color,         size = 3, axes = FALSE, labels = FALSE) aspect3d(1.7, 1.4, 0.1) first = c(0) second = c(0) bg3d(\"black\", labels = FALSE) axes3d(edges = \"bbox\", col = 'white', labels = FALSE, tick = FALSE)"},{"path":[]},{"path":"/articles/UINMF_vignette.html","id":"loading-the-data","dir":"Articles","previous_headings":"Step 1: Preprocessing and Normalization","what":"1.1 Loading the data","title":"Unshared Features UINMF","text":"prepared RDS files can directly loaded R environment. presented dense matrix (R default) form. recommend converting sparse matrix form (“dgCMatrix” class supported “Matrix” package) order reduce memory usage speed downstream analysis. Next, create Liger object, submitting datasets list format. unshared features subsetted , submitted separately. Rather, included matrix submitted dataset. example,scRNA-seq data submitted entirety, unshared features submitted separately. helps ensure proper normalization.","code":"library(rliger) library(Matrix)  options(ligerDotSize = 0.5)  osmFISH <- readRDS(\"uinmf_vignette_data/OSMFISH.vin.RDS\") osmFISH <- as(osmFISH, \"CsparseMatrix\") rna <- readRDS(\"uinmf_vignette_data/DROPVIZ.vin.RDS\") lig <- createLiger(list(osmFISH = osmFISH, rna = rna))"},{"path":"/articles/UINMF_vignette.html","id":"preprocess-the-datasets","dir":"Articles","previous_headings":"Step 1: Preprocessing and Normalization","what":"1.2 Preprocess the datasets","title":"Unshared Features UINMF","text":"normalization applied datasets entirety. normalized data dataset can accessed normData(). Next, select variable genes used integration. include unshared features analysis, set useUnsharedDatasets vector names datasets unshared features included. instance, case, wish include unshared features RNA dataset, second dataset, analysis. provide individual tuning threshold unshared features. single value submitted, threshold applied datasets’ unshared features. multiple datasets include unshared features, user can specify individual thresholds dataset submitting list thresholds length number datasets unshared datasets. selected shared features, 33 osmFISH genes case, can accessed varFeatures(lig). unshared variable features specific dataset, namingly \"rna\" case, can accessed varUnsharedFeatures(lig, \"rna\"). scale selected gene expression matrix integration. datasets centered scaling non-negative constraint factorization addressed. scaled matrix shared features can accessed scaleData(). scaled matrix unshared features RNA dataset separate matrix can accessed scaleUnsharedData(lig, \"rna\").","code":"lig <- normalize(lig) lig <- selectGenes(lig, useUnsharedDatasets = \"rna\", unsharedThresh = 0.4) ## ℹ Selecting variable features for dataset \"osmFISH\" ## ✔ ... 33 features selected out of 33 shared features. ## ℹ Selecting variable features for dataset \"rna\" ## ✔ ... 29 features selected out of 33 shared features. ## ✔ ... 1327 features selected out of 24520 unshared features. ## ✔ Finally 33 shared variable features are selected. lig <- scaleNotCenter(lig)"},{"path":"/articles/UINMF_vignette.html","id":"step-2-joint-matrix-factorization","dir":"Articles","previous_headings":"","what":"Step 2: Joint Matrix Factorization","title":"Unshared Features UINMF","text":"provide function runIntegration() general wrapper integration method developed. Users can runIntegration(..., method = \"UINMF\") perform analysis. Alternatively, stand-alone function runUINMF() also provided specific parameter setitng guide.","code":"lig <- runIntegration(lig, k = 30, method = \"UINMF\")"},{"path":[]},{"path":"/articles/UINMF_vignette.html","id":"quantile-normalize-the-factor-loading","dir":"Articles","previous_headings":"Step 3: Quantile Normalization and Joint Clustering","what":"3.1 Quantile normalize the factor loading","title":"Unshared Features UINMF","text":"factorization, resulting liger object can used downstream LIGER functions without adjustment. default reference dataset quantile normalization larger dataset, user select higher quality dataset reference dataset, even smaller dataset.","code":"lig <- quantileNorm(lig, reference = \"rna\")"},{"path":"/articles/UINMF_vignette.html","id":"leiden-clustering","dir":"Articles","previous_headings":"Step 3: Quantile Normalization and Joint Clustering","what":"3.2 Leiden clustering","title":"Unshared Features UINMF","text":"quantile normalized cell factor loading, can apply Leiden graph-based community detection method .","code":"lig <- runCluster(lig)"},{"path":[]},{"path":"/articles/UINMF_vignette.html","id":"create-dimension-reduction-embedding","dir":"Articles","previous_headings":"Step 4: Visualizations and Downstream processing","what":"4.1 Create dimension reduction embedding","title":"Unshared Features UINMF","text":"","code":"lig <- runUMAP(lig)"},{"path":"/articles/UINMF_vignette.html","id":"visualize","dir":"Articles","previous_headings":"Step 4: Visualizations and Downstream processing","what":"4.2 Visualize","title":"Unshared Features UINMF","text":"Next, can visualize returned factorized object dataset check alignment datasets, well cluster determined factorization.   can also examine features gene expression.","code":"plotDatasetDimRed(lig) plotClusterDimRed(lig, legendNCol = 2) pdgfra <- plotGeneDimRed(lig, \"Pdgfra\", splitBy = \"dataset\", title = names(lig)) bmp4 <- plotGeneDimRed(lig, \"Bmp4\", splitBy = \"dataset\", title = names(lig)) cowplot::plot_grid(     pdgfra$Pdgfra.rna, pdgfra$Pdgfra.osmFISH,     bmp4$Bmp4.rna, bmp4$Bmp4.osmFISH )"},{"path":[]},{"path":"/articles/cross_species_vig.html","id":"load-data-and-create-liger-object","dir":"Articles","previous_headings":"Step 1: Load the data","what":"1. Load data and create liger object","title":"Cross-Species Analysis with UINMF","text":"tutorial, use two datasets, can downloaded https://www.dropbox.com/sh/y9kjoum8u469nj1/AADik2b2-Qo3os2QSWXdIAbna?dl=0 . scRNA mouse dataset (Drop_mouse.RDS) 28,366 genes 71,639 cells. scRNA lizard dataset (RNA_lizard.RDS) 15,345 genes 4,202 cells. input raw count matrices presented dgCMatrix class objects, common form sparse matrix. Users can create liger object two datasets. named list required submitting datasets object creator.","code":"library(rliger) options(ligerDotSize = 0.5)  mouse <- readRDS(\"cross_species_vignette_data/Drop_mouse.RDS\") lizard <- readRDS(\"cross_species_vignette_data/RNA_lizard.RDS\")  lig <- createLiger(list(mouse = mouse, lizard = lizard))"},{"path":[]},{"path":"/articles/cross_species_vig.html","id":"normalization","dir":"Articles","previous_headings":"Step 2: Preprocessing and normalization","what":"2. Normalization","title":"Cross-Species Analysis with UINMF","text":"Liger simply normalizes matrices library size, without multiplying scale factor applying “log1p” transformation.","code":"lig <- normalize(lig)"},{"path":"/articles/cross_species_vig.html","id":"select-variable-genes","dir":"Articles","previous_headings":"Step 2: Preprocessing and normalization","what":"3. Select variable genes","title":"Cross-Species Analysis with UINMF","text":"cross-species analysis, select shared, homologous genes two species, well unshared, non-homologous genes lizard dataset. default setting selectGenes() function selects homologous genes shared datasets. enable selection unshared genes, users need specify name(s) dataset(s) unshared genes chosen useUnsharedDatasets.","code":"lig <- selectGenes(lig, thresh = 0.3, useUnsharedDatasets = \"lizard\", unsharedThresh = 0.3) ## ℹ Selecting variable features for dataset \"mouse\" ## ✔ ... 1683 features selected out of 12334 shared features. ## ℹ Selecting variable features for dataset \"lizard\" ## ✔ ... 612 features selected out of 12334 shared features. ## ✔ ... 166 features selected out of 3008 unshared features. ## ✔ Finally 1976 shared variable features are selected."},{"path":"/articles/cross_species_vig.html","id":"scale-not-center","dir":"Articles","previous_headings":"Step 2: Preprocessing and normalization","what":"4. Scale not center","title":"Cross-Species Analysis with UINMF","text":"scale dataset. Three new matrices created hook, two containing shared variable features datasets, one unshared variable features lizard data. Note Liger center scaled data iNMF/UINMF methods require non-negative input.","code":"lig <- scaleNotCenter(lig)"},{"path":[]},{"path":"/articles/cross_species_vig.html","id":"mosaic-integrative-nmf","dir":"Articles","previous_headings":"Step 3: Joint Matrix Factorization","what":"5. Mosaic integrative NMF","title":"Cross-Species Analysis with UINMF","text":"Unshared Integrative Non-negative Matrix Factorization (UINMF) can applied runIntegration(..., method = \"UINMF\"). standalone function runUINMF() also provided detailed documentation initialization setup. step produces factor gene loading matrices shared genes: \\(W\\) shared information across datasets, \\(V\\) dataset specific information. Specific UINMF method, additional factor gene loading matrix unshared genes, \\(U\\) also produced. \\(H\\) matrices, cell factor loading matrices produced dataset can interpreted load rank representation cells.","code":"lig <- runIntegration(lig, k = 30, method = \"UINMF\")"},{"path":[]},{"path":"/articles/cross_species_vig.html","id":"quantile-normalization","dir":"Articles","previous_headings":"Step 4: Quantile Normalization and Joint Clustering","what":"6. Quantile normalization","title":"Cross-Species Analysis with UINMF","text":"default reference dataset quantile normalization largest dataset, user select higher quality dataset reference dataset, even smaller dataset. case, mouse dataset considered higher quality lizard dataset, set mouse dataset reference dataset. step, low-rank cell factor loading matrices, \\(H\\), aligned ready cluster definition.","code":"lig <- quantileNorm(lig, reference = \"mouse\")"},{"path":"/articles/cross_species_vig.html","id":"leiden-clustering","dir":"Articles","previous_headings":"Step 4: Quantile Normalization and Joint Clustering","what":"7. Leiden clustering","title":"Cross-Species Analysis with UINMF","text":"aligned cell factor loading information, next apply Leiden community detection algorithm identify cell clusters.","code":"lig <- runCluster(lig, nNeighbors = 30, resolution = 0.6)"},{"path":[]},{"path":"/articles/cross_species_vig.html","id":"dimensionality-reduction","dir":"Articles","previous_headings":"Step 5: Visualization","what":"8. Dimensionality reduction","title":"Cross-Species Analysis with UINMF","text":"create UMAP quantile normalized cell factor loading.","code":"lig <- runUMAP(lig, nNeighbors = 30, minDist = 0.3)"},{"path":"/articles/cross_species_vig.html","id":"plot-umap","dir":"Articles","previous_headings":"Step 5: Visualization","what":"9. Plot UMAP","title":"Cross-Species Analysis with UINMF","text":"Next, can visualize returned factorized object dataset check integration datasets, also cluster labeling global population.   can also use datasets’ original annotations check correspondence cell types two species. annotations can downloaded https://www.dropbox.com/sh/y9kjoum8u469nj1/AADik2b2-Qo3os2QSWXdIAbna?dl=0 cellMeta()<- method feature partial insertion implemented great adding dataset specific metadata new variable. unsure order given variable cells object, argument cellIdx can used precise locating. Users might use different strategies creating index depending different situation.   also implemented Sankey diagram function shows mapping network individual cluster assignments joint clustering. individual cluster assignment added , can simply use variables show diagram plotSankey().","code":"plotDatasetDimRed(lig) plotClusterDimRed(lig, legendNCol = 2) mouse_annies = readRDS(\"cross_species_vignette_data/Dropviz_general_annotations.RDS\") lizard_annies = readRDS(\"cross_species_vignette_data/lizard_labels.RDS\") mouse_id <- paste0(\"mouse_\", names(mouse_annies)) cellMeta(lig, \"mouse_ann\", cellIdx = mouse_id) <- factor(mouse_annies)  lizard_id <- paste0(\"lizard_\", names(lizard_annies)) cellMeta(lig, \"lizard_ann\", cellIdx = lizard_id) <- factor(lizard_annies)  plotClusterDimRed(lig, useCluster = \"mouse_ann\", legendNCol = 1) plotClusterDimRed(lig, useCluster = \"lizard_ann\", legendNCol = 1) plotSankey(lig, cluster1 = \"mouse_ann\", cluster2 = \"lizard_ann\",             titles = c(\"Mouse\", \"Integrated\", \"Lizard\"),             mar = c(1, 8, 2, 3))"},{"path":"/articles/installation.html","id":"liger-is-available-on-cran","dir":"Articles","previous_headings":"","what":"LIGER is available on CRAN","title":"Install LIGER with R","text":"install latest stable release, please run following command R console:","code":"install.packages(\"rliger\")"},{"path":"/articles/installation.html","id":"building-from-source","dir":"Articles","previous_headings":"","what":"Building from source","title":"Install LIGER with R","text":"developmental versions well source version previous versions accessible GitHub. currently contributing repository welch-lab/liger branch newObj latest developmental version. install latest version GitHub, please run following command R console: encounter issues building source, please see sections details dependencies. Please note latest version (>=1.99.0) massively updated compared prior versions, functions directly compatible old version objects users might possess. Please use readLiger() load old RDS files convertOldLiger() convert loaded object --date structure. might need careful overwriting existing analysis don’t provide methods convert new structure backwards.","code":"if (!requireNamespace(\"devtools\")) install.packages(\"devtools\") devtools::install_github(\"welch-lab/liger@newObj\")"},{"path":"/articles/installation.html","id":"compiler-setup","dir":"Articles","previous_headings":"Building from source","what":"Compiler setup","title":"Install LIGER with R","text":"Windows users need install Rtools can downloaded CRAN. downloading , open file follow prompt install. MacOS users need Clang gfortran, can also found CRAN Mac Tools.","code":""},{"path":"/articles/installation.html","id":"installing-hdf5-library","dir":"Articles","previous_headings":"Building from source","what":"Installing HDF5 Library","title":"Install LIGER with R","text":"HDF5 library required interacting H5 files. can installed via following commands.","code":""},{"path":"/articles/installation.html","id":"installing-rcppplanc","dir":"Articles","previous_headings":"Building from source","what":"Installing RcppPlanc","title":"Install LIGER with R","text":"RcppPlanc extension R package built basing Planc. implemented highly optimized iNMF algorithm variants new version upgrade. currently available via GitHub. Please refer RcppPlanc GitHub repository detail support.","code":"devtools::install_github(\"welch-lab/RcppPlanc\")"},{"path":"/articles/installation.html","id":"installing-fit-sne","dir":"Articles","previous_headings":"Building from source","what":"Installing FIt-SNE","title":"Install LIGER with R","text":"dimensionality reduction, options UMAP t-SNE. UMAP, depend uwot readily scalable large datasets. t-SNE, default use Rtsne, scalable large datasets. allow using another implementation t-SNE, namingly FIt-SNE, efficient computation. FIt-SNE distributed package CRAN, thus users need install following steps .","code":""},{"path":"/articles/installation.html","id":"create-a-directory-fo-organizing-the-source-code","dir":"Articles","previous_headings":"Building from source > Installing FIt-SNE","what":"1. Create a directory fo organizing the source code","title":"Install LIGER with R","text":"","code":"cd path/you/need mkdir FItSNE_local"},{"path":"/articles/installation.html","id":"install-fftw-library-","dir":"Articles","previous_headings":"Building from source > Installing FIt-SNE","what":"1. Install FFTW library.","title":"Install LIGER with R","text":"Download FFTW . UNIX like users, run following command terminal. following commands terminal show locally install library version 3.3.10 tutorial written . can check official website update available. can simply replace version number URL file name update installation. FFTW library installed directory source code located. can change part pwd path (quotes needed) even remove --prefix token globally install library root access. folder lib files named libfftw3* must presented current location.","code":"cd FItSNE_local curl ftp://ftp.fftw.org/pub/fftw/fftw-3.3.10.tar.gz -o fftw-3.3.10.tar.gz tar -xvzf  fftw-3.3.10.tar.gz cd fftw-3.3.10 ./configure --prefix=`pwd` make make install prefix=`pwd`"},{"path":"/articles/installation.html","id":"install-fit-sne","dir":"Articles","previous_headings":"Building from source > Installing FIt-SNE","what":"2. Install FIt-SNE","title":"Install LIGER with R","text":"next download FIt-SNE GitHub compile part need R wrapper functionality. folder bin file named fast_tsne must presented current location. command pwd shows location binary need printed path next step.","code":"cd ../ # back to FItSNE_local git clone https://github.com/KlugerLab/FIt-SNE.git cd FIt-SNE g++ -std=c++11 -O3  src/sptree.cpp src/tsne.cpp src/nbodyfft.cpp -o bin/fast_tsne -pthread -L../fftw-3.3.10/lib -lfftw3 -lm pwd"},{"path":"/articles/installation.html","id":"run-t-sne-with-flt-sne","dir":"Articles","previous_headings":"Building from source > Installing FIt-SNE","what":"3. Run t-SNE with Flt-SNE","title":"Install LIGER with R","text":"Now, ’ve binary compiled, command pwd shows location binary. back R LIGER analysis, following command can used invoke binary. Just simply pass string containing pwd shows argument fitsnePath runTSNE() function switch method = \"fftRtsne\".","code":"ligerObj <- runTSNE(ligerObj, method = \"fftRtsne\", fitsnePath = \"path/you/need/FItSNE_local/FIt-SNE\")"},{"path":"/articles/liger-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Data Integration with LIGER","text":"LIGER initially introduced Welch et al. 2019 method integrating single-cell RNA-seq data across multiple technologies, species, conditions. method relies integrative nonnegative matrix factorization (iNMF) identify shared dataset-specific factors. LIGER can used compare contrast experimental datasets variety contexts, instance: Across experimental batches Across individuals Across sex Across tissues Across species (e.g., mouse human) Across modalities (e.g., scRNAseq spatial transcriptomics data, scMethylation, scATAC-seq) multiple datasets integrated, package provides functionality data exploration, analysis, visualization. Users can: Identify clusters Find significant shared (dataset-specific) gene markers Compare clusters previously identified cell types Visualize clusters gene expression using t-SNE UMAP","code":""},{"path":"/articles/liger-vignette.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Data Integration with LIGER","text":"now made documentation website rliger 2.0.0. Please check detailed introduction. made number vignettes typical types analysis can performed LIGER. Integrating Multiple Single-Cell RNA-seq Datasets Jointly Defining Cell Types scRNA-seq scATAC-seq Iterative Single-Cell Multi-Omic Integration Using Online iNMF Integrating unshared features UINMF Integrating spatial transcriptomic transcriptomic datasets using UINMF scATAC scRNA Integration using unshared features (UINMF) Cross-species Analysis UINMF Jointly Defining Cell Types Single-Cell RNA-seq DNA Methylation Meanwhile, since version 2.0.0, LIGER massively updated usability interoperability packages. links introduction new features. Introduction new liger object related classes Running Liger directly Seurat objects","code":""},{"path":"/articles/liger_object.html","id":"structure","dir":"Articles","previous_headings":"","what":"Structure","title":"Interact with A Liger Object","text":"Starting rliger 2.0.0, introduced newly designed structure main data container object class. figure brings overall idea design.  left hand side figure, briefly illustrate old structure like. slots data processing stage, slot named list object containing matrices. new version, right side, first introduce another new class, ligerDataset, serve container matrices belonging specific dataset. way, easy safe control data matching thanks number object oriented accessor methods validity checks. liger class, main differences: Feature (gene expression) matrices now wrapped ligerDataset objects, put datasets(obj) slot. Click access raw counts, normalized counts, scaled data. Cell metadata including dataset belonging, study design conditions, quality control (QC) metrics now stored slot cellMeta(obj). Meanwhile, moved cluster labeling result also slot, order multiple cluster variables existing time. Additionally, introducing S4Vectors::DataFrame class metadata flexibility tidy display. Click access cell metadata. Dimensionality reductions now expanded list low-dimensional representation (e.g. UMAP, t-SNE) slot dimReds(obj). Click access dimensionality reductions. Variable features identified now stored varFeatures(obj), structural change. new slot @uns added storing miscellaneous unstructured information, including default setting cluster labeling dimension reduction, faster visualization calls. also added feature record commands applied liger object allow retrieving records commands(obj). See liger command recording retrieving. demonstrate examples example dataset “pbmc”, minimal subset study conducted Hyun Min Kang et. al., Nature Biotechnology, 2018. data ready use (new) liger object raw counts data. quickly process can show retrieve kinds data sections .","code":"library(rliger) data(\"pbmc\") pbmc <- pbmc %>%     normalize() %>%     selectGenes() %>%     scaleNotCenter() %>%     runIntegration() %>%     quantileNorm() %>%     runCluster() %>%     runUMAP()"},{"path":"/articles/liger_object.html","id":"access-a-dataset","dir":"Articles","previous_headings":"","what":"Access a dataset","title":"Interact with A Liger Object","text":"introduced , dataset-specific information contained ligerDataset object. get names datasets get number datasets list number cells dataset access ligerDataset object specific dataset rliger functions argument useDatasets exposed, users can always use exact character name(s) numeric index specify datasets involved analysis. Moreoever, logical vector index also allowed ease usage cases. example , runMarkerDEG() funcion parametered detecting dataset specific markers within cluster, within female samples. example, cells condition “female-1 cluster 1” tested cells belonging condition “cluster 1 female datasets”. Can use access multiple datasets, returned list","code":"names(pbmc) ## [1] \"ctrl\" \"stim\" length(pbmc) ## [1] 2 lengths(pbmc) ## ctrl stim  ##  300  300 ctrlLD <- dataset(pbmc, dataset = \"ctrl\") # Alternatively, using numeric index ctrlLD <- dataset(pbmc, 1) # Not run, just for example, assuming we've got the clustering for such an object names(ligerObj) ## [1] female-1  female-2  male-3  male-4  female-5 ...... femaleIdx <- startsWith(names(ligerObj), \"fe\") runMarkerDEG(ligerObj, conditionBy = \"dataset\", splitBy = \"leiden_cluster\",               useDatasets = femaleIdx) ldList <- datasets(pbmc)"},{"path":"/articles/liger_object.html","id":"access-feature-matrices","dir":"Articles","previous_headings":"","what":"Access feature matrices","title":"Interact with A Liger Object","text":"three main generics accessing feature matrices, namingly rawData(), normData() scaleData(). scaled unshared features, used UINMF, also scaleUnsharedData(). Additionally, provide rawPeak() normPeak() accessing peak counts ATACseq dataset. logistics accessor feature matrices , present case raw counts. get list raw counts datasets: get raw counts specific dataset: replace raw counts new matrix object: new version, strict validity checks put upon modification object content. Replacement unmatching feature names barcodes rejected. case need replace dataset different set barcodes features, suggest recreating new ligerDataset object new raw counts (feature matrix), replace whole dataset .","code":"rawList <- rawData(pbmc) class(rawList) length(rawList) # Alternatively rawList <- getMatrix(pbmc, \"rawData\", returnList = TRUE) ## [1] \"list\" ## [1] 2 stimRaw <- rawData(pbmc, \"stim\") class(stimRaw) dim(stimRaw) # Alternatively, get the `ligerDataset` object of the dataset first # and then fetch from there stim <- dataset(pbmc, \"stim\") stimRaw <- rawData(stim) # Alternatively stimRaw <- getMatrix(pbmc, \"rawData\", dataset = \"stim\") ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" ## [1] 262 300 ctrlRaw <- rawData(pbmc, \"ctrl\") # Assume we do some operation on it here rawData(pbmc, \"ctrl\") <- ctrlRaw ctrlRaw <- rawData(pbmc, \"ctrl\") ctrlRawSubset <- ctrlRaw[1:200, 1:200] ## Not Run, will raise error # rawData(pbmc, \"ctrl\") <- ctrlRawSubset ctrlNew <- createLigerDataset(rawData = ctrlRawSubset) dataset(pbmc, \"ctrl\") <- ctrlNew dim(pbmc) ## [1] NA 500"},{"path":"/articles/liger_object.html","id":"access-cell-metadata","dir":"Articles","previous_headings":"","what":"Access cell metadata","title":"Interact with A Liger Object","text":"previously descibed top page, cell metadata including dataset origin, study metadata, QC metrics cluster labeling stored cellMeta(obj). look full metadata table: retrieve one variables: retrieve multiple variables: get variable subset cells (e.g. specific dataset), use argument useDatasets, alternatively cellIdx subscribes cells explicitly: Add replace variable. new variable added matching size (length() nrow()) number cells (ncol(pbmc)): new variable subset cells (e.g. original clustering derived individual dataset).","code":"cellMeta(pbmc) ## DataFrame with 600 rows and 9 columns ##                        dataset               barcode      nUMI     nGene ##                       <factor>           <character> <numeric> <integer> ## ctrl_AAACATACCTCGCT.1     ctrl ctrl_AAACATACCTCGCT.1      2151       102 ## ctrl_AAACGGCTCTTCGC.1     ctrl ctrl_AAACGGCTCTTCGC.1      1916       103 ## ctrl_AACACTCTAAGTAG.1     ctrl ctrl_AACACTCTAAGTAG.1      1869        95 ## ctrl_AACCGCCTCAGGAG.1     ctrl ctrl_AACCGCCTCAGGAG.1       733        84 ## ctrl_AACGTTCTTCCGTC.1     ctrl ctrl_AACGTTCTTCCGTC.1       573        76 ## ...                        ...                   ...       ...       ... ## stim_TTCATGACTTATCC.1     stim stim_TTCATGACTTATCC.1      1091       101 ## stim_TTCATGACTTCAGG.1     stim stim_TTCATGACTTCAGG.1       431        86 ## stim_TTCGGAGATTTCAC.1     stim stim_TTCGGAGATTTCAC.1      1344       102 ## stim_TTGACACTTCCTGC.1     stim stim_TTGACACTTCCTGC.1      1423       105 ## stim_TTTGCATGAACGAA.1     stim stim_TTTGCATGAACGAA.1      2818       120 ##                            mito      ribo      hemo quantileNorm_cluster ##                       <numeric> <numeric> <numeric>             <factor> ## ctrl_AAACATACCTCGCT.1         0  10.83217         0                   12 ## ctrl_AAACGGCTCTTCGC.1         0  20.25052         0                   5  ## ctrl_AACACTCTAAGTAG.1         0   5.08293         0                   3  ## ctrl_AACCGCCTCAGGAG.1         0  42.70123         0                   2  ## ctrl_AACGTTCTTCCGTC.1         0  38.04538         0                   19 ## ...                         ...       ...       ...                  ... ## stim_TTCATGACTTATCC.1         0   8.61595         0                   11 ## stim_TTCATGACTTCAGG.1         0  41.29930         0                   14 ## stim_TTCGGAGATTTCAC.1         0   8.85417         0                   6  ## stim_TTGACACTTCCTGC.1         0  11.94659         0                   6  ## stim_TTTGCATGAACGAA.1         0   9.43932         0                   5  ##                       leiden_cluster ##                             <factor> ## ctrl_AAACATACCTCGCT.1              0 ## ctrl_AAACGGCTCTTCGC.1              0 ## ctrl_AACACTCTAAGTAG.1              0 ## ctrl_AACCGCCTCAGGAG.1              3 ## ctrl_AACGTTCTTCCGTC.1              1 ## ...                              ... ## stim_TTCATGACTTATCC.1              0 ## stim_TTCATGACTTCAGG.1              1 ## stim_TTCGGAGATTTCAC.1              7 ## stim_TTGACACTTCCTGC.1              7 ## stim_TTTGCATGAACGAA.1              6 nUMI <- cellMeta(pbmc, \"nUMI\") class(nUMI) length(nUMI) # Alternatively nUMI <- pbmc$nUMI nUMI <- pbmc[[\"nUMI\"]] ## [1] \"numeric\" ## [1] 600 cellMeta(pbmc, c(\"nUMI\", \"nGene\")) ## DataFrame with 600 rows and 2 columns ##                            nUMI     nGene ##                       <numeric> <integer> ## ctrl_AAACATACCTCGCT.1      2151       102 ## ctrl_AAACGGCTCTTCGC.1      1916       103 ## ctrl_AACACTCTAAGTAG.1      1869        95 ## ctrl_AACCGCCTCAGGAG.1       733        84 ## ctrl_AACGTTCTTCCGTC.1       573        76 ## ...                         ...       ... ## stim_TTCATGACTTATCC.1      1091       101 ## stim_TTCATGACTTCAGG.1       431        86 ## stim_TTCGGAGATTTCAC.1      1344       102 ## stim_TTGACACTTCCTGC.1      1423       105 ## stim_TTTGCATGAACGAA.1      2818       120 nUMI <- cellMeta(pbmc, \"nUMI\", useDatasets = \"ctrl\") length(nUMI) ## [1] 300 foo <- seq_len(ncol(pbmc)) pbmc$foo <- foo # Alternatively cellMeta(pbmc, \"foo\") <- foo ctrlBar <- seq_len(ncol(dataset(pbmc, \"ctrl\"))) cellMeta(pbmc, \"ctrl_bar\", useDataset = \"ctrl\") <- ctrlBar"},{"path":"/articles/liger_object.html","id":"access-dimensionality-reductions","dir":"Articles","previous_headings":"","what":"Access dimensionality reductions","title":"Interact with A Liger Object","text":"get list dimensionality reductions: get specific dimensionality reduction: get specific dimensionality reduction specific dataset, , use argument useDatasets. Setting existing dimensionality reduction default visualization Every time runUMAP() runTSNE() called, new result set default. default dimensionality reduction set, plotting function shall work use default without need specify explicitly. dimensionality reduction accessor function also returns default one specific one requested. Add new matrix object Cell identifiers rownames(value) checked matching present. check aware dataset name prefix added object cell IDs. Adding dimensionality reduction matrix one certain dataset","code":"allDimReds <- dimReds(pbmc) class(allDimReds) length(allDimReds) ## [1] \"list\" ## [1] 1 umap <- dimRed(pbmc, \"UMAP\") class(umap) dim(umap) ## [1] \"matrix\" \"array\"  ## [1] 600   2 ctrlUMAP <- dimRed(pbmc, \"UMAP\", useDatasets = \"ctrl\") dim(ctrlUMAP) ## [1] 300   2 defaultDimRed(pbmc) <- \"UMAP\" umap <- dimRed(pbmc) dimRed(pbmc, \"newUMAP\") <- umap ctrlUMAP <- dimRed(pbmc, \"UMAP\", useDatasets = \"ctrl\") dimRed(pbmc, \"ctrlUMAP\", useDatasets = \"ctrl\") <- ctrlUMAP"},{"path":"/articles/liger_object.html","id":"access-factorization-result","dir":"Articles","previous_headings":"","what":"Access factorization result","title":"Interact with A Liger Object","text":"suggest using getMatrix() matrices involved factorization, including: \\(H\\), \\(V\\) matrices produced dataset, involved iNMF variant algorithms \\(W\\) matrix shared datasets, involved iNMF variant algorithms NMF dimension reduction \\(H.norm\\), aligned factor loading matrix, produced downstream iNMF integration quantileNorm() \\(\\) \\(B\\) matrices produced intermediate information dataset online iNMF interations \\(U\\) matrices produced dataset, involved UINMF","code":"HList <- getMatrix(pbmc, \"H\") lapply(HList, dim) ## $ctrl ## [1]  20 300 ##  ## $stim ## [1]  20 300"},{"path":"/articles/liger_object.html","id":"subsetting-the-data","dir":"Articles","previous_headings":"","what":"Subsetting the data","title":"Interact with A Liger Object","text":"liger object can subset cells genes. cell level subsetting, indexing method among barcode names, numeric logical index can job. Cells indexed rownames(cellMeta(object)), concatenation barcodes dataset, datasets ordered names(object) shows. gene level subsetting, allow using gene names, assumed different datasets can different set genes. genes shared datasets can used. ligerDataset object can subset cells genes. Cell level subsetting works exactly way liger object. Gene level subsetting ligerDataset object can achieved type index. Note , scaleData(ctrlLD) scaleUnsharedData(ctrlLD) comes variable genes identified upstream. Subsetting genes ligerDataset object based raw input data. Therefore, take user specification available scaled data subset scaled data.","code":"pbmcSmall <- pbmc[, 1:100] ## ℹ Subsetting dataset: \"ctrl\" ## ✔ Subsetting dataset: \"ctrl\" ... done ## pbmcCluster1 <- pbmc[, pbmc$leiden_cluster == 1] ## ℹ Subsetting dataset: \"ctrl\" ## ℹ Subsetting dataset: \"stim\" ## ✔ Subsetting dataset: \"stim\" ... done ## ##  [36mℹ [39m Subsetting dataset:  [34m\"ctrl\" [39m  [32m✔ [39m Subsetting dataset:  [34m\"ctrl\" [39m ... done pbmcVarOnly <- pbmc[varFeatures(pbmc),] ## ℹ Subsetting dataset: \"ctrl\" ## ℹ Subsetting dataset: \"stim\" ## ✔ Subsetting dataset: \"stim\" ... done ## ##  [36mℹ [39m Subsetting dataset:  [34m\"ctrl\" [39m  [32m✔ [39m Subsetting dataset:  [34m\"ctrl\" [39m ... done ctrlUnsharedGenes <- c(\"P2RY1\", \"GFI1B\", \"HDGFRP2\", \"TUBGCP6\", \"CELA1\") # Not run, will raise error # pbmc[ctrl.unshared.genes,] ctrlLD <- dataset(pbmc, \"ctrl\") ctrlLDSmall <- ctrlLD[, 1:100] ctrlLDsmall <- ctrlLD[1:100, ] ctrlLDsmall <- ctrlLD[1:100, 1:100]"},{"path":"/articles/liger_object.html","id":"check-the-records-of-run-commands","dir":"Articles","previous_headings":"","what":"Check the records of run commands","title":"Interact with A Liger Object","text":"implemented analysis tracking feature order keep record functions called parameters used. show list function names applied liger object time order unique suffix added function name keep track calls function different parameters. Detailed function call information can retrieved partial matching. function can applied object several times parameter tweaks. example, different lambda iNMF integration. runINMF() called several times, calling commands(pbmc, \"runINMF\") returns list records calls, record names starting \"runINMF\" matched. listing names first using unique record name required getting information one specific call among . another example, given runCluster() runUMAP() also record, following result returned matching \"run\"","code":"commands(pbmc) ## [1] \"normalize.liger_14e6077ce8\"      \"selectGenes.liger_5e95d93621\"    ## [3] \"scaleNotCenter.liger_af6ce74ea4\" \"runINMF.liger_e174922df1\"        ## [5] \"quantileNorm.liger_192a85fe37\"   \"runCluster_7ab2199e62\"           ## [7] \"runUMAP_0870bae906\" commands(pbmc, \"runINMF\") ## A liger command record, performed at 03-16-2024 00:55:38 EDT  ## Call: runINMF.liger(object, k = k, lambda = lambda, seed = seed, verbose = verbose,      ...)  ## Parameters: ##     k : 20  ##     lambda : 5  ##     nIteration : 30  ##     nRandomStarts : 1  ##     HInit : NULL  ##     WInit : NULL  ##     VInit : NULL  ##     seed : 1  ##     nCores : 2  ##     verbose : TRUE commands(pbmc, \"run\") ## $runINMF.liger_e174922df1 ## A liger command record, performed at 03-16-2024 00:55:38 EDT  ## Call: runINMF.liger(object, k = k, lambda = lambda, seed = seed, verbose = verbose,      ...)  ## Parameters: ##     k : 20  ##     lambda : 5  ##     nIteration : 30  ##     nRandomStarts : 1  ##     HInit : NULL  ##     WInit : NULL  ##     VInit : NULL  ##     seed : 1  ##     nCores : 2  ##     verbose : TRUE  ##  ## $runCluster_7ab2199e62 ## A liger command record, performed at 03-16-2024 00:55:38 EDT  ## Call: runCluster(.)  ## Parameters: ##     resolution : 1  ##     nNeighbors : 20  ##     prune : 0.0666666666666667  ##     eps : 0.1  ##     nRandomStarts : 10  ##     nIterations : 5  ##     method : \"leiden\"  ##     useRaw : NULL  ##     useDims : NULL  ##     groupSingletons : TRUE  ##     clusterName : \"leiden_cluster\"  ##     seed : 1  ##     verbose : TRUE  ##  ## $runUMAP_0870bae906 ## A liger command record, performed at 03-16-2024 00:55:38 EDT  ## Call: runUMAP(.)  ## Parameters: ##     useRaw : NULL  ##     useDims : NULL  ##     nDims : 2  ##     distance : \"cosine\"  ##     nNeighbors : 20  ##     minDist : 0.1  ##     dimredName : \"UMAP\"  ##     seed : 42  ##     verbose : TRUE"},{"path":"/articles/liger_with_seurat.html","id":"goal-of-this-article","dir":"Articles","previous_headings":"","what":"Goal of this article","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"introduced basic usage LIGER throughout many vignettes, together various use cases. article, bring LIGER Seurat users, showing run rliger functions Seurat objects integrate datasets. old version (< 1.99.0), provided wrapper functions SeuratWrappers allow rliger functions run Seurat objects. current new version (>= 1.99.0), now provide native support Seurat objects rliger. functions applied liger object can now directly applied Seurat object. article demonstrate workflow loading standard Seurat data obtaining integration labeling.","code":""},{"path":"/articles/liger_with_seurat.html","id":"example-datasets-with-v5-style","dir":"Articles","previous_headings":"","what":"Example datasets, with V5 style","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"vignette uses example shown Seurat official integration tutorial. package called SeuratData needed loading example datasets. release Seurat v5, now recommended gene expression data, namingly “counts”, “data” “scale.data” slots previously Seurat Assay, splitted batches. metadata variable required presented indicates batch information. example dataset, batch information stored stim variable. analogous ligerObj$dataset variable liger object. printed output, can see expression data ifnb object now presented layers conditions.","code":"library(Seurat) library(SeuratData) library(patchwork) library(rliger)  InstallData(\"ifnb\")  ifnb <- LoadData(\"ifnb\") ifnb ## An object of class Seurat  ## 14053 features across 13999 samples within 1 assay  ## Active assay: RNA (14053 features, 0 variable features) ##  2 layers present: counts, data ifnb[[\"RNA\"]] <- split(ifnb[[\"RNA\"]], f = ifnb$stim) ifnb ## An object of class Seurat  ## 14053 features across 13999 samples within 1 assay  ## Active assay: RNA (14053 features, 0 variable features) ##  4 layers present: counts.CTRL, counts.STIM, data.CTRL, data.STIM"},{"path":[]},{"path":"/articles/liger_with_seurat.html","id":"preprocessing","dir":"Articles","previous_headings":"Integration with LIGER","what":"Preprocessing","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"first step go QC remove non-expressing cells genes. LIGER’s primary strategy integration perform integrative non-negative matrix factorization (iNMF). Due nature method, important -zero rows columns removed input data. QC criteria can also optionally added, minimum number genes expressed, minimum number UMIs, mitochondrial gene percentage etc. QC techniques simple similar across kinds toolkits platforms, go detail . Given metrics already calculated creating Seurat object, directly go Seurat suggested syntax obtain subset. next perform preprocessing steps specific LIGER: library size normalization, without CPM log1p transformation Variable gene selection, done individually dataset combined Scaling normalized expression variable genes, without centering address non-negative requirement iNMF Note new layers created normalized scaled data named different Seurat general convention. Instead \"data\" \"scale.data\" see Seurat object, name \"ligerNormData\" \"ligerScaleData\", respectively, order avoid data processed LIGER-specific approach misused general scRNAseq analysis, Seurat general production misused LIGER integration.","code":"ifnb <- subset(ifnb, subset = nFeature_RNA > 200 & nFeature_RNA < 2500) ifnb <- ifnb %>%     normalize() %>%     selectGenes() %>%     scaleNotCenter() ifnb ## An object of class Seurat  ## 14053 features across 13997 samples within 1 assay  ## Active assay: RNA (14053 features, 4233 variable features) ##  8 layers present: counts.CTRL, counts.STIM, data.CTRL, data.STIM, ligerNormData.CTRL, ligerNormData.STIM, ligerScaleData.CTRL, ligerScaleData.STIM"},{"path":"/articles/liger_with_seurat.html","id":"integration","dir":"Articles","previous_headings":"Integration with LIGER","what":"Integration","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"Now, ready performing iNMF integration two datasets. object information shown , runINMF() produces two low-dimensional representations, can accessed ifnb[[\"inmf\"]] ifnb[[\"inmfNorm\"]]. call cell factor loading matrices. first one raw factorization result iNMF, second one quantile normalized version first one. quantile normalization performed suppressing variance cell datasets datasets can well aligned.","code":"ifnb <- ifnb %>%     runINMF(k = 20) %>%     quantileNorm() ifnb ## An object of class Seurat  ## 14053 features across 13997 samples within 1 assay  ## Active assay: RNA (14053 features, 4233 variable features) ##  8 layers present: counts.CTRL, counts.STIM, data.CTRL, data.STIM, ligerNormData.CTRL, ligerNormData.STIM, ligerScaleData.CTRL, ligerScaleData.STIM ##  2 dimensional reductions calculated: inmf, inmfNorm"},{"path":"/articles/liger_with_seurat.html","id":"visualizing-the-integration-result","dir":"Articles","previous_headings":"Integration with LIGER","what":"Visualizing the integration result","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"Given example data provided Seurat already annotation cell types, can now examine visually integration result looks like. create UMAP embedding using cell factor loading, make scatter plot colored dataset source cell type annotation.  visualize two conditions side--side, can use split.argument show condition colored cluster.","code":"ifnb <- RunUMAP(ifnb, reduction = \"inmfNorm\", dims = 1:20) gg.byDataset <- DimPlot(ifnb, group.by = \"stim\") gg.byCelltype <- DimPlot(ifnb, group.by = \"seurat_annotations\") gg.byDataset + gg.byCelltype DimPlot(ifnb, group.by = \"seurat_annotations\", split.by = \"stim\")"},{"path":"/articles/liger_with_seurat.html","id":"joint-clustering","dir":"Articles","previous_headings":"Integration with LIGER","what":"Joint clustering","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"Despite annotation provided , time, people need cluster cells basing integration work annotation. demonstrate use Seurat functions create cluster labels basing cell factor loading obtained runINMF(). , can also visualize clustering label UMAP previously created.","code":"ifnb <- ifnb %>%     FindNeighbors(reduction = \"inmfNorm\", dims = 1:20) %>%     FindClusters() ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 13997 ## Number of edges: 475772 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8865 ## Number of communities: 17 ## Elapsed time: 1 seconds DimPlot(ifnb, group.by = \"seurat_clusters\")"},{"path":"/articles/liger_with_seurat.html","id":"class-conversion-in-various-use-cases","dir":"Articles","previous_headings":"","what":"Class conversion in various use cases","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"Examples based latest Seurat architecture, layers data can split dataset source, makes computationally efficient kinds integration tool, LIGER also methods introduced Seurat official integration vignette. highly recommend users follow syntax. However, working existing projects old version Seurat object presence, want move Seurat downstream analysis LIGER integration, show potential work arounds section .","code":""},{"path":"/articles/liger_with_seurat.html","id":"update-seurat-object-to-its-latest-structure","dir":"Articles","previous_headings":"Class conversion in various use cases","what":"Update Seurat object to its latest structure","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"Seurat provides UpdateSeuratObject() function automatically convert Seurat objects old versions latest version. , previously introduced analysis can applied updated object.","code":"seuratObj.new <- UpdateSeuratObject(seuratObj.old)"},{"path":"/articles/liger_with_seurat.html","id":"create-a-liger-object-from-multiple-seurat-objects","dir":"Articles","previous_headings":"Class conversion in various use cases","what":"Create a liger object from multiple Seurat objects","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"old days, Seurat recommended datasets integrated stored separately individual Seurat objects. data form, suggest using createLigerObject() function named list Seurat objects. Note metadata individual objects copied liger object, guarantee field consistency can bring lot mess, LIGER’s core integration functionality rely metadata now. However, need keep metadata quick visualization integration, can manually bring liger object cellMeta()<- method. Setting useDataset argument ensures metadata extracted single dataset assigned matching dataset; argument inplace indicates values replaced specified dataset instead erasing existing values cells variable first.","code":"seurat.list <- list(dataName1 = seuratObj1, dataName2 = seuratObj2) ligerObj <- createLiger(seurat.list) cellMeta(ligerObj, \"newVarName\", useDataset = \"dataName1\", inplace = TRUE) <- seuratObj1$oldVarName"},{"path":"/articles/liger_with_seurat.html","id":"convert-a-single-seurat-object-to-a-liger-object","dir":"Articles","previous_headings":"Class conversion in various use cases","what":"Convert a single Seurat object to a liger object","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"expected can scenario datasets integrated stored single Seurat object. case, best practice update object latest version yet, split() shown previous example. However, users interested full LIGER style analysis, provide .liger() method Seurat object. Importantly, datasetVar argument must properly provided LIGER infer dataset source. Optionally, annotation dimensionality reduction presented, can set default value liger object quick visualization  Note converting Seurat object liger object, raw gene expression counts copied output object. mentioned preprocessing step, normalized scaled data produced tools generally suitable LIGER analysis.","code":"ifnb.liger <- as.liger(ifnb, datasetVar = \"stim\") defaultCluster(ifnb.liger) <- \"seurat_clusters\" defaultDimRed(ifnb.liger) <- \"umap\" plotByDatasetAndCluster(ifnb.liger)"},{"path":"/articles/liger_with_seurat.html","id":"move-on-to-seurat-downstream-analysis-after-liger","dir":"Articles","previous_headings":"Class conversion in various use cases","what":"Move on to Seurat downstream analysis after LIGER","title":"Using LIGER to integrate datasets stored in Seurat objects","text":"Downstream analysis obtaining joint clustering labels integration always common use case. LIGER provides wide range methods purpose, runMarkerDEG() runPairwiseDEG() help across-cluster across-condition-per-cluster comparison; imputeKNN() linkGenesAndPeaks() cross comparison dual-omics data; runGOEnrich() runGSEA() functional enrichment analysis. extending analysis much possibility possible, provide conversion methods exporting liger object publically known structure.  shown printed information , normalized scaled data explicitly named avoid confusion general scRNAseq use case. quantile-normalized cell factor loading now stored reduction pbmc.seurat[[\"inmf\"]].","code":"data(\"pbmc\", package = \"rliger\") # Go through a full regular LIGER analysis pbmc <- pbmc %>%     normalize() %>%     selectGenes() %>%     scaleNotCenter() %>%     runINMF(k = 20) %>%     quantileNorm() %>%     runCluster() %>%     runUMAP()  pbmc.seurat <- ligerToSeurat(pbmc) pbmc.seurat ## An object of class Seurat  ## 279 features across 600 samples within 1 assay  ## Active assay: RNA (279 features, 173 variable features) ##  6 layers present: counts.ctrl, counts.stim, ligerNormData.ctrl, ligerNormData.stim, ligerScaleData.ctrl, ligerScaleData.stim ##  2 dimensional reductions calculated: inmf, UMAP DimPlot(pbmc.seurat)"},{"path":"/articles/online_iNMF_tutorial.html","id":"load-data-and-preprocess","dir":"Articles","previous_headings":"","what":"Load data and preprocess","title":"Iterative single-cell multi-omic integration using online learning","text":"LIGER supports integrating datasets based HDF5 files, examples, 10X CellRanger output file located sample/outs/filtered_feature_bc_matrix.h5 can used LIGER. ’s link learn CellRanger output HDF5 files. feature read one chunk data memory time, large-scale datasets stored disk can analyzed rather small memory specification. Large datasets often generated multiple 10X runs (example, multiple biological replicates). cases may necessary merge HDF5 files run single HDF5 file. provide mergeH5() function purpose. integrate datasets stored HDF5 files, first create liger object using file names HDF5 files. prepared following example datasets demonstration: pbmcs_ctrl.h5 pbmcs_stim.h5 Similar iNMF integration tutorial, also need preprocee data 1. normalizing cell library size, 2. select variable genes dataset, 3. scale gene expression within dataset non-negative way.","code":"library(rliger)  dataSource <- data.frame(     filenames = c(\"pbmcs_ctrl_vignette.h5\",                    \"pbmcs_stim_vignette.h5\"),     urls = c(\"https://figshare.com/ndownloader/files/43108963\",              \"https://figshare.com/ndownloader/files/43108966\") ) for (i in seq_len(nrow(dataSource))) {     if (!file.exists(dataSource$filenames[i])) {         download.file(dataSource$urls[i], destfile = dataSource$filenames[i])     } }  pbmcs <- createLiger(list(ctrl = dataSource$filenames[1],                           stim = dataSource$filenames[2])) pbmcs <- pbmcs %>%     normalize() %>%     selectGenes(var.thresh = 0.2) %>%     scaleNotCenter()"},{"path":[]},{"path":"/articles/online_iNMF_tutorial.html","id":"online-integrative-nonnegative-matrix-factorization","dir":"Articles","previous_headings":"Scenario 1: sampling minibatches from fully observed datasets","what":"Online Integrative Nonnegative Matrix Factorization","title":"Iterative single-cell multi-omic integration using online learning","text":"Now can use online iNMF factorize data, using minibatches read HDF5 files demand (default mini-batch size = 5000). Sufficient number iterations crucial obtaining ideal factorization result. size mini-batch set close size whole dataset (.e. epoch contains one iteration), max.epochs needs increased accordingly iterations.","code":"pbmcs <- runIntegration(pbmcs, k = 20, method = \"online\")"},{"path":"/articles/online_iNMF_tutorial.html","id":"joint-clustering-and-visualization","dir":"Articles","previous_headings":"Scenario 1: sampling minibatches from fully observed datasets","what":"Joint clustering and visualization","title":"Iterative single-cell multi-omic integration using online learning","text":"performing factorization, can perform quantile normalization align datasets, use graph based community detection algorithm find clusters. can also visualize cell factor loadings two dimensions using t-SNE UMAP.","code":"pbmcs <- quantileNorm(pbmcs) pbmcs <- runCluster(pbmcs, nNeighbors = 30, resolution = .6, nRandomStarts = 2) pbmcs <- runUMAP(pbmcs, nNeighbors = 30, minDist = .3) plotByDatasetAndCluster(pbmcs)"},{"path":"/articles/online_iNMF_tutorial.html","id":"downstream-analysis","dir":"Articles","previous_headings":"Scenario 1: sampling minibatches from fully observed datasets","what":"Downstream analysis","title":"Iterative single-cell multi-omic integration using online learning","text":"downstream analysis requires expression data, differential expression test, currently support direct computation using -disk HDF5 data. order conduct analyses, users need create downsampled subset large-scale -disk data read memory. default, downsample() function randomly samples maxCells cells. Alternatively, can set balanced sampling basing given categorical variables. Note newH5 = FALSE set order take subsample memory, wise another downsampled HDF5 file created still used downstream analysis method. Using sampled data stored memory, can now compare clusters datasets identify differentially expressed genes. runMarkerDEG() function performs differential expression analysis, default Wilcoxon rank-sum test. default mode mark detection goes finding marker cluster performing test cluster rest. , demonstrate finding dataset-specific markers, within cluster. returned object list element dataset-specific marker table derived within cluster contains stats genes without filtering sorting. strongly suggest using package “dplyr” data frame operation due simplicity. , show example getting top 10 markers “stim” within cluster 2. can show UMAP coordinates sampled cells loadings factor (Factor 4 example). lower part figure shows gene loading ranking factor, middle showing ranking shared gene loading, dataset-specific gene loading ranking two sides.","code":"pbmcs.sample <- downsample(pbmcs, maxCells = 5000, useSlot = \"normData\", newH5 = FALSE) markerTableList <- runMarkerDEG(pbmcs.sample, conditionBy = \"dataset\", splitBy = \"leiden_cluster\") library(dplyr) markerTable2 <- markerTableList$`2` markerTable2 %>%     filter(logFC > 1, padj < 0.05, group == \"stim\") %>%     arrange(padj, -logFC) %>%     top_n(10) %>%     select(feature, logFC, padj) factorMarker <- getFactorMarkers(pbmcs.sample, dataset1 = \"ctrl\", dataset2 = \"stim\") plotGeneLoadings(pbmcs.sample, markerTable = factorMarker, useFactor = 4)"},{"path":"/articles/online_iNMF_tutorial.html","id":"visualization-with-expression","dir":"Articles","previous_headings":"Scenario 1: sampling minibatches from fully observed datasets","what":"Visualization with expression","title":"Iterative single-cell multi-omic integration using online learning","text":"subsampled data loaded memory, can also generate plots dimensional reduction coordinates colored expression specified gene. example, gene ISG15 expression visualized .  Furthermore, can make violin plots expression specified gene. Taking ISG15 example , can make violin plot dataset group cluster.","code":"plotGeneDimRed(pbmcs.sample, \"ISG15\") plotGeneViolin(pbmcs.sample, \"ISG15\", byDataset = TRUE, title = names(pbmcs.sample))"},{"path":"/articles/online_iNMF_tutorial.html","id":"scenario-2-iterative-refinement-by-incorporating-new-datasets","dir":"Articles","previous_headings":"","what":"Scenario 2: iterative refinement by incorporating new datasets","title":"Iterative single-cell multi-omic integration using online learning","text":"second scenario online learning algorithm performed factorization existing dataset(s), add continually arriving datasets pool update factorization existing result. example, still PBMC example, first perform online iNMF control dataset. , obtain new dataset, run online iNMF adding new arriving dataset. couple points note. different ways specifying new datasets. allow using either named list raw data. users work HDF5 based data way, ’s best named list HDF5 filenames. users work -memory matrices, named list matrix objects (dgCMatrix class). New datasets always regarded raw count input, preprocessed internally. variable genes identified using original existing datasets always used taking scaled data. Therefore, users need make sure newly arriving datasets available. Alternatively, liger object can also used input argument newDatasets. Users need aware second point , remove missing features default can cause error variable features obtained existing dataserts identified missing creating object new datasets. HDF5 filename inputs, assumed program can find raw counts data 10X CellRanger format. HDF5 file stores raw counts data different way (e.g. H5AD data), users need create separate liger object specification, use constructed object input aware 2nd 3rd point . seccessfully integrating new datasets existing factorization, returned liger obejct inserted. factorization, can go procedure align factor loading jointly cluster cells, well visualize integration result.","code":"pbmcs <- createLiger(list(ctrl = \"pbmcs_ctrl_vignette.h5\")) %>%   normalize() %>%   selectGenes() %>%   scaleNotCenter() %>%   runIntegration(method = \"online\") pbmcs.new <- runOnlineINMF(pbmcs, newDatasets = list(stim = \"pbmcs_stim_vignette.h5\")) pbmcs.new <- quantileNorm(pbmcs.new) %>%   runCluster(nNeighbors = 30, resolution = .6, nRandomStarts = 2) %>%   runUMAP(nNeighbors = 30, minDist = .3)  plotByDatasetAndCluster(pbmcs.new)"},{"path":"/articles/online_iNMF_tutorial.html","id":"scenario-3-projecting-new-datasets","dir":"Articles","previous_headings":"","what":"Scenario 3: Projecting new datasets","title":"Iterative single-cell multi-omic integration using online learning","text":"third scenario serves fast inspection new datasets. update factorization newly arriving data, instead, compute factor loading cells (.e. \\(H\\) matrices new datasets) using existing gene loading factors (\\(W\\) matrix previous factorization). Therefore, dataset-specific gene loading factors (\\(V\\) matrices) can produced new datasets approach. Scenario 3 can triggered specifying new datasets, following guidance scenario 2 , set projection = TRUE.","code":"pbmcs <- createLiger(list(ctrl = \"pbmcs_ctrl_vignette.h5\")) %>%   normalize() %>%   selectGenes() %>%   scaleNotCenter() %>%   runIntegration(method = \"online\") pbmcs.new <- runOnlineINMF(pbmcs, newDatasets = list(stim = \"pbmcs_stim_vignette.h5\"), projection = TRUE) pbmcs.new <- quantileNorm(pbmcs.new) %>%   runCluster(nNeighbors = 30, resolution = .6, nRandomStarts = 2) %>%   runUMAP(nNeighbors = 30, minDist = .3)  plotByDatasetAndCluster(pbmcs.new)"},{"path":"/articles/rna_methylation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Jointly Defining Cell Types from Single-Cell Gene Expression and Methylation Data Using LIGER","text":"vignette shows use LIGER jointly define cell types single-cell gene expression DNA methylation. using scRNA-seq single-nucleus DNA methylation data mouse cortex. datasets used previous paper. steps involved quite similar integrating multiple RNA datasets. differences (1) process methylation data gene-level values comparable gene expression, (2) perform gene selection using RNA data , (3) scale center factor loadings performing quantile normalization. full dataset used paper quite large, example, restrict attention inhibitory interneurons derived caudal ganglionic eminence (CGE). downloaded gene-level methylation data provided Ecker lab. generated values dividing numbers methylated (non-CG methylation, mCH) detected positions across gene body within cell. found gene body mCH proportions negatively correlated gene expression level neurons. gene expression data Saunders et al. 2018. full dataset available download Dropviz. convenience, provide gene x cell count matrices CGE interneurons well original cluster assignment obtained study: RNA data 18,455 genes 2,927 cells mouse_frontal_cortex_cge_rna.RDS RNA data cluster assignment rna_clusters.RDS Methylation data 31,928 genes 184 cells mouse_frontal_cortex_cge_met.RDS Methylation data cluster assignment met_clusters.RDS","code":"rna <- readRDS(\"meth_data/mouse_frontal_cortex_cge_rna.RDS\") met <- readRDS(\"meth_data/mouse_frontal_cortex_cge_met.RDS\") rna_clusts <- readRDS(\"meth_data/rna_clusters.RDS\") met_clusts <- readRDS(\"meth_data/met_clusters.RDS\")"},{"path":"/articles/rna_methylation.html","id":"create-liger-object-and-preprocess-data","dir":"Articles","previous_headings":"","what":"Create liger object and preprocess data","title":"Jointly Defining Cell Types from Single-Cell Gene Expression and Methylation Data Using LIGER","text":"create liger object using methylation expression data. Alternatively, build importing function directly pull datasets online storage build liger object. selectGenes() function performs variable gene selection datasets separately, takes union result. variable genes selected comparing variance gene’s expression mean expression. selectGenes() function written primarily scRNA-seq mind, methylation data distribution quite different. instead taking union variable genes RNA methylation, set useDatasets = \"rna\" function perform gene selection using RNA dataset. gene body mCH proportions negatively correlated gene expression level neurons, need reverse direction methylation data, simply subtracting values maximum methylation value per selected dataset. resulting values positively correlated gene expression. addition, proportional nature gene body methylation makes unnecessary normalize scale methylation data. setting argument modal createLiger(), ’ve already marked need take actions methylation dataset, function scaleNotCenter() automatically done properly. Optionally, reverseMethData() explicitly reversing operation specified datasets datasets initially marked methylation data.","code":"library(rliger)  rna.met <- createLiger(list(rna = rna, met = met), modal = c(\"rna\", \"meth\")) # NOT RUN rna.met <- importCGE() rna.met <- rna.met %>%      normalize() %>%     selectGenes(useDatasets = \"rna\") %>%     scaleNotCenter()"},{"path":"/articles/rna_methylation.html","id":"factorize-and-perform-quantile-normalization","dir":"Articles","previous_headings":"","what":"Factorize and perform quantile normalization","title":"Jointly Defining Cell Types from Single-Cell Gene Expression and Methylation Data Using LIGER","text":"Next perform integrative non-negative matrix factorization (iNMF) order identify shared distinct metagenes across datasets corresponding metagene loadings cell. important parameters factorization k (number factors) lambda (penalty parameter limits dataset-specific component factorization). default value lambda = 5 usually provides reasonable results analyses. analysis, simply use k = 20 default value lambda. Using metagene factors calculated iNMF, assign cell factor highest loading, giving joint clusters correspond across datasets. perform quantile normalization dataset, factor, cluster fully integrate datasets. perform analysis, typing : quantileNorm() function gives joint clusters correspond across datasets. However, desired, quantile normalization, users can additionally run Leiden algorithm community detection, widely used single-cell analysis excels merging small clusters broad cell classes. can achieved running runCluster() function. Several tuning parameters, including resolution, nNeighbors, prune control number clusters produced function.","code":"rna.met <- runIntegration(rna.met, k = 20) rna.met <- quantileNorm(rna.met) rna.met <- runCluster(rna.met, nNeighbors = 30)"},{"path":"/articles/rna_methylation.html","id":"visualize-results","dir":"Articles","previous_headings":"","what":"Visualize results","title":"Jointly Defining Cell Types from Single-Cell Gene Expression and Methylation Data Using LIGER","text":"run t-SNE normalized factors, color t-SNE coordinates dataset cluster.   t-SNE plot shows datasets align well indicates jointly inferred clusters. Using original RNA methylation cluster assignments, can visually confirm joint analysis highly consistent single-modality analyses. First, insert original cluster assignment “cellMeta” variables. cell metadata table contains variables apply datasets together. Partial insertion values part datasets requires cell index specification ensure correctness. , can visualize variables. Note “NA” values plot indicate cells belong dataset.  Plotting marker genes subtypes CGE interneurons confirms data types properly aligned, expected inverse relationship gene body mCH gene expression.","code":"rna.met <- runTSNE(rna.met) plotDatasetDimRed(rna.met) plotClusterDimRed(rna.met, legendNCol = 1) # `rna_clusts` is a named factor object, and the names match with `colnames(rna)` # However, a prefix of `\"datasetName_\"` is appended when creating the liger object names(rna_clusts) <- paste0(\"rna_\", names(rna_clusts)) # `rna_clusts` contains all cells from the original study while we only deal # with the CGE interneurons in this vignette. # Use `drop = TRUE` to omit unexisting categories in the resulting subset. rna_clusts <- rna_clusts[names(rna_clusts) %in% colnames(rna.met), drop = TRUE] # Use `columns` to name the new variable in metadata cellMeta(rna.met, columns = \"rna_cluster\", cellIdx = names(rna_clusts)) <- rna_clusts  # Similarly names(met_clusts) <- paste0(\"met_\", names(met_clusts)) met_clusts <- met_clusts[names(met_clusts) %in% colnames(rna.met), drop = TRUE] cellMeta(rna.met, columns = \"met_cluster\", cellIdx = names(met_clusts)) <- met_clusts rnaPlot <- plotClusterDimRed(rna.met, useCluster = \"rna_cluster\", legendNCol = 1) metPlot <- plotClusterDimRed(rna.met, useCluster = \"met_cluster\") cowplot::plot_grid(rnaPlot, metPlot) plots <- plotGeneDimRed(rna.met, c(\"Vip\", \"Lamp5\"), splitBy = \"dataset\",                         titles = c(names(rna.met), names(rna.met))) cowplot::plot_grid(plotlist = plots, nrow = 2)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joshua Welch. Author. Yichen Wang. Author, maintainer. Chao Gao. Author. Jialin Liu. Author. Joshua Sodicoff. Author, contributor. Velina Kozareva. Author, contributor. Evan Macosko. Author, contributor. Paul Hoffman. Contributor. Ilya Korsunsky. Contributor. Robert Lee. Contributor. Andrew Robbins. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Welch J, Wang Y, Gao C, Liu J, Sodicoff J, Kozareva V, Macosko E (2024). rliger: Linked Inference Genomic Experimental Relationships. R package version 1.99.1, https://github.com/welch-lab/liger.","code":"@Manual{,   title = {rliger: Linked Inference of Genomic Experimental Relationships},   author = {Joshua Welch and Yichen Wang and Chao Gao and Jialin Liu and Joshua Sodicoff and Velina Kozareva and Evan Macosko},   year = {2024},   note = {R package version 1.99.1},   url = {https://github.com/welch-lab/liger}, }"},{"path":"/index.html","id":"liger-linked-inference-of-genomic-experimental-relationships","dir":"","previous_headings":"","what":"Linked Inference of Genomic Experimental Relationships","title":"Linked Inference of Genomic Experimental Relationships","text":"Now comprehensive documentation site latest version rliger (2.0)! LIGER (installed rliger ) package integrating analyzing multiple single-cell datasets, developed Macosko lab maintained/extended Welch lab. relies integrative non-negative matrix factorization identify shared dataset-specific factors. Check Cell paper complete description methods analyses. access data used SN BNST analyses, visit study “SCP466” Single Cell Portal. LIGER can used compare contrast experimental datasets variety contexts, instance: Across experimental batches Across individuals Across sex Across tissues Across species (e.g., mouse human) Across modalities (e.g., scRNAseq spatial transcriptomics data, scMethylation, scATAC-seq) multiple datasets integrated, package provides functionality data exploration, analysis, visualization. Users can: Identify clusters Find significant shared (dataset-specific) gene markers Compare clusters previously identified cell types Visualize clusters gene expression using t-SNE UMAP also designed LIGER interface existing single-cell analysis packages, including Seurat.","code":""},{"path":"/index.html","id":"feedback","dir":"","previous_headings":"","what":"Feedback","title":"Linked Inference of Genomic Experimental Relationships","text":"questions, comments, suggestions, welcomed open Issue!","code":""},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Linked Inference of Genomic Experimental Relationships","text":"usage examples guided walkthroughs, check vignettes directory repo. Integrating Multiple Single-Cell RNA-seq Datasets Jointly Defining Cell Types scRNA-seq scATAC-seq Iterative Single-Cell Multi-Omic Integration Using Online iNMF Integrating unshared features UINMF Integrating spatial transcriptomic transcriptomic datasets using UINMF scATAC scRNA Integration using unshared features (UINMF) Cross-species Analysis UINMF Jointly Defining Cell Types Single-Cell RNA-seq DNA Methylation Meanwhile, since version 2.0.0, LIGER massively updated usability interoperability packages. links introduction new features. Introduction new liger object related classes Running Liger directly Seurat objects","code":""},{"path":"/index.html","id":"sample-datasets","dir":"","previous_headings":"","what":"Sample Datasets","title":"Linked Inference of Genomic Experimental Relationships","text":"rliger package provides different types small toy dataset basic demos functions. attaching package R session, can load : also provide set datasets real-world style demos, including scRNAseq, scATACseq, spatial transcriptomics DNA methylation data. described detail articles use . Please check links .","code":"data(\"pbmc\") data(\"pbmcPlot\") data(\"bmmc\")"},{"path":"/reference/H5Apply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply function to chunks of H5 data in ligerDataset object — H5Apply","title":"Apply function to chunks of H5 data in ligerDataset object — H5Apply","text":"h5 calculation wrapper, runs specified calculation -disk matrix chunks","code":""},{"path":"/reference/H5Apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply function to chunks of H5 data in ligerDataset object — H5Apply","text":"","code":"H5Apply(   object,   FUN,   init = NULL,   useData = c(\"rawData\", \"normData\"),   chunkSize = 1000,   verbose = getOption(\"ligerVerbose\"),   ... )"},{"path":"/reference/H5Apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply function to chunks of H5 data in ligerDataset object — H5Apply","text":"object ligerDataset object. FUN function applied chunk. See detail restrictions. init Initialized result need updated iteratively. Default NULL. useData slot name data processed. Choose \"rawData\", \"normData\", \"scaleData\". Default \"rawData\". chunkSize Number columns included chunk. Default 1000. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. ... arguments passed FUN.","code":""},{"path":"/reference/H5Apply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply function to chunks of H5 data in ligerDataset object — H5Apply","text":"FUN function first four arguments ordered : chunk data: sparse matrix (dgCMatrix-class) containing maximum chunkSize columns. x-vector index: index subscribes vector x slot dgCMatrix, points values chunk. Mostly used need write new sparse matrix H5 file. cell index: column index chunk whole original matrix Initialized result: customized object, value passed H5Apply(init) argument passed first iteration. returned value FUN iteratively passed next chunk iterations. important keep object structure returned value consistent init. default value four arguments pre-defined H5Apply automatically generate input.","code":""},{"path":"/reference/as.liger.html","id":null,"dir":"Reference","previous_headings":"","what":"Converting other classes of data to a liger object — as.liger.dgCMatrix","title":"Converting other classes of data to a liger object — as.liger.dgCMatrix","text":"function converts data stored SingleCellExperiment (SCE), Seurat object merged sparse matrix (dgCMatrix) liger object. designed container object matrix already contains multiple datasets integerated LIGER. individual datasets, please use createLiger instead.","code":""},{"path":"/reference/as.liger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converting other classes of data to a liger object — as.liger.dgCMatrix","text":"","code":"# S3 method for dgCMatrix as.liger(object, datasetVar = NULL, modal = NULL, ...)  # S3 method for SingleCellExperiment as.liger(object, datasetVar = NULL, modal = NULL, ...)  # S3 method for Seurat as.liger(object, datasetVar = NULL, modal = NULL, assay = NULL, ...)  seuratToLiger(object, datasetVar = NULL, modal = NULL, assay = NULL, ...)  as.liger(object, ...)"},{"path":"/reference/as.liger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converting other classes of data to a liger object — as.liger.dgCMatrix","text":"object Object. datasetVar Specify dataset belonging : 1. Select variable existing metadata object (e.g. colData column); 2. Specify vector/factor assign dataset belonging. 3. Give single character string means data one dataset (must metadata variable, otherwise understood 1.). Default NULL gathers things one dataset names \"sample\" dgCMatrix, attempts find variable \"sample\" SCE \"orig.ident\" Seurat. modal Modality setting dataset. See createLiger. ... Additional arguments passed createLiger assay Name assay use. Default NULL uses current active assay.","code":""},{"path":"/reference/as.liger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converting other classes of data to a liger object — as.liger.dgCMatrix","text":"liger object.","code":""},{"path":"/reference/as.liger.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converting other classes of data to a liger object — as.liger.dgCMatrix","text":"Seurat V5 structure, highly recommended users make use split layer feature, things like \"counts\", \"data\", \"scale.data\" can held dataset Seurat object, e.g. \"count.ctrl\", \"count.stim\", merged. Seurat object split layers given, datasetVar ignored layers directly used.","code":""},{"path":"/reference/as.liger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converting other classes of data to a liger object — as.liger.dgCMatrix","text":"","code":"# dgCMatrix (common sparse matrix class), usually obtained from other # container object, and contains multiple samples merged in one. matList <- rawData(pbmc) multiSampleMatrix <- mergeSparseAll(matList) # The `datasetVar` argument expects the variable assigning the sample source pbmc2 <- as.liger(multiSampleMatrix, datasetVar = pbmc$dataset) #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>  pbmc2 #> An object of class liger with 600 cells #> datasets(2): ctrl (300 cells), stim (300 cells)  #> cellMeta(7): dataset, barcode, nUMI, ..., hemo  #> varFeatures(0):   #> dimReds(0):    # \\donttest{ sce <- SingleCellExperiment::SingleCellExperiment(     assays = list(counts = multiSampleMatrix) ) sce$sample <- pbmc$dataset pbmc3 <- as.liger(sce, datasetVar = \"sample\") #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>  pbmc3 #> An object of class liger with 600 cells #> datasets(2): ctrl (300 cells), stim (300 cells)  #> cellMeta(8): dataset, barcode, nUMI, ..., sample  #> varFeatures(0):   #> dimReds(0):    seu <- SeuratObject::CreateSeuratObject(multiSampleMatrix) # Seurat creates variable \"orig.ident\" by identifying the cell barcode # prefixes, which is indeed what we need in this case. Users might need # to be careful and have it confirmed first. pbmc4 <- as.liger(seu, datasetVar = \"orig.ident\") #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>  #> ℹ Removing missing in dataset: \"ctrl\" #> ℹ Removing missing in dataset: \"stim\" pbmc4 #> An object of class liger with 600 cells #> datasets(2): ctrl (300 cells), stim (300 cells)  #> cellMeta(10): dataset, barcode, nUMI, ..., nFeature_RNA  #> varFeatures(0):   #> dimReds(0):    # As per Seurat V5 updates with layered data, specifically helpful udner the # scenario of dataset integration. \"counts\" and etc for each datasets can be # split into layers. seu5 <- seu seu5[[\"RNA\"]] <- split(seu5[[\"RNA\"]], pbmc$dataset) print(SeuratObject::Layers(seu5)) #> [1] \"counts.ctrl\" \"counts.stim\" pbmc5 <- as.liger(seu5) #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>  #> ℹ Removing missing in dataset: \"ctrl\" #> ℹ Removing missing in dataset: \"stim\" # }"},{"path":"/reference/as.ligerDataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Converting other classes of data to a ligerDataset object — as.ligerDataset.ligerDataset","title":"Converting other classes of data to a ligerDataset object — as.ligerDataset.ligerDataset","text":"Works converting matrix container object single ligerDataset, can also convert modality preset ligerDataset. used dense matrix object, automatically converts matrix sparse form (dgCMatrix-class). used container objects Seurat SingleCellExperiment, highly recommended object contains one dataset/sample going integrated LIGER. multi-sample objects, please use .liger dataset source variable specified.","code":""},{"path":"/reference/as.ligerDataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converting other classes of data to a ligerDataset object — as.ligerDataset.ligerDataset","text":"","code":"# S3 method for ligerDataset as.ligerDataset(   object,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   ... )  # S3 method for default as.ligerDataset(   object,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   ... )  # S3 method for matrix as.ligerDataset(   object,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   ... )  # S3 method for Seurat as.ligerDataset(   object,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   assay = NULL,   ... )  # S3 method for SingleCellExperiment as.ligerDataset(   object,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   ... )  as.ligerDataset(object, ...)"},{"path":"/reference/as.ligerDataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converting other classes of data to a ligerDataset object — as.ligerDataset.ligerDataset","text":"object Object. modal Modality setting dataset. Choose \"default\", \"rna\", \"atac\", \"spatial\", \"meth\". ... Additional arguments passed createLigerDataset assay Name assay use. Default NULL uses current active assay.","code":""},{"path":"/reference/as.ligerDataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converting other classes of data to a ligerDataset object — as.ligerDataset.ligerDataset","text":"liger object.","code":""},{"path":"/reference/as.ligerDataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converting other classes of data to a ligerDataset object — as.ligerDataset.ligerDataset","text":"","code":"ctrl <- dataset(pbmc, \"ctrl\") ctrl #> An object of class ligerDataset with 300 cells #> rawData: 266 features # Convert the modality preset as.ligerDataset(ctrl, modal = \"atac\") #> An object of class ligerATACDataset with 300 cells #> rawData: 266 features rawCounts <- rawData(ctrl) class(rawCounts) #> [1] \"dgCMatrix\" #> attr(,\"package\") #> [1] \"Matrix\" as.ligerDataset(rawCounts) #> An object of class ligerDataset with 300 cells #> rawData: 266 features"},{"path":"/reference/bmmc.html","id":null,"dir":"Reference","previous_headings":"","what":"liger object of bone marrow subsample data with RNA and ATAC modality — bmmc","title":"liger object of bone marrow subsample data with RNA and ATAC modality — bmmc","text":"liger object bone marrow subsample data RNA ATAC modality","code":""},{"path":"/reference/bmmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"liger object of bone marrow subsample data with RNA and ATAC modality — bmmc","text":"","code":"bmmc"},{"path":"/reference/bmmc.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"liger object of bone marrow subsample data with RNA and ATAC modality — bmmc","text":"liger object two dataset named \"rna\" \"atac\"","code":""},{"path":"/reference/bmmc.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"liger object of bone marrow subsample data with RNA and ATAC modality — bmmc","text":"https://www.nature.com/articles/s41587-019-0332-7","code":""},{"path":"/reference/bmmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"liger object of bone marrow subsample data with RNA and ATAC modality — bmmc","text":"Jeffrey M. Granja et. al., Nature Biotechnology, 2019","code":""},{"path":"/reference/calcARI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","title":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","text":"function aims calculating adjusted Rand index clustering result obtained LIGER external clustering (existing \"true\" annotation). ARI ranges 0 1, score 0 indicating agreement clusterings 1 indicating perfect agreement. true clustering annotation must specified base line. suggest setting object cellMeta can easily used many visualization evaluation functions. ARI can calculated specified datasets, since true annotation might available datasets. Evaluation one datasets can done specifying useDatasets. useDatasets specified, argument checking trueCluster useCluster enforced match cells specified datasets.","code":""},{"path":"/reference/calcARI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","text":"","code":"calcARI(   object,   trueCluster,   useCluster = NULL,   useDatasets = NULL,   verbose = getOption(\"ligerVerbose\", TRUE),   classes.compare = trueCluster )"},{"path":"/reference/calcARI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","text":"object liger object, clustering result present cellMeta. trueCluster Either name one variable cellMeta(object) factor object annotation matches cells considered. useCluster name one variable cellMeta(object). Default NULL uses default clusters. useDatasets character vector names, numeric logical vector index datasets considered purity calculation. Default NULL uses datasets. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. classes.compare [Deprecated/Renamed]. Use trueCluster instead.","code":""},{"path":"/reference/calcARI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","text":"numeric scalar, ARI clustering result indicated useCluster compared trueCluster.","code":""},{"path":"/reference/calcARI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","text":"L. Hubert P. Arabie (1985) Comparing Partitions, Journal Classification, 2, pp. 193-218.","code":""},{"path":"/reference/calcARI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables — calcARI","text":"","code":"# Assume the true cluster in `pbmcPlot` is \"leiden_cluster\" # generate fake new labeling fake <- sample(1:7, ncol(pbmcPlot), replace = TRUE) # Insert into cellMeta pbmcPlot$new <- factor(fake) calcARI(pbmcPlot, trueCluster = \"leiden_cluster\", useCluster = \"new\") #> [1] -0.0003310172  # Now assume we got existing base line annotation only for \"stim\" dataset nStim <- ncol(dataset(pbmcPlot, \"stim\")) stimTrueLabel <- factor(fake[1:nStim]) # Insert into cellMeta cellMeta(pbmcPlot, \"stim_true_label\", useDatasets = \"stim\") <- stimTrueLabel # Assume \"leiden_cluster\" is the clustering result we got and need to be # evaluated calcARI(pbmcPlot, trueCluster = \"stim_true_label\",         useCluster = \"leiden_cluster\", useDatasets = \"stim\") #> [1] 0.0003172964"},{"path":"/reference/calcAgreement.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate agreement metric after integration — calcAgreement","title":"Calculate agreement metric after integration — calcAgreement","text":"metric quantifies much factorization alignment distorts geometry original datasets. greater agreement, less distortion geometry . calculated performing dimensionality reduction original quantile aligned (just factorized) datasets, measuring similarity k nearest neighbors cell original aligned datasets. Jaccard index used quantify similarity, final metric averages across cells. Note datasets, greater chosen nNeighbor, greater agreement general. Although agreement can theoretically approach 1, practice usually higher 0.2-0.3.","code":""},{"path":"/reference/calcAgreement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate agreement metric after integration — calcAgreement","text":"","code":"calcAgreement(   object,   ndims = 40,   nNeighbors = 15,   useRaw = FALSE,   byDataset = FALSE,   seed = 1,   dr.method = NULL,   k = nNeighbors,   use.aligned = NULL,   rand.seed = seed,   by.dataset = byDataset )"},{"path":"/reference/calcAgreement.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate agreement metric after integration — calcAgreement","text":"object liger object. call quantile_norm calling. ndims Number factors produce NMF. Default 40. nNeighbors Number nearest neighbors use calculating Jaccard index. Default 15. useRaw Whether evaluate just factorized \\(H\\) matrices instead using quantile aligned \\(H.norm\\) matrix. Default FALSE uses aligned matrix. byDataset Whether return agreement calculated dataset instead average datasets. Default FALSE. seed Random seed allow reproducible results. Default 1. dr.method [defunct] longer support methods just NMF. k, rand.seed, .dataset [Deprecated] See Usage replacement. use.aligned [defunct] Use useRaw instead.","code":""},{"path":"/reference/calcAgreement.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate agreement metric after integration — calcAgreement","text":"numeric vector agreement metric. single value byDataset = FALSE dataset value otherwise.","code":""},{"path":"/reference/calcAgreement.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate agreement metric after integration — calcAgreement","text":"","code":"pbmc <- pbmc %>%   normalize %>%   selectGenes %>%   scaleNotCenter %>%   runINMF %>%   quantileNorm #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  calcAgreement(pbmc) #> [1] 0.3723238"},{"path":"/reference/calcAlignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate alignment metric after integration — calcAlignment","title":"Calculate alignment metric after integration — calcAlignment","text":"metric quantifies well-aligned two datasets . randomly downsample datasets many cells smallest one. construct nearest-neighbor graph calculate cell many neighbors dataset. average across cells compare expected value perfectly mixed datasets, scale value 0 1. Note practice, alignment can greater 1 occasionally.","code":""},{"path":"/reference/calcAlignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate alignment metric after integration — calcAlignment","text":"","code":"calcAlignment(   object,   clustersUse = NULL,   clusterVar = NULL,   nNeighbors = NULL,   cellIdx = NULL,   cellComp = NULL,   resultBy = c(\"all\", \"dataset\", \"cell\"),   seed = 1,   k = nNeighbors,   rand.seed = seed,   cells.use = cellIdx,   cells.comp = cellComp,   clusters.use = clustersUse,   by.cell = NULL,   by.dataset = NULL )"},{"path":"/reference/calcAlignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate alignment metric after integration — calcAlignment","text":"object liger object, quantileNorm already run. clustersUse clusters consider calculating alignment. vector existing levels clusterVar. Default NULL. See Details. clusterVar name one variable cellMeta(object). Default NULL uses default clusters. nNeighbors Number neighbors use calculating alignment. Default NULL uses codefloor(0.01 * ncol(object)), lower bound 10 cases except total number sampled cells less 10. cellIdx, cellComp Character, logical numeric index can subscribe cells. Default NULL. See Details. resultBy Select \"\", \"dataset\" \"cell\". level mean alignment calculated. Default \"\". seed Random seed allow reproducible results. Default 1. k, rand.seed, cells.use, cells.comp, clusters.use [Deprecated] Please see Usage replacement. .cell, .dataset [Defunct] Use resultBy instead.","code":""},{"path":"/reference/calcAlignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate alignment metric after integration — calcAlignment","text":"alignment metric.","code":""},{"path":"/reference/calcAlignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate alignment metric after integration — calcAlignment","text":"\\(\\bar{x}\\) average number neighbors belonging cells' dataset, \\(N\\) number datasets, \\(k\\) number neighbors KNN graph. $$1 - \\frac{\\bar{x} - \\frac{k}{N}}{k - \\frac{k}{N}}$$ selection cells measured can done various way represent different scenarios: default, cells considered alignment across datasets calculated. Select clustersUse clusterVar use cells clusters interests. measures alignment across covered datasets within specified clusters. Specify cellIdx flexible selection. measures alignment across covered datasets within specified cells. none-NULL cellIdx privileges clustersUse. Specify cellIdx cellComp time, original dataset source ignored cells specified argument regarded dataset. measures alignment cells specified two arguments. cellComp can contain cells already specified cellIdx.","code":""},{"path":"/reference/calcAlignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate alignment metric after integration — calcAlignment","text":"","code":"pbmc <- pbmc %>%   normalize %>%   selectGenes %>%   scaleNotCenter %>%   runINMF %>%   quantileNorm #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  calcAlignment(pbmc) #> [1] 0.8996667"},{"path":"/reference/calcDatasetSpecificity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a dataset-specificity score for each factor — calcDatasetSpecificity","title":"Calculate a dataset-specificity score for each factor — calcDatasetSpecificity","text":"score represents relative magnitude dataset-specific components factor's gene loadings compared shared components two datasets. First, dataset calculate norm sum factor's shared loadings (\\(W\\)) dataset-specific loadings (\\(V\\)). determine ratio two values subtract 1... TODO: finish description.","code":""},{"path":"/reference/calcDatasetSpecificity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a dataset-specificity score for each factor — calcDatasetSpecificity","text":"","code":"calcDatasetSpecificity(   object,   dataset1,   dataset2,   doPlot = FALSE,   do.plot = doPlot )"},{"path":"/reference/calcDatasetSpecificity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a dataset-specificity score for each factor — calcDatasetSpecificity","text":"object liger object factorization results. dataset1 Name first dataset. Required. dataset2 Name second dataset. Required. doPlot Logical. Whether display barplot dataset specificity scores (factor). Default FALSE. .plot Deprecated. Use doPlot instead.","code":""},{"path":"/reference/calcDatasetSpecificity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a dataset-specificity score for each factor — calcDatasetSpecificity","text":"List containing three elements. pct1 Vector norm metagene factor dataset1. pct2 Vector norm metagene factor dataset2. pctSpec Vector dataset specificity scores.","code":""},{"path":"/reference/calcPurity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate purity by comparing two cluster labeling variables — calcPurity","title":"Calculate purity by comparing two cluster labeling variables — calcPurity","text":"function aims calculating purity clustering result obtained LIGER external clustering (existing \"true\" annotation). Purity can sometimes useful metric clustering tested contains subgroups clusters true clusters. Purity ranges 0 1, score 1 representing pure, accurate clustering. true clustering annotation must specified base line. suggest setting object cellMeta can easily used many visualization evaluation functions. purity can calculated specified datasets, since true annotation might available datasets. Evaluation one datasets can done specifying useDatasets. useDatasets specified, argument checking trueCluster useCluster enforced match cells specified datasets.","code":""},{"path":"/reference/calcPurity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate purity by comparing two cluster labeling variables — calcPurity","text":"","code":"calcPurity(   object,   trueCluster,   useCluster = NULL,   useDatasets = NULL,   verbose = getOption(\"ligerVerbose\", TRUE),   classes.compare = trueCluster )"},{"path":"/reference/calcPurity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate purity by comparing two cluster labeling variables — calcPurity","text":"object liger object, clustering result present cellMeta. trueCluster Either name one variable cellMeta(object) factor object annotation matches cells considered. useCluster name one variable cellMeta(object). Default NULL uses default clusters. useDatasets character vector names, numeric logical vector index datasets considered purity calculation. Default NULL uses datasets. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. classes.compare [Deprecated/Renamed]. Use trueCluster instead.","code":""},{"path":"/reference/calcPurity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate purity by comparing two cluster labeling variables — calcPurity","text":"numeric scalar, purity clustering result indicated useCluster compared trueCluster.","code":""},{"path":"/reference/calcPurity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate purity by comparing two cluster labeling variables — calcPurity","text":"","code":"# Assume the true cluster in `pbmcPlot` is \"leiden_cluster\" # generate fake new labeling fake <- sample(1:7, ncol(pbmcPlot), replace = TRUE) # Insert into cellMeta pbmcPlot$new <- factor(fake) calcPurity(pbmcPlot, trueCluster = \"leiden_cluster\", useCluster = \"new\") #> [1] 0.2466667  # Now assume we got existing base line annotation only for \"stim\" dataset nStim <- ncol(dataset(pbmcPlot, \"stim\")) stimTrueLabel <- factor(fake[1:nStim]) # Insert into cellMeta cellMeta(pbmcPlot, \"stim_true_label\", useDatasets = \"stim\") <- stimTrueLabel # Assume \"leiden_cluster\" is the clustering result we got and need to be # evaluated calcPurity(pbmcPlot, trueCluster = \"stim_true_label\",            useCluster = \"leiden_cluster\", useDatasets = \"stim\") #> [1] 0.1016667"},{"path":"/reference/closeAllH5.html","id":null,"dir":"Reference","previous_headings":"","what":"Close all links (to HDF5 files) of a liger object — closeAllH5","title":"Close all links (to HDF5 files) of a liger object — closeAllH5","text":"need interact data embedded HDF5 files currect R session, HDF5 files closed order available processes.","code":""},{"path":"/reference/closeAllH5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Close all links (to HDF5 files) of a liger object — closeAllH5","text":"","code":"closeAllH5(object)"},{"path":"/reference/closeAllH5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Close all links (to HDF5 files) of a liger object — closeAllH5","text":"object liger object.","code":""},{"path":"/reference/closeAllH5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Close all links (to HDF5 files) of a liger object — closeAllH5","text":"object links closed.","code":""},{"path":"/reference/commandDiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Check difference of two liger command — commandDiff","title":"Check difference of two liger command — commandDiff","text":"Check difference two liger command","code":""},{"path":"/reference/commandDiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check difference of two liger command — commandDiff","text":"","code":"commandDiff(object, cmd1, cmd2)"},{"path":"/reference/commandDiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check difference of two liger command — commandDiff","text":"object liger object cmd1, cmd2 Exact string command labels. Available options viewed running commands(object).","code":""},{"path":"/reference/commandDiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check difference of two liger command — commandDiff","text":"difference found, character vector summarizing differences","code":""},{"path":"/reference/commandDiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check difference of two liger command — commandDiff","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- normalize(pbmc, log = TRUE, scaleFactor = 1e4) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  cmds <- commands(pbmc) commandDiff(pbmc, cmds[1], cmds[2]) #> [1] \"Argument not found in `x`: log\"         #> [2] \"Argument not found in `x`: scaleFactor\""},{"path":"/reference/convertOldLiger.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert old liger object to latest version — convertOldLiger","title":"Convert old liger object to latest version — convertOldLiger","text":"Convert old liger object latest version","code":""},{"path":"/reference/convertOldLiger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert old liger object to latest version — convertOldLiger","text":"","code":"convertOldLiger(   object,   dimredName,   clusterName = \"clusters\",   h5FilePath = NULL )"},{"path":"/reference/convertOldLiger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert old liger object to latest version — convertOldLiger","text":"object liger object rliger version <1.99.0 dimredName name variable cellMeta slot store dimensionality reduction matrix, originally located tsne.coords slot. Default \"tsne.coords\". clusterName name variable cellMeta slot store clustering assignment, originally located clusters slot. Default \"clusters\". h5FilePath Named list, specify path H5 file dataset location changed. Default NULL looks file paths stored object.","code":""},{"path":"/reference/convertOldLiger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert old liger object to latest version — convertOldLiger","text":"","code":"if (FALSE) { # Suppose you have a liger object of old version (<1.99.0) newLig <- convertOldLiger(oldLig) }"},{"path":"/reference/coordinate.html","id":null,"dir":"Reference","previous_headings":"","what":"Access ligerSpatialDataset coordinate data — coordinate","title":"Access ligerSpatialDataset coordinate data — coordinate","text":"Similar default ligerDataset data accessed.","code":""},{"path":"/reference/coordinate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access ligerSpatialDataset coordinate data — coordinate","text":"","code":"coordinate(x, dataset)  coordinate(x, dataset, check = TRUE) <- value  # S4 method for liger,character coordinate(x, dataset)  # S4 method for liger,character coordinate(x, dataset, check = TRUE) <- value  # S4 method for ligerSpatialDataset,missing coordinate(x, dataset = NULL)  # S4 method for ligerSpatialDataset,missing coordinate(x, dataset = NULL, check = TRUE) <- value"},{"path":"/reference/coordinate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access ligerSpatialDataset coordinate data — coordinate","text":"x ligerSpatialDataset object liger object. dataset Name numeric index spatial dataset. check Logical, whether perform object validity check setting new value. value matrix.","code":""},{"path":"/reference/coordinate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access ligerSpatialDataset coordinate data — coordinate","text":"retrieved coordinate matrix updated x object.","code":""},{"path":"/reference/createH5LigerDataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Create on-disk ligerDataset Object — createH5LigerDataset","title":"Create on-disk ligerDataset Object — createH5LigerDataset","text":"Create -disk ligerDataset Object","code":""},{"path":"/reference/createH5LigerDataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create on-disk ligerDataset Object — createH5LigerDataset","text":"","code":"createH5LigerDataset(   h5file,   formatType = \"10X\",   rawData = NULL,   normData = NULL,   scaleData = NULL,   barcodesName = NULL,   genesName = NULL,   indicesName = NULL,   indptrName = NULL,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   featureMeta = NULL,   ... )"},{"path":"/reference/createH5LigerDataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create on-disk ligerDataset Object — createH5LigerDataset","text":"h5file Filename H5 file formatType Select preset H5 file structure. Default \"10X\". Current available options \"10X\" \"AnnData\". rawData, indicesName, indptrName path H5 file raw sparse matrix data. three types data stands x, , p slots dgCMatrix-class object. Default NULL uses formatType preset. normData path H5 file \"x\" vector normalized sparse matrix. Default NULL. scaleData path H5 file dense 2D scaled matrix. Default NULL. genesName, barcodesName path H5 file gene names cell barcodes. Default NULL uses formatType preset. modal Name modality dataset. Currently options \"default\", \"rna\", \"atac\", \"spatial\" \"meth\" supported. Default \"default\". featureMeta Data frame feature metadata. Default NULL. ... Additional slot data. See ligerDataset detail. Given values directly placed corresponding slots.","code":""},{"path":"/reference/createLiger.html","id":null,"dir":"Reference","previous_headings":"","what":"Create liger object — createLiger","title":"Create liger object — createLiger","text":"function allows creating liger object multiple datasets various forms (See rawData).","code":""},{"path":"/reference/createLiger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create liger object — createLiger","text":"","code":"createLiger(   rawData,   modal = NULL,   cellMeta = NULL,   removeMissing = TRUE,   addPrefix = \"auto\",   formatType = \"10X\",   dataName = NULL,   indicesName = NULL,   indptrName = NULL,   genesName = NULL,   barcodesName = NULL,   newH5 = TRUE,   verbose = getOption(\"ligerVerbose\", TRUE),   ...,   remove.missing = removeMissing,   format.type = formatType,   data.name = dataName,   indices.name = indicesName,   indptr.name = indptrName,   genes.name = genesName,   barcodes.name = barcodesName )"},{"path":"/reference/createLiger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create liger object — createLiger","text":"rawData Named list datasets. Required. Elements allowed include matrix, Seurat object, SingleCellExperiment object, AnnData object, ligerDataset object filename HDF5 file. See detail HDF5 reading. modal Character vector modality setting. Use one string datasets, number strings number datasets. Currently options \"default\", \"rna\", \"atac\", \"spatial\" \"meth\" supported. cellMeta data.frame metadata single-cell level. Default NULL. removeMissing Logical. Whether remove cells counts features expressed cells dataset. Default TRUE. addPrefix Logical. Whether add \"<dataset name>_\" prefix cell identifiers (e.g. barcodes) avoid duplicates multiple libraries ( common 10X data). Default \"auto\" detects matrix columns already exact prefix . Logical value forces action. formatType Select preset H5 file structure. Current available options \"10X\" \"AnnData\". Can either single specification datasets character vector match dataset. dataName, indicesName, indptrName path H5 file raw sparse matrix data. three types data stands x, , p slots dgCMatrix-class object. Default NULL uses formatType preset. genesName, barcodesName path H5 file gene names cell barcodes. Default NULL uses formatType preset. newH5 using HDF5 based data subsets created removing missing cells/features, whether create new HDF5 files subset. Default TRUE. FALSE, data subset memory can dangerous large scale analysis. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. ... Additional slot values directly placed object. remove.missing, format.type, data.name, indices.name, indptr.name, genes.name, barcodes.name Deprecated. See Usage section replacement.","code":""},{"path":[]},{"path":"/reference/createLiger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create liger object — createLiger","text":"","code":"# Create from raw count matrices ctrl.raw <- rawData(pbmc, \"ctrl\") stim.raw <- rawData(pbmc, \"stim\") pbmc1 <- createLiger(list(ctrl = ctrl.raw, stim = stim.raw)) #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>   # Create from H5 files h5Path <- system.file(\"extdata/ctrl.h5\", package = \"rliger\") print(h5Path) #> [1] \"/private/var/folders/k9/nwtr_c_57kd43cmbtz82ywlr0000gn/T/RtmpLAVIoJ/temp_libpath1279e50325aa8/rliger/extdata/ctrl.h5\" lig <- createLiger(list(ctrl = h5Path)) #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> ℹ calculating QC for dataset \"ctrl\" #>  #> ✔ calculating QC for dataset \"ctrl\" ... done #>   # Create from other container object ctrl.seu <- SeuratObject::CreateSeuratObject(ctrl.raw) stim.seu <- SeuratObject::CreateSeuratObject(stim.raw) pbmc2 <- createLiger(list(ctrl = ctrl.seu, stim = stim.seu)) #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>"},{"path":"/reference/createLigerDataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Create in-memory ligerDataset object — createLigerDataset","title":"Create in-memory ligerDataset object — createLigerDataset","text":"Create -memory ligerDataset object","code":""},{"path":"/reference/createLigerDataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create in-memory ligerDataset object — createLigerDataset","text":"","code":"createLigerDataset(   rawData = NULL,   modal = c(\"default\", \"rna\", \"atac\", \"spatial\", \"meth\"),   normData = NULL,   scaleData = NULL,   featureMeta = NULL,   ... )"},{"path":"/reference/createLigerDataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create in-memory ligerDataset object — createLigerDataset","text":"rawData, normData, scaleData dgCMatrix-class object raw normalized expression count dense matrix scaled variable gene expression, respectively. Default NULL three lease one specified. modal Name modality dataset. Currently options \"default\", \"rna\", \"atac\", \"spatial\" \"meth\" supported. Default \"default\". featureMeta Data frame feature metadata. Default NULL. ... Additional slot data. See ligerDataset detail. Given values directly placed corresponding slots.","code":""},{"path":[]},{"path":"/reference/createLigerDataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create in-memory ligerDataset object — createLigerDataset","text":"","code":"ctrl.raw <- rawData(pbmc, \"ctrl\") ctrl.ld <- createLigerDataset(ctrl.raw)"},{"path":"/reference/dot-complexHeatmapDotPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate dot plot from input matrix with ComplexHeatmap — .complexHeatmapDotPlot","title":"Generate dot plot from input matrix with ComplexHeatmap — .complexHeatmapDotPlot","text":"Generate dot plot input matrix ComplexHeatmap","code":""},{"path":"/reference/dot-complexHeatmapDotPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate dot plot from input matrix with ComplexHeatmap — .complexHeatmapDotPlot","text":"","code":".complexHeatmapDotPlot(   colorMat,   sizeMat,   featureAnnDF = NULL,   cellSplitVar = NULL,   cellLabels = NULL,   maxDotSize = 4,   clusterFeature = FALSE,   clusterCell = FALSE,   legendColorTitle = \"Matrix Value\",   legendSizeTitle = \"Fraction Value\",   transpose = FALSE,   baseSize = 8,   cellTextSize = NULL,   featureTextSize = NULL,   cellTitleSize = NULL,   featureTitleSize = NULL,   legendTextSize = NULL,   legendTitleSize = NULL,   featureGrpRot = 0,   viridisOption = \"C\",   viridisDirection = -1,   ... )"},{"path":"/reference/dot-complexHeatmapDotPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate dot plot from input matrix with ComplexHeatmap — .complexHeatmapDotPlot","text":"colorMat, sizeMat Matrix size. Values colorMat visualized color values sizeMat reflected dot size. featureAnnDF Data frame features containing feature names grouping labels. cellSplitVar Split cell orientation (default columns) variable. cellLabels Label shown cell orientation. maxDotSize maximum dot size. Default 4. clusterFeature, clusterCell Whether feature/cell orientation (default rows/column, respectively) clustered. Default FALSE. legendColorTitle, legendSizeTitle title color bar dot size legends, repectively. Default see \"Matrix Value\" \"Fraction Value\". transpose Logical, whether rotate dot plot orientation. .e. rows cell aggregation columns features. Default FALSE. baseSize One-parameter control text sizes. Individual text element sizes can controlled size arguments. \"Title\" sizes 2 points larger \"text\" sizes controlled . Default 8. cellTextSize, featureTextSize, legendTextSize Size cell labels, feature label legend text. Default NULL controls baseSize. cellTitleSize, featureTitleSize, legendTitleSize Size titles cell feature orientation legend title. Default NULL controls baseSize + 2. featureGrpRot Number degree rotate feature grouping label. Default 0. viridisOption, viridisDirection See argument option direction viridis. Default \"\" -1. ... Additional arguments passed Heatmap.","code":""},{"path":"/reference/dot-complexHeatmapDotPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate dot plot from input matrix with ComplexHeatmap — .complexHeatmapDotPlot","text":"HeatmapList object.","code":""},{"path":"/reference/dot-ggCellViolin.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce single violin plot with data frame passed from upstream — .ggCellViolin","title":"Produce single violin plot with data frame passed from upstream — .ggCellViolin","text":"Produce single violin plot data frame passed upstream","code":""},{"path":"/reference/dot-ggCellViolin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce single violin plot with data frame passed from upstream — .ggCellViolin","text":"","code":".ggCellViolin(   plotDF,   y,   groupBy = NULL,   colorBy = NULL,   violin = TRUE,   violinAlpha = 0.8,   violinWidth = 0.9,   box = FALSE,   boxAlpha = 0.6,   boxWidth = 0.4,   dot = FALSE,   dotColor = \"black\",   dotSize = getOption(\"ligerDotSize\"),   raster = NULL,   seed = 1,   ... )"},{"path":"/reference/dot-ggCellViolin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce single violin plot with data frame passed from upstream — .ggCellViolin","text":"plotDF Data frame like object (fortifiable) contains necessary information make plot. y, groupBy, colorBy See plotCellViolin. violin, box, dot Logical, whether add violin plot, box plot dot (scatter) plot, respectively. Layers added order dot, violin, violin top surface. default, violin plot generated. violinAlpha, boxAlpha Numeric, controls transparency layers. Default 0.8, 0.6, respectively. violinWidth, boxWidth Numeric, controls width violin/box bounding box. Default 0.9 0.4. dotColor, dotSize Numeric, globally controls appearance dots. Default \"black\" getOption(\"ligerDotSize\") (1). raster Logical, whether rasterize dot plot. Default NULL automatically rasterizes dot plot number total cells plotted exceeds 100,000. seed Random seed reproducibility. Default 1. ... theme setting arguments passed .ggplotLigerTheme.","code":""},{"path":"/reference/dot-ggCellViolin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produce single violin plot with data frame passed from upstream — .ggCellViolin","text":"ggplot object default. plotly = TRUE, returns plotly (htmlwidget) object.","code":""},{"path":"/reference/dot-ggScatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce single scatter plot with data frame passed from upstream — .ggScatter","title":"Produce single scatter plot with data frame passed from upstream — .ggScatter","text":"Produce single scatter plot data frame passed upstream","code":""},{"path":"/reference/dot-ggScatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce single scatter plot with data frame passed from upstream — .ggScatter","text":"","code":".ggScatter(   plotDF,   x,   y,   colorBy = NULL,   shapeBy = NULL,   dotOrder = c(\"shuffle\", \"ascending\", \"descending\"),   dotSize = getOption(\"ligerDotSize\"),   dotAlpha = 0.9,   trimHigh = NULL,   trimLow = NULL,   zeroAsNA = TRUE,   raster = NULL,   labelBy = colorBy,   labelText = TRUE,   labelTextSize = 4,   seed = 1,   ... )"},{"path":"/reference/dot-ggScatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce single scatter plot with data frame passed from upstream — .ggScatter","text":"plotDF Data frame like object (fortifiable) contains necessary information make plot. x, y Available variable name cellMeta slot look dot coordinates. See details. colorBy, shapeBy See plotDimRed. dotOrder Controls order dot added plot. Choose \"shuffle\", \"ascending\", \"descending\". Default \"shuffle\", useful coloring categories overlaps (e.g. \"dataset\"), \"ascending\" can useful coloring continuous variable (e.g. gene expression) high values needs highlight. NULL use default order. dotSize, dotAlpha Numeric, controls size transparency dots. Default getOption(\"ligerDotSize\") (1) 0.9. trimHigh, trimLow Numeric, limit largest smallest value continuous colorBy variable. Default NULL. zeroAsNA Logical, whether set zero values continuous colorBy variable NA color value. raster Logical, whether rasterize plot. Default NULL automatically rasterize plot number total cells plotted exceeds 100,000. labelBy variable name available plotDF. variable categorical (factor), label position median coordinates dots within group. Unique labeling character vector dot also acceptable. Default colorBy. labelText Logical, whether show text label median position categorical group specified colorBy. Default TRUE. work continuous coloring specified. labelTextSize Numeric, controls size label size labelText = TRUE. Default 4. seed Random seed reproducibility. Default 1. ... theme setting arguments passed .ggplotLigerTheme.","code":""},{"path":"/reference/dot-ggScatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produce single scatter plot with data frame passed from upstream — .ggScatter","text":"ggplot object default. plotly = TRUE, returns plotly (htmlwidget) object.","code":""},{"path":"/reference/dot-ggScatter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Produce single scatter plot with data frame passed from upstream — .ggScatter","text":"package \"ggrepel\" installed can help adding tidier text labels scatter plot.","code":""},{"path":"/reference/dot-ggplotLigerTheme.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic ggplot theme setting for rliger package — .ggplotLigerTheme","title":"Generic ggplot theme setting for rliger package — .ggplotLigerTheme","text":"Controls content size peripheral texts.","code":""},{"path":"/reference/dot-ggplotLigerTheme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic ggplot theme setting for rliger package — .ggplotLigerTheme","text":"","code":".ggplotLigerTheme(   plot,   title = NULL,   subtitle = NULL,   xlab = TRUE,   ylab = TRUE,   legendColorTitle = NULL,   legendFillTitle = NULL,   legendShapeTitle = NULL,   legendSizeTitle = NULL,   showLegend = TRUE,   legendPosition = \"right\",   baseSize = getOption(\"ligerBaseSize\"),   titleSize = NULL,   subtitleSize = NULL,   xTextSize = NULL,   xFacetSize = NULL,   xTitleSize = NULL,   yTextSize = NULL,   yFacetSize = NULL,   yTitleSize = NULL,   legendTextSize = NULL,   legendTitleSize = NULL,   legendDotSize = 4,   panelBorder = FALSE,   legendNRow = NULL,   legendNCol = NULL,   colorLabels = NULL,   colorValues = NULL,   colorPalette = \"magma\",   colorDirection = -1,   naColor = \"#DEDEDE\",   colorLow = NULL,   colorMid = NULL,   colorHigh = NULL,   colorMidPoint = NULL,   plotly = FALSE )"},{"path":"/reference/dot-ggplotLigerTheme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic ggplot theme setting for rliger package — .ggplotLigerTheme","text":"plot ggplot object passed wrapper plotting functions title, subtitle, xlab, ylab Main title, subtitle X/Y axis title text. default, main title subtitle set, X/Y axis title names variables used plotting. Use NULL hide elements. TRUE xlab ylab shows default values. legendColorTitle, legendFillTitle, legendShapeTitle, legendSizeTitle Set alternative title text legend aes color, fill, shape size, respectively. Default NULL shows original variable name. showLegend Whether show legend. Default TRUE. legendPosition Text indicating place legend. Choose \"top\", \"bottom\", \"left\" \"right\". Default \"right\". baseSize One-parameter control text sizes. Individual text element sizes can controlled size arguments. \"Title\" sizes 2 points larger \"text\" sizes controlled . titleSize, xTitleSize, yTitleSize, legendTitleSize Size main title, axis titles legend title. Default NULL controls baseSize + 2. subtitleSize, xTextSize, yTextSize, legendTextSize Size subtitle text, axis texts legend text. Default NULL controls baseSize. xFacetSize, yFacetSize Size facet label text. Default NULL controls baseSize - 2. legendDotSize Allow dots legend region large enough see colors/shapes clearly. Default 4. panelBorder Whether show rectangle border panel instead using ggplot classic bottom left axis lines. Default FALSE. legendNRow, legendNCol Integer, many categories one variable, arranges number rows columns. Default NULL, automatically split ceiling(levels(variable)/10) columns. colorLabels, colorValues vector many values number categories categorical coloring aesthetics. Labels shown text values color code. passed scale_color_manual. Default uses internal selected palette <= 26 colors needed, ggplot hues otherwise, plot original labels (levels factor). colorPalette continuous coloring, index palette name select available options ggplot scale_brewer viridis. Default \"magma\". colorDirection Choose 1 -1. Applied colorPalette Viridis options. Default -1 use darker color higher value, 1 reverses direction. naColor color code NA values. Default \"#DEDEDE\". scale_colour_gradient2. Default NULL. colorLow, colorMid, colorHigh, colorMidPoint four must specified customize palette plotly Whether use plotly enable web based interactive browsing plot. Requires installation package \"plotly\". Default FALSE.","code":""},{"path":"/reference/dot-ggplotLigerTheme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic ggplot theme setting for rliger package — .ggplotLigerTheme","text":"Updated ggplot object default. plotly = TRUE, returns plotly (htmlwidget) object.","code":""},{"path":"/reference/dot-plotHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"General heatmap plotting with prepared matrix and data.frames — .plotHeatmap","title":"General heatmap plotting with prepared matrix and data.frames — .plotHeatmap","text":"exported function. documentation just serves manual extra arguments users can use generating heatmaps plotGeneHeatmap plotFactorHeatmap. Note following arguments pre-occupied upstream wrappers users include function call: dataMatrix, dataName, cellDF, featureDF, cellSplitVar, featureSplitVar. following arguments Heatmap occupied function, users include function call well: matrix, name, col, heatmap_legend_param, top_annotation, column_title_gp, column_names_gp, show_column_names, column_split, column_gap, left_annotation, row_title_gp, row_names_gp, show_row_names, row_split, row_gap.","code":""},{"path":"/reference/dot-plotHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General heatmap plotting with prepared matrix and data.frames — .plotHeatmap","text":"","code":".plotHeatmap(   dataMatrix,   dataName = \"Value\",   cellDF = NULL,   featureDF = NULL,   transpose = FALSE,   cellSplitVar = NULL,   featureSplitVar = NULL,   dataScaleFunc = NULL,   showCellLabel = FALSE,   showCellLegend = TRUE,   showFeatureLabel = TRUE,   showFeatureLegend = TRUE,   cellAnnColList = NULL,   featureAnnColList = NULL,   scale = FALSE,   trim = c(-2, 2),   baseSize = 8,   cellTextSize = NULL,   featureTextSize = NULL,   cellTitleSize = NULL,   featureTitleSize = NULL,   legendTextSize = NULL,   legendTitleSize = NULL,   viridisOption = \"A\",   viridisDirection = -1,   RColorBrewerOption = \"RdBu\",   ... )"},{"path":"/reference/dot-plotHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General heatmap plotting with prepared matrix and data.frames — .plotHeatmap","text":"dataMatrix Matrix object features/factors rows cells columns. dataName Text heatmap color bar title. Default Value. cellDF data.frame object. Number rows must match number columns dataMatrix. featureDF data.frame object. Number columns must match number rows dataMatrix. transpose Logical, whether \"rotate\" heatmap 90 degrees cell information displayed row. Default FALSE. cellSplitVar, featureSplitVar Subset columns cellDF featureDF, respectively. dataScaleFunc function object, applied dataMatrix. showCellLabel, showFeatureLabel Logical, whether show cell barcodes, gene symbols factor names. Default TRUE gene/factors FALSE cells. showCellLegend, showFeatureLegend Logical, whether show cell feature legends. Default TRUE. Can scalar overall control vector matching given annotation variable. cellAnnColList, featureAnnColList List object, element named vector R-interpretable color code. names list elements used matching annotation variable names. names colors vectors used matching levels variable (factor object, categorical). Default NULL generates ggplot-flavor categorical colors. scale Logical, whether take z-score scale center gene expression. Applied dataScaleFunc. Default FALSE. trim Numeric vector two values. Limit z-score value range scale = TRUE. Default c(-2, 2). baseSize One-parameter control text sizes. Individual text element sizes can controlled size arguments. \"Title\" sizes 2 points larger \"text\" sizes controlled . cellTextSize, featureTextSize, legendTextSize Size cell barcode labels, gene/factor labels, legend values. Default NULL. cellTitleSize, featureTitleSize, legendTitleSize Size titles cell slices, gene/factor slices, legends. Default NULL. viridisOption, viridisDirection See argument option direction viridis. Default \"\" -1. RColorBrewerOption scale = TRUE, heatmap color mapped brewer.pal. passed name. Default \"RdBu\". ... Additional arguments passed Heatmap.","code":""},{"path":"/reference/dot-plotHeatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General heatmap plotting with prepared matrix and data.frames — .plotHeatmap","text":"HeatmapList-class object","code":""},{"path":"/reference/downsample.html","id":null,"dir":"Reference","previous_headings":"","what":"Downsample datasets — downsample","title":"Downsample datasets — downsample","text":"function mainly aims downsampling datasets size suitable plotting expensive -memmory calculation. Users can balance sample size categories interests balance. Multi-variable specification balance supported, maxCells cells sampled combination categories variables. example, two datasets presented three clusters labeled across , \\(2 \\times 3 \\times maxCells\\) cells selected. Note \"dataset\" automatically added one variable balancing downsampling. However, users want balance downsampling solely basing dataset origin, users explicitly set balance = \"dataset\".","code":""},{"path":"/reference/downsample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Downsample datasets — downsample","text":"","code":"downsample(   object,   balance = NULL,   maxCells = 1000,   useDatasets = NULL,   seed = 1,   returnIndex = FALSE,   ... )"},{"path":"/reference/downsample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Downsample datasets — downsample","text":"object liger object balance Character vector categorical variable names cellMeta slot, subsample maxCells cells combination specified variables. Default NULL samples maxCells cells whole object. maxCells Max number cells sample grouping based balance. useDatasets Index selection datasets include Default NULL using datasets. seed Random seed reproducibility. Default 1. returnIndex Logical, whether return numeric index can subset original object instead subset object. Default FALSE. ... Arguments passed subsetLiger, cellIdx occupied internal implementation.","code":""},{"path":"/reference/downsample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Downsample datasets — downsample","text":"default, subset liger  object. Alternatively returnIndex = TRUE, numeric vector used original object.","code":""},{"path":"/reference/downsample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Downsample datasets — downsample","text":"","code":"# Subsetting an object pbmc <- downsample(pbmc) #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>  # Creating a subsetting index sampleIdx <- downsample(pbmcPlot, balance = \"leiden_cluster\",                         maxCells = 10, returnIndex = TRUE) plotClusterDimRed(pbmcPlot, cellIdx = sampleIdx) #> ℹ Plotting feature \"leiden_cluster\" on 158 cells #> ✔ Plotting feature \"leiden_cluster\" on 158 cells ... done #>"},{"path":"/reference/exportInteractTrack.html","id":null,"dir":"Reference","previous_headings":"","what":"Export predicted gene-pair interaction — exportInteractTrack","title":"Export predicted gene-pair interaction — exportInteractTrack","text":"Export predicted gene-pair interactions calculated upstream function linkGenesAndPeaks Interact Track file compatible UCSC Genome Browser.","code":""},{"path":"/reference/exportInteractTrack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export predicted gene-pair interaction — exportInteractTrack","text":"","code":"exportInteractTrack(   corrMat,   pathToCoords,   useGenes = NULL,   outputPath = getwd() )"},{"path":"/reference/exportInteractTrack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export predicted gene-pair interaction — exportInteractTrack","text":"corrMat sparse matrix correlation peak names rows gene names columns. pathToCoords Path gene coordinates file. useGenes Character vector gene names exported. Default NULL uses genes available corrMat. outputPath Path filename output file stored. folder, file named \"Interact_Track.bed\" created. Default current working directory.","code":""},{"path":"/reference/exportInteractTrack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export predicted gene-pair interaction — exportInteractTrack","text":"return value. file located outputPath created.","code":""},{"path":"/reference/exportInteractTrack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export predicted gene-pair interaction — exportInteractTrack","text":"","code":"# \\donttest{ bmmc <- normalize(bmmc) #> ℹ Normalizing datasets \"rna\" #> ℹ Normalizing datasets \"atac\" #> ✔ Normalizing datasets \"atac\" ... done #>  #> ℹ Normalizing datasets \"rna\" #> ✔ Normalizing datasets \"rna\" ... done #>  bmmc <- selectGenes(bmmc) #> ℹ Selecting variable features for dataset \"rna\" #> ✔ ... 83 features selected out of 172 shared features. #> ℹ Selecting variable features for dataset \"atac\" #> ✔ ... 126 features selected out of 172 shared features. #> ✔ Finally 135 shared variable features are selected. bmmc <- scaleNotCenter(bmmc) #> ℹ Scaling dataset \"rna\" #> ✔ Scaling dataset \"rna\" ... done #>  #> ℹ Scaling dataset \"atac\" #> ✔ Scaling dataset \"atac\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     bmmc <- runINMF(bmmc)     bmmc <- quantileNorm(bmmc)     bmmc <- normalizePeak(bmmc)     bmmc <- imputeKNN(bmmc, reference = \"atac\", queries = \"rna\")     corr <- linkGenesAndPeaks(         bmmc, useDataset = \"rna\",         pathToCoords = system.file(\"extdata/hg19_genes.bed\", package = \"rliger\")     )     resultPath <- tempfile()     exportInteractTrack(         corrMat = corr,         pathToCoords = system.file(\"extdata/hg19_genes.bed\", package = \"rliger\"),         outputPath = resultPath     )     head(read.table(resultPath, skip = 1)) } #> ℹ Normalizing peak of dataset: \"atac\" #> ✔ Normalizing peak of dataset: \"atac\" ... done #>  #> ℹ Imputing 1 query dataset: \"rna\" #> ℹ from reference dataset: \"atac\" #> ℹ Normalizing peak of dataset: \"rna\" #> ✔ Normalizing peak of dataset: \"rna\" ... done #>  #> ℹ 172 genes to be tested against 995 peaks #> ℹ Calculating correlation for gene-peak pairs... #> ! Totally 141 selected genes do not have significant correlated peaks, out of #> 172 selected genes #> ✔ Result written at: /private/var/folders/k9/nwtr_c_57kd43cmbtz82ywlr0000gn/T/RtmpNcCFx3/file12c13257fe50b #>     V1        V2        V3                             V4 V5         V6 V7 V8 #> 1 chr1 155928566 155929066  LMNA/chr1:155928566-155929066  0  0.2997087  .  5 #> 2 chr1 220868226 220868726 MARC2/chr1:220868226-220868726  0  0.1840661  .  5 #> 3 chr2  20382204  20382704    SDC1/chr2:20382204-20382704  0  0.5781944  .  5 #> 4 chr2  20412152  20412652    SDC1/chr2:20412152-20412652  0  0.1810287  .  5 #> 5 chr2 232223879 232224379 ITM2C/chr2:232223879-232224379  0 -0.1559540  .  5 #> 6 chr3  52090371  52090871   STAB1/chr3:52090371-52090871  0  0.1717412  .  5 #>     V9       V10       V11 V12 V13  V14       V15       V16   V17 V18 #> 1 chr1 155928566 155928567   .   . chr1 156052368 156052369  LMNA   . #> 2 chr1 220868226 220868227   .   . chr1 220921675 220921676 MARC2   . #> 3 chr2  20382204  20382205   .   . chr2  20400557  20400558  SDC1   . #> 4 chr2  20412152  20412153   .   . chr2  20400557  20400558  SDC1   . #> 5 chr2 232223879 232223880   .   . chr2 231729620 231729621 ITM2C   . #> 6 chr3  52090371  52090372   .   . chr3  52529355  52529356 STAB1   . # }"},{"path":"/reference/getFactorMarkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Find shared and dataset-specific markers — getFactorMarkers","title":"Find shared and dataset-specific markers — getFactorMarkers","text":"Applies various filters genes shared (\\(W\\)) dataset-specific (\\(V\\)) components factorization, selecting load significantly factor (shared dataset-specific way).","code":""},{"path":"/reference/getFactorMarkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find shared and dataset-specific markers — getFactorMarkers","text":"","code":"getFactorMarkers(   object,   dataset1,   dataset2,   factorShareThresh = 10,   datasetSpecificity = NULL,   logFCThresh = 1,   pvalThresh = 0.05,   nGenes = 30,   printGenes = FALSE,   verbose = getOption(\"ligerVerbose\", TRUE),   factor.share.thresh = factorShareThresh,   dataset.specificity = datasetSpecificity,   log.fc.thresh = logFCThresh,   pval.thresh = pvalThresh,   num.genes = nGenes,   print.genes = printGenes )"},{"path":"/reference/getFactorMarkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find shared and dataset-specific markers — getFactorMarkers","text":"object liger object factorization results. dataset1 Name first dataset. Required. dataset2 Name second dataset. Required factorShareThresh Numeric. factors dataset specificity less equal threshold used. Default 10. datasetSpecificity Numeric vector. Pre-calculated dataset specificity available. Length match number factors available. Default NULL automatically calculates calcDatasetSpecificity. logFCThresh Numeric. Lower log-fold change threshold differential expression markers. Default 1. pvalThresh Numeric. Upper p-value threshold Wilcoxon rank test gene expression. Default 0.05. nGenes Integer. Max number genes report dataset. Default 30. printGenes Logical. Whether print ordered markers passing logFC, UMI frac thresholds, verbose = TRUE. Default FALSE. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. factor.share.thresh, dataset.specificity, log.fc.thresh, pval.thresh, num.genes, print.genes Deprecated. See Usage section replacement.","code":""},{"path":"/reference/getFactorMarkers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find shared and dataset-specific markers — getFactorMarkers","text":"list object consisting following entries: [value `dataset1`] data.frame dataset1-specific markers shared data.frame shared markers [value `dataset1`] data.frame dataset2-specific markers num_factors_V1 frequency table indicating number factors marker appears, dataset1 num_factors_V2 frequency table indicating number factors marker appears, dataset2","code":""},{"path":"/reference/getFactorMarkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find shared and dataset-specific markers — getFactorMarkers","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union result <- getFactorMarkers(pbmcPlot, dataset1 = \"ctrl\", dataset2 = \"stim\") #> ! Factor 7 did not appear as max in any cell in either dataset #>  print(class(result)) #> [1] \"list\" print(names(result)) #> [1] \"ctrl\"           \"shared\"         \"stim\"           \"num_factors_V1\" #> [5] \"num_factors_V2\" result$shared %>% group_by(factor_num) %>% top_n(2, logFC) #> # A tibble: 38 × 4 #> # Groups:   factor_num [19] #>    feature  factor_num logFC    pval #>    <chr>         <int> <dbl>   <dbl> #>  1 DUSP2             1  6.52 1       #>  2 NPM1              1  7.15 0.889   #>  3 ID3               2  3.42 0.161   #>  4 CD83              2  4.29 0.620   #>  5 IL1B              3  6.14 0.0377  #>  6 H2AFZ             3  5.98 0.0942  #>  7 S100A10           4 10.9  0.653   #>  8 S100A11           4  7.97 1       #>  9 MARCKSL1          5  2.94 0.0660  #> 10 IL8               5 10.9  0.00408 #> # ℹ 28 more rows"},{"path":"/reference/getProportionMito.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate proportion mitochondrial contribution — getProportionMito","title":"Calculate proportion mitochondrial contribution — getProportionMito","text":"Calculates proportion mitochondrial contribution based raw normalized data.","code":""},{"path":"/reference/getProportionMito.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate proportion mitochondrial contribution — getProportionMito","text":"","code":"getProportionMito(object, use.norm = FALSE, pattern = \"^mt-\")"},{"path":"/reference/getProportionMito.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate proportion mitochondrial contribution — getProportionMito","text":"object liger object. use.norm Deprecated Whether use cell normalized data calculating contribution. Default FALSE. pattern Regex pattern identifying mitochondrial genes. Default \"^mt-\" mouse.","code":""},{"path":"/reference/getProportionMito.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate proportion mitochondrial contribution — getProportionMito","text":"Named vector containing proportion mitochondrial contribution cell.","code":""},{"path":"/reference/getProportionMito.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate proportion mitochondrial contribution — getProportionMito","text":"getProportionMito deprecated runGeneralQC generally covers expands use case.","code":""},{"path":"/reference/getProportionMito.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate proportion mitochondrial contribution — getProportionMito","text":"","code":"# Example dataset does not contain MT genes, expected to see a message pbmc$mito <- getProportionMito(pbmc) #> Warning: `getProportionMito()` was deprecated in rliger 1.99.0. #> ℹ Please use `runGeneralQC()` instead. #> ! Zero proportion detected in all cells"},{"path":"/reference/importVignetteData.html","id":null,"dir":"Reference","previous_headings":"","what":"Import prepared dataset publically available — importPBMC","title":"Import prepared dataset publically available — importPBMC","text":"functions download example datasets subset public data. PBMC - Downsampled GSE96583, Kang et al, Nature Biotechnology, 2018. Contains two scRNAseq datasets. BMMC - Downsampled GSE139369, Granja et al, Nature Biotechnology, 2019. Contains two scRNAseq datasets one scATAC data. CGE - Downsampled GSE97179, Luo et al, Science, 2017. Contains one scRNAseq dataset one DNA methylation data.","code":""},{"path":"/reference/importVignetteData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import prepared dataset publically available — importPBMC","text":"","code":"importPBMC(   dir = getwd(),   overwrite = FALSE,   method = \"libcurl\",   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  importBMMC(   dir = getwd(),   overwrite = FALSE,   method = \"libcurl\",   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  importCGE(   dir = getwd(),   overwrite = FALSE,   method = \"libcurl\",   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/importVignetteData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import prepared dataset publically available — importPBMC","text":"dir Path download datasets. Default current working directory getwd(). overwrite Logical, file exists corresponding download location, whether re-download directly use file. Default FALSE. method method argument directly passed download.file. Using \"libcurl\" options might work depending platform. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. ... Additional arguments passed download.file","code":""},{"path":"/reference/importVignetteData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import prepared dataset publically available — importPBMC","text":"Constructed liger object QC performed missing data removed.","code":""},{"path":"/reference/importVignetteData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import prepared dataset publically available — importPBMC","text":"","code":"if (FALSE) { # interactive() # \\donttest{ pbmc <- importPBMC() bmmc <- importBMMC() cge <- importCGE() # } }"},{"path":"/reference/imputeKNN.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute the peak counts from gene expression data referring to an ATAC dataset\nafter integration — imputeKNN","title":"Impute the peak counts from gene expression data referring to an ATAC dataset\nafter integration — imputeKNN","text":"function designed creating peak data dataset gene expression. function uses quantile normalized cell factor loading find nearest neighbors cells queried dataset (without peak) cells reference dataset (peak). impute peak former basing weight. Therefore, reference dataset selected must \"atac\" modality setting.","code":""},{"path":"/reference/imputeKNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute the peak counts from gene expression data referring to an ATAC dataset\nafter integration — imputeKNN","text":"","code":"imputeKNN(   object,   reference,   queries = NULL,   nNeighbors = 20,   weight = TRUE,   norm = TRUE,   scale = FALSE,   verbose = getOption(\"ligerVerbose\", TRUE),   ...,   knn_k = nNeighbors )"},{"path":"/reference/imputeKNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute the peak counts from gene expression data referring to an ATAC dataset\nafter integration — imputeKNN","text":"object liger object aligned factor loading computed advance. reference Name dataset containing peak data impute query dataset(s). queries Names datasets augmented imputation. include reference. Default NULL uses datasets except reference. nNeighbors maximum number nearest neighbors search. Default 20. weight Logical. Whether use KNN distances weight matrix. Default FALSE. norm Logical. Whether normalize imputed data. Default TRUE. scale Logical. Whether scale center imputed data. Default TRUE. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. ... Optional arguments passed normalize norm = TRUE. knn_k Deprecated. See Usage section replacement.","code":""},{"path":"/reference/imputeKNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute the peak counts from gene expression data referring to an ATAC dataset\nafter integration — imputeKNN","text":"input object queried ligerDataset objects datasets slot replaced. datasets converted ligerATACDataset class additional slot rawPeak store imputed peak counts, normPeak normalized imputed peak counts norm = TRUE.","code":""},{"path":"/reference/imputeKNN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute the peak counts from gene expression data referring to an ATAC dataset\nafter integration — imputeKNN","text":"","code":"bmmc <- normalize(bmmc) #> ℹ Normalizing datasets \"rna\" #> ℹ Normalizing datasets \"atac\" #> ✔ Normalizing datasets \"atac\" ... done #>  #> ℹ Normalizing datasets \"rna\" #> ✔ Normalizing datasets \"rna\" ... done #>  bmmc <- selectGenes(bmmc, datasets.use = \"rna\") #> Warning: The `datasets.use` argument of `selectGenes.liger()` is deprecated as of rliger #> 1.99.0. #> ℹ Please use the `useDatasets` argument instead. #> ℹ The deprecated feature was likely used in the rliger package. #>   Please report the issue at <https://github.com/welch-lab/liger/issues>. #> ℹ Selecting variable features for dataset \"rna\" #> ✔ ... 83 features selected out of 172 shared features. #> ✔ Finally 83 shared variable features are selected. bmmc <- scaleNotCenter(bmmc) #> ℹ Scaling dataset \"rna\" #> ✔ Scaling dataset \"rna\" ... done #>  #> ℹ Scaling dataset \"atac\" #> ✔ Scaling dataset \"atac\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     bmmc <- runINMF(bmmc, k = 20)     bmmc <- quantileNorm(bmmc)     bmmc <- normalizePeak(bmmc)     bmmc <- imputeKNN(bmmc, reference = \"atac\", queries = \"rna\") } #> ℹ Normalizing peak of dataset: \"atac\" #> ✔ Normalizing peak of dataset: \"atac\" ... done #>  #> ℹ Imputing 1 query dataset: \"rna\" #> ℹ from reference dataset: \"atac\" #> ℹ Normalizing peak of dataset: \"rna\" #> ✔ Normalizing peak of dataset: \"rna\" ... done #>"},{"path":"/reference/is.newLiger.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if given liger object if under new implementation — is.newLiger","title":"Check if given liger object if under new implementation — is.newLiger","text":"Check given liger object new implementation","code":""},{"path":"/reference/is.newLiger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if given liger object if under new implementation — is.newLiger","text":"","code":"is.newLiger(object)"},{"path":"/reference/is.newLiger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if given liger object if under new implementation — is.newLiger","text":"object liger object","code":""},{"path":"/reference/is.newLiger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if given liger object if under new implementation — is.newLiger","text":"TRUE version object later equal 1.99.0. Otherwise FALSE. raises error input object liger class.","code":""},{"path":"/reference/is.newLiger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if given liger object if under new implementation — is.newLiger","text":"","code":"is.newLiger(pbmc) # TRUE #> [1] TRUE"},{"path":"/reference/isH5Liger.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a liger or ligerDataset object is made of HDF5 file — isH5Liger","title":"Check if a liger or ligerDataset object is made of HDF5 file — isH5Liger","text":"Check liger ligerDataset object made HDF5 file","code":""},{"path":"/reference/isH5Liger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a liger or ligerDataset object is made of HDF5 file — isH5Liger","text":"","code":"isH5Liger(object, dataset = NULL)"},{"path":"/reference/isH5Liger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a liger or ligerDataset object is made of HDF5 file — isH5Liger","text":"object liger ligerDataset object. dataset object liger class, check specific dataset. NULL, Check datasets made HDF5 file. Default NULL.","code":""},{"path":"/reference/isH5Liger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a liger or ligerDataset object is made of HDF5 file — isH5Liger","text":"TRUE FALSE specified check.","code":""},{"path":"/reference/isH5Liger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if a liger or ligerDataset object is made of HDF5 file — isH5Liger","text":"","code":"isH5Liger(pbmc) #> [1] FALSE isH5Liger(pbmc, \"ctrl\") #> [1] FALSE ctrl <- dataset(pbmc, \"ctrl\") isH5Liger(ctrl) #> [1] FALSE"},{"path":"/reference/liger-DEG.html","id":null,"dir":"Reference","previous_headings":"","what":"Find DEG between two groups — runPairwiseDEG","title":"Find DEG between two groups — runPairwiseDEG","text":"Find DEG two groups. Two methods supported: \"wilcoxon\" \"pseudoBulk\". Wilcoxon rank sum test performed single-cell level, pseudo-bulk method aggregates cells basing biological replicates calls bulk RNAseq DE methods, DESeq2 wald test. real biological replicates available, pseudo replicates can generated. Please see detailed scenario usage.","code":""},{"path":"/reference/liger-DEG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find DEG between two groups — runPairwiseDEG","text":"","code":"runPairwiseDEG(   object,   groupTest,   groupCtrl,   variable1 = NULL,   variable2 = NULL,   method = c(\"wilcoxon\", \"pseudoBulk\"),   usePeak = FALSE,   useReplicate = NULL,   nPsdRep = 5,   minCellPerRep = 10,   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE) )  runMarkerDEG(   object,   conditionBy = NULL,   splitBy = NULL,   method = c(\"wilcoxon\", \"pseudoBulk\"),   useDatasets = NULL,   usePeak = FALSE,   useReplicate = NULL,   nPsdRep = 5,   minCellPerRep = 10,   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE) )  runWilcoxon(   object,   data.use = NULL,   compare.method = c(\"clusters\", \"datasets\") )"},{"path":"/reference/liger-DEG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find DEG between two groups — runPairwiseDEG","text":"object liger object, normalized data available groupTest, groupCtrl, variable1, variable2 Condition specification. See ?runPairwiseDEG section Pairwise DEG Scenarios detail. method DEG test method use. Choose \"wilcoxon\" \"pseudoBulk\". Default \"wilcoxon\" usePeak Logical. Whether use peak count instead gene count. supported ATAC datasets involved. Default FALSE. useReplicate cellMeta variable biological replicate annotation. used method = \"pseudoBulk\". Default NULL create nPsdRep pseudo replicates per group. nPsdRep Number pseudo replicates create. used method = \"pseudoBulk\", useReplicate = NULL. Default 5. minCellPerRep Numeric, make pseudo-bulk replicate less number cells. Default 10. seed Random seed use pseudo-replicate generation. Default 1. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. conditionBy cellMeta variable(s). Marker detection performed level variable. Multiple variables combined. Default NULL uses default cluster. splitBy Split data cellMeta variable(s) identify markers conditionBy within chunk. Default NULL. useDatasets Datasets perform marker detection within. Default NULL use datasets. data.use useDatasets. compare.method Choose \"clusters\" (default) \"datasets\". \"clusters\" compares cluster cells, \"datasets\" run within cluster compare dataset datasets.","code":""},{"path":"/reference/liger-DEG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find DEG between two groups — runPairwiseDEG","text":"data.frame DEG information","code":""},{"path":"/reference/liger-DEG.html","id":"pairwise-deg-scenarios","dir":"Reference","previous_headings":"","what":"Pairwise DEG Scenarios","title":"Find DEG between two groups — runPairwiseDEG","text":"Users can select classes cells variable cellMeta. variable1 variable2 used specify column cellMeta, groupTest groupCtrl used specify existing classes variable1 variable2, respectively. variable2 missing, groupCtrl considered variable1. example, variable1 = \"celltype\" variable2 = NULL, groupTest groupCtrl valid cell types object$celltype. variable1 \"celltype\" variable2 \"gender\", groupTest valid cell type object$celltype groupCtrl valid class object$gender. variable1 variable2 missing, groupTest groupCtrl valid index cells object.","code":""},{"path":"/reference/liger-DEG.html","id":"marker-detection-scenarios","dir":"Reference","previous_headings":"","what":"Marker Detection Scenarios","title":"Find DEG between two groups — runPairwiseDEG","text":"Marker detection generally performed one vs. rest manner. grouping condition specified conditionBy, column name cellMeta. splitBy specified another variable name cellMeta, marker detection iteratively done within level splitBy variable. example, conditionBy = \"celltype\" splitBy = NULL, marker detection performed comparing cells \"celltype_i\" cells, etc. conditionBy = \"celltype\" splitBy = \"gender\", marker detection performed comparing \"celltype_i\" cells \"gender_j\" cells \"gender_j\", etc.","code":""},{"path":"/reference/liger-DEG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find DEG between two groups — runPairwiseDEG","text":"","code":"# Compare between cluster \"0\" and cluster \"1\" degStats <- runPairwiseDEG(pbmcPlot, groupTest = 0, groupCtrl = 1,                            variable1 = \"leiden_cluster\") #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  # Compare between all cells from cluster \"5\" and # all cells from dataset \"stim\" degStats <- runPairwiseDEG(pbmcPlot, groupTest = \"5\", groupCtrl = \"stim\",                            variable1 = \"leiden_cluster\",                            variable2 = \"dataset\") #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  # Identify markers for each cluster. Equivalent to old version # `runWilcoxon(method = \"cluster\")` markerStats <- runMarkerDEG(pbmcPlot, conditionBy = \"leiden_cluster\") #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  # Identify dataset markers within each cluster. Equivalent to old version # `runWilcoxon(method = \"dataset\")`. markerStatsList <- runMarkerDEG(pbmcPlot, conditionBy = \"dataset\",                                 splitBy = \"leiden_cluster\") #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>"},{"path":"/reference/liger-class.html","id":null,"dir":"Reference","previous_headings":"","what":"liger class — liger-class","title":"liger class — liger-class","text":"liger object main data container LIGER analysis R. slot datasets list element ligerDataset object containing dataset specific information, expression matrices. parts liger object stores information can shared across analysis, cell metadata factorization result matrices. manual provides explanation liger object structure well usage class-specific methods. Please see detail sections information. liger objects created older versions rliger package, please try updating objects individually convertOldLiger.","code":""},{"path":"/reference/liger-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"liger class — liger-class","text":"","code":"datasets(x, check = NULL)  datasets(x, check = TRUE) <- value  dataset(x, dataset = NULL)  dataset(x, dataset, type = NULL, qc = TRUE) <- value  cellMeta(   x,   columns = NULL,   useDatasets = NULL,   cellIdx = NULL,   as.data.frame = FALSE,   ... )  cellMeta(   x,   columns = NULL,   useDatasets = NULL,   cellIdx = NULL,   inplace = FALSE,   check = FALSE ) <- value  defaultCluster(x, useDatasets = NULL, ...)  defaultCluster(x, name = NULL, useDatasets = NULL, ...) <- value  dimReds(x)  dimReds(x) <- value  dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...)  dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...) <- value  defaultDimRed(x, useDatasets = NULL, cellIdx = NULL)  defaultDimRed(x) <- value  varFeatures(x)  varFeatures(x, check = TRUE) <- value  varUnsharedFeatures(x, dataset = NULL)  varUnsharedFeatures(x, dataset, check = TRUE) <- value  commands(x, funcName = NULL, arg = NULL)  # S4 method for liger show(object)  # S4 method for liger dim(x)  # S4 method for liger dimnames(x)  # S4 method for liger,list dimnames(x) <- value  # S4 method for liger datasets(x, check = NULL)  # S4 method for liger,logical datasets(x, check = TRUE) <- value  # S4 method for liger,missing datasets(x, check = TRUE) <- value  # S4 method for liger,character_OR_NULL dataset(x, dataset = NULL)  # S4 method for liger,missing dataset(x, dataset = NULL)  # S4 method for liger,numeric dataset(x, dataset = NULL)  # S4 method for liger,character,missing,ANY,ligerDataset dataset(x, dataset, type = NULL, qc = TRUE) <- value  # S4 method for liger,character,ANY,ANY,matrixLike dataset(x, dataset, type = c(\"rawData\", \"normData\"), qc = FALSE) <- value  # S4 method for liger,character,missing,ANY,NULL dataset(x, dataset, type = NULL, qc = TRUE) <- value  # S3 method for liger names(x)  # S3 method for liger names(x) <- value  # S3 method for liger length(x)  # S3 method for liger lengths(x, use.names = TRUE)  # S4 method for liger,NULL cellMeta(   x,   columns = NULL,   useDatasets = NULL,   cellIdx = NULL,   as.data.frame = FALSE,   ... )  # S4 method for liger,character cellMeta(   x,   columns = NULL,   useDatasets = NULL,   cellIdx = NULL,   as.data.frame = FALSE,   ... )  # S4 method for liger,missing cellMeta(   x,   columns = NULL,   useDatasets = NULL,   cellIdx = NULL,   as.data.frame = FALSE,   ... )  # S4 method for liger,missing cellMeta(x, columns = NULL, useDatasets = NULL, cellIdx = NULL, check = FALSE) <- value  # S4 method for liger,character cellMeta(   x,   columns = NULL,   useDatasets = NULL,   cellIdx = NULL,   inplace = TRUE,   check = FALSE ) <- value  # S4 method for liger rawData(x, dataset = NULL)  # S4 method for liger,ANY,ANY,matrixLike_OR_NULL rawData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,H5D rawData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger normData(x, dataset = NULL)  # S4 method for liger,ANY,ANY,matrixLike_OR_NULL normData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,H5D normData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY scaleData(x, dataset = NULL)  # S4 method for liger,ANY,ANY,matrixLike_OR_NULL scaleData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,H5D scaleData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,H5Group scaleData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,character scaleUnsharedData(x, dataset = NULL)  # S4 method for liger,numeric scaleUnsharedData(x, dataset = NULL)  # S4 method for liger,ANY,ANY,matrixLike_OR_NULL scaleUnsharedData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,H5D scaleUnsharedData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,H5Group scaleUnsharedData(x, dataset = NULL, check = TRUE) <- value  # S4 method for liger,ANY,ANY,ANY getMatrix(   x,   slot = c(\"rawData\", \"normData\", \"scaleData\", \"scaleUnsharedData\", \"H\", \"V\", \"U\", \"A\",     \"B\", \"W\", \"H.norm\"),   dataset = NULL,   returnList = FALSE )  # S4 method for liger,ANY getH5File(x, dataset = NULL)  # S3 method for liger [[(x, i) <- value  # S3 method for liger $(x, name)  # S3 method for liger $(x, name) <- value  # S4 method for liger defaultCluster(x, useDatasets = NULL, droplevels = FALSE, ...)  # S4 method for liger,ANY,ANY,character defaultCluster(x, name = NULL, useDatasets = NULL, ...) <- value  # S4 method for liger,ANY,ANY,factor defaultCluster(x, name = NULL, useDatasets = NULL, droplevels = TRUE, ...) <- value  # S4 method for liger,ANY,ANY,NULL defaultCluster(x, name = NULL, useDatasets = NULL, ...) <- value  # S4 method for liger dimReds(x)  # S4 method for liger,list dimReds(x) <- value  # S4 method for liger,missing_OR_NULL dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...)  # S4 method for liger,index dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...)  # S4 method for liger,index,ANY,ANY,NULL dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...) <- value  # S4 method for liger,character,ANY,ANY,matrixLike dimRed(   x,   name = NULL,   useDatasets = NULL,   cellIdx = NULL,   asDefault = NULL,   inplace = FALSE,   ... ) <- value  # S4 method for liger defaultDimRed(x, useDatasets = NULL, cellIdx = cellIdx)  # S4 method for liger,character defaultDimRed(x) <- value  # S4 method for liger varFeatures(x)  # S4 method for liger,ANY,character varFeatures(x, check = TRUE) <- value  # S4 method for liger,ANY varUnsharedFeatures(x, dataset = NULL)  # S4 method for liger,ANY,ANY,character varUnsharedFeatures(x, dataset, check = TRUE) <- value  # S3 method for liger fortify(model, data, ...)  # S3 method for liger c(...)  # S4 method for liger commands(x, funcName = NULL, arg = NULL)  # S4 method for ligerDataset,missing varUnsharedFeatures(x, dataset = NULL)  # S4 method for ligerDataset,missing,ANY,character varUnsharedFeatures(x, dataset = NULL, check = TRUE) <- value"},{"path":"/reference/liger-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"liger class — liger-class","text":"x, object, model liger object check Logical, whether perform object validity check setting new value. Users supposed set FALSE . value Metadata value inserted dataset Name numeric index dataset type using dataset<- matrix like value, specify type matrix . Choose \"rawData\", \"normData\" \"scaleData\". qc Logical, whether perform general qc added new dataset. columns names available variables cellMeta slot. .data.frame = TRUE, please use variable names coercion. useDatasets Setter getter method apply cells specified datasets. valid character, numeric logical subscriber acceptable. Default NULL works datasets. cellIdx Valid cell subscription subset retrieved variables. Default NULL uses cells. .data.frame Logical, whether apply .data.frame subscription. Default FALSE. ... See detailed sections explanation. inplace cellMeta<- method, columns existing variable useDatasets cellIdx indicate partial insertion object, whether default (TRUE) -place insert value variable selected cells replace whole variable non-selected part left NA. name name available variables cellMeta slot name new variable store. funcName, arg See Command records section. use.names Whether returned vector named dataset names. slot Name slot retrieve matrix . Options shown Usage. returnList Logical, whether force return list even one dataset-specific matrix (.e. expression matrices, H, V U) requested. Default FALSE. Name numeric index cell meta variable replaced droplevels Whether remove unused cluster levels factor object fetched defaultCluster(). Default FALSE. asDefault Whether set inserted dimension reduction matrix default visualization methods. Default NULL sets default set yet, otherwise change current default. data fortify method required argument. used.","code":""},{"path":"/reference/liger-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"liger class — liger-class","text":"See detailed sections explanetion. Input liger object updated replaced/new variable cellMeta(x).","code":""},{"path":"/reference/liger-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"liger class — liger-class","text":"datasets list ligerDataset objects. Use generic dataset, dataset<-, datasets datasets<- interact . See detailed section accordingly. cellMeta DFrame object cell metadata. Pre-existing metadata, QC metrics, cluster labeling, low-dimensional embedding etc. stored . Use generic cellMeta, cellMeta<-, $, [[]] [[]]<- interact . See detailed section accordingly. varFeatures Character vector feature names. Use generic varFeatures varFeatures<- interact . See detailed section accordingly. W Matrix gene loading factor. See runIntegration. H.norm Matrix aligned factor loading cell. See quantileNorm runIntegration. commands List ligerCommand objects. Record analysis. Use commands retrieve information. See detailed section accordingly. uns List unstructured meta-info analyses presets. version Record version rliger package","code":""},{"path":"/reference/liger-class.html","id":"dataset-access","dir":"Reference","previous_headings":"","what":"Dataset access","title":"liger class — liger-class","text":"datasets() method accesses datasets slot, list ligerDataset objects. dataset() method accesses single dataset, subsequent cell metadata updates checks bonded adding modifying dataset. Therefore, users want modify something inside ligerDataset cell metadata change happen, recommended use: datasets(x)[[name]] <- ligerD efficiency, though result dataset(x, name) <- ligerD. length() names() methods implemented access number names datasets. names<- method supported modifying dataset names, taking care \"dataset\" variable cell metadata.","code":""},{"path":"/reference/liger-class.html","id":"matrix-access","dir":"Reference","previous_headings":"","what":"Matrix access","title":"liger class — liger-class","text":"liger object, rawData(), normData, scaleData() scaleUnsharedData() methods exported users access corresponding feature expression matrix specification one dataset. retrieving type matrix multiple datasets, please use getMatrix() method. one matrix expected retrieved getMatrix(), matrix returned. list returned multiple matrices requested (querying multiple datasets) returnList set TRUE.","code":""},{"path":"/reference/liger-class.html","id":"cell-metadata-access","dir":"Reference","previous_headings":"","what":"Cell metadata access","title":"liger class — liger-class","text":"Three approaches provided access cell metadata. generic function cellMeta implemented plenty options multi-variable accessibility. Besides, users can use double-bracket (e.g. ligerObj[[varName]]) dollor-sign (e.g. ligerObj$nUMI) access modify single variables. users' convenience generating customized ggplot available cell metadata, S3 method fortify.liger implemented. hook, users can create simple ggplots directly starting ggplot(ligerObj, aes(...)) cell metadata variables can directly thrown aes(). Special partial metadata insertion implemented specifically mapping categorical annotation sub-population (subset object) back original experiment (full-size object). example, sub-clustering annotation done specific cell-type cells (stored subobj) subset experiment (stored obj), users can cellMeta(obj, \"sub_ann\", cellIdx = colnames(subobj)) <- subobj$sub_ann map value back, leaving cells non-annotated NAs. Plotting variable also show NA cells default grey color. Furthermore, sub-clustering labels cell types can also mapped variable. example, cellMeta(obj, \"sub_ann\", cellIdx = colnames(subobj2)) <- subobj2$sub_ann. long labeling variables stored factor class (categorical), levels (category names) properly handled merged. situations follow R default behavior (e.g. categories might converted integer numbers mapped numerical variable original object). Note feature available using generic function cellMeta `[[` `$` accessing methods due syntax reasons. generic defaultCluster works getter setter. setter, users can defaultCluster(obj) <- \"existingVariableName\" set categorical variable default cluster used visualization downstream analysis. Users can also defaultCluster(obj, \"newVarName\") <- factorOfLabels push new labeling object set default. getter method, function returns factor object default cluster labeling. Argument useDatasets can used requiring given retrieved labeling match cells specified datasets. generally recommend setting \"dataset\" default cluster preserved (always existing) field metadata can lead meaningless result running analysis utilizes clustering information dataset source information.","code":""},{"path":"/reference/liger-class.html","id":"dimension-reduction-access","dir":"Reference","previous_headings":"","what":"Dimension reduction access","title":"liger class — liger-class","text":"Currently, low-dimensional representaion cells, presented dense matrices, stored dimReds slot, can totally accessed generics dimRed dimRed<-. Adding dimRed object looks simple dimRed(obj, \"name\") <- matrixLike. can retrieved back dimRed(obj, \"name\"). Similar default cluster labeling, also constructed feature default dimRed. can set defaultDimRed(obj) <- \"existingMatLikeVar\" matrix can retrieved defaultDimRed(obj).","code":""},{"path":"/reference/liger-class.html","id":"variable-feature-access","dir":"Reference","previous_headings":"","what":"Variable feature access","title":"liger class — liger-class","text":"varFeatures slot allows character vectors gene names. varFeatures(x) returns vector value varFeatures<- method character vector NULL. replacement method, check = TRUE performs checks gene name consistency check across scaleData, H, V slots inner ligerDataset objects well W H.norm slots input liger object.","code":""},{"path":"/reference/liger-class.html","id":"command-records","dir":"Reference","previous_headings":"","what":"Command records","title":"liger class — liger-class","text":"rliger functions, perform calculation update liger object, recorded ligerCommand object stored commands slot, list, liger object. Method commands() implemented retrieve show log history. Running funcName = NULL (default) returns command labels. Specifying funcName allows partial matching command labels returns subset list (ligerCommand object) matches (ligerCommand object one match found). arg specified, subset list parameters matches returned. example, requesting list resolution values used louvain cluster attempts: commands(ligerObj, \"louvainCluster\", \"resolution\")","code":""},{"path":"/reference/liger-class.html","id":"dimensionality","dir":"Reference","previous_headings":"","what":"Dimensionality","title":"liger class — liger-class","text":"liger object, column orientation assigned cells. Due data structure, hard define row index liger object, might contain datasets vary number genes. Therefore, liger objects, dim dimnames returns NA/NULL rows total cell counts/barcodes columns. direct call dimnames<- method, value list NULL first element valid cell identifiers second element. colnames<- method, character vector cell identifiers. rownames<- method applicable.","code":""},{"path":"/reference/liger-class.html","id":"subsetting","dir":"Reference","previous_headings":"","what":"Subsetting","title":"liger class — liger-class","text":"detail subsetting liger object ligerDataset object, please check subsetLiger subsetLigerDataset. , set S4 method \"single-bracket\" [ quick wrapper subset liger object. Note j serves cell subscriptor can valid index refering collection cells (.e. rownames(cellMeta(obj))). , feature subscriptor can character vector features dataset can vary. ... arugments passed subsetLiger advanced options allowed.","code":""},{"path":"/reference/liger-class.html","id":"combining-multiple-liger-object","dir":"Reference","previous_headings":"","what":"Combining multiple liger object","title":"liger class — liger-class","text":"list datasets slot, rows cellMeta slot list commands slot simply concatenated. Variable features varFeatures slot taken union. \\(W\\) \\(H.norm\\) matrices taken account now.","code":""},{"path":"/reference/liger-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"liger class — liger-class","text":"","code":"# Methods for base generics pbmcPlot #> An object of class liger with 600 cells #> datasets(2): ctrl (300 cells), stim (300 cells)  #> cellMeta(3): dataset, nUMI, leiden_cluster  #> varFeatures(50): ISG15, ID3, RPL11, ..., HIST1H2AC  #> dimReds(1): UMAP  print(pbmcPlot) #> An object of class liger with 600 cells #> datasets(2): ctrl (300 cells), stim (300 cells)  #> cellMeta(3): dataset, nUMI, leiden_cluster  #> varFeatures(50): ISG15, ID3, RPL11, ..., HIST1H2AC  #> dimReds(1): UMAP  dim(pbmcPlot) #> [1]  NA 600 ncol(pbmcPlot) #> [1] 600 colnames(pbmcPlot)[1:5] #> [1] \"ctrl_AAACATACCTCGCT.1\" \"ctrl_AAACGGCTCTTCGC.1\" \"ctrl_AACACTCTAAGTAG.1\" #> [4] \"ctrl_AACCGCCTCAGGAG.1\" \"ctrl_AACGTTCTTCCGTC.1\" pbmcPlot[varFeatures(pbmcPlot)[1:10], 1:10] #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>  #> An object of class liger with 10 cells #> datasets(1): ctrl (10 cells)  #> cellMeta(3): dataset, nUMI, leiden_cluster  #> varFeatures(10): ISG15, ID3, RPL11, ..., S100A8  #> dimReds(1): UMAP  names(pbmcPlot) #> [1] \"ctrl\" \"stim\" length(pbmcPlot) #> [1] 2  # rliger generics ## Retrieving dataset(s), replacement methods available datasets(pbmcPlot) #> $ctrl #> An object of class ligerDataset with 300 cells #> normData: 50 features #>  #> $stim #> An object of class ligerDataset with 300 cells #> normData: 50 features #>  dataset(pbmcPlot, \"ctrl\") #> An object of class ligerDataset with 300 cells #> normData: 50 features dataset(pbmcPlot, 2) #> An object of class ligerDataset with 300 cells #> normData: 50 features  ## Retrieving cell metadata, replacement methods available cellMeta(pbmcPlot) #> DataFrame with 600 rows and 3 columns #>                        dataset      nUMI leiden_cluster #>                       <factor> <numeric>       <factor> #> ctrl_AAACATACCTCGCT.1     ctrl      2151              0 #> ctrl_AAACGGCTCTTCGC.1     ctrl      1916              0 #> ctrl_AACACTCTAAGTAG.1     ctrl      1869              0 #> ctrl_AACCGCCTCAGGAG.1     ctrl       733              3 #> ctrl_AACGTTCTTCCGTC.1     ctrl       573              1 #> ...                        ...       ...            ... #> stim_TTCATGACTTATCC.1     stim      1091              0 #> stim_TTCATGACTTCAGG.1     stim       431              1 #> stim_TTCGGAGATTTCAC.1     stim      1344              7 #> stim_TTGACACTTCCTGC.1     stim      1423              7 #> stim_TTTGCATGAACGAA.1     stim      2818              6 head(pbmcPlot[[\"nUMI\"]]) #> [1] 2151 1916 1869  733  573 1872 head(pbmcPlot$UMAP) #> NULL  ## Retrieving variable features, replacement methods available varFeatures(pbmcPlot) #>  [1] \"ISG15\"     \"ID3\"       \"RPL11\"     \"MARCKSL1\"  \"RPS8\"      \"GBP1\"      #>  [7] \"S100A10\"   \"S100A11\"   \"S100A9\"    \"S100A8\"    \"S100A6\"    \"S100A4\"    #> [13] \"RPS27\"     \"FCER1G\"    \"FCGR3A\"    \"XCL2\"      \"XCL1\"      \"SELL\"      #> [19] \"RSAD2\"     \"RPS27A\"    \"GNLY\"      \"DUSP2\"     \"RPL31\"     \"IL1B\"      #> [25] \"CXCR4\"     \"PTMA\"      \"RPL32\"     \"RPL15\"     \"RPL14\"     \"GPX1\"      #> [31] \"TEX264\"    \"FGFBP2\"    \"RPL9\"      \"IL8\"       \"PPBP\"      \"CXCL3\"     #> [37] \"CXCL10\"    \"PLAC8\"     \"H2AFZ\"     \"RPL34\"     \"ANXA5\"     \"RPS3A\"     #> [43] \"GZMK\"      \"RPS23\"     \"CD14\"      \"CD74\"      \"RPS14\"     \"NPM1\"      #> [49] \"CD83\"      \"HIST1H2AC\"  ## Command record/history pbmcPlot <- scaleNotCenter(pbmcPlot) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  commands(pbmcPlot) #> [1] \"normalize.liger_741028558e\"      \"selectGenes.liger_c7a9432654\"    #> [3] \"scaleNotCenter.liger_fbb78f6b9e\" \"runINMF.liger_2b7a03d986\"        #> [5] \"quantileNorm.liger_3d42d49bd9\"   \"runCluster_8c80b11e91\"           #> [7] \"runUMAP_51304eca8d\"              \"scaleNotCenter.liger_34e18a2db6\" commands(pbmcPlot, funcName = \"scaleNotCenter\") #> $scaleNotCenter.liger_fbb78f6b9e #> A liger command record, performed at 02-29-2024 23:33:43 EST  #> Call: scaleNotCenter.liger(.)  #> Parameters: #>     useDatasets : \"ctrl\", \"stim\"  #>     features : \"Long character with 173 elements: ISG15, ID3, RPL11, ..., CCNH\"  #>     verbose : TRUE  #>  #> $scaleNotCenter.liger_34e18a2db6 #> A liger command record, performed at 03-16-2024 00:41:32 EDT  #> Call: scaleNotCenter.liger(pbmcPlot)  #> Parameters: #>     useDatasets : \"ctrl\", \"stim\"  #>     features : \"Long character with 50 elements: ISG15, ID3, RPL11, ..., HIST1H2AC\"  #>     verbose : TRUE  #>   # S3 methods pbmcPlot2 <- pbmcPlot names(pbmcPlot2) <- paste0(names(pbmcPlot), 2) c(pbmcPlot, pbmcPlot2) #> An object of class liger with 1200 cells #> datasets(4): ctrl (300 cells), stim (300 cells), ctrl2 (300 cells), stim2 (300 cells)  #> cellMeta(3): dataset, nUMI, leiden_cluster  #> varFeatures(50): ISG15, ID3, RPL11, ..., HIST1H2AC  #> dimReds(0):    library(ggplot2) ggplot(pbmcPlot, aes(x = UMAP_1, y = UMAP_2)) + geom_point()  cellMeta(pbmc) #> DataFrame with 600 rows and 7 columns #>                        dataset               barcode      nUMI     nGene #>                       <factor>           <character> <numeric> <integer> #> ctrl_AAACATACCTCGCT.1     ctrl ctrl_AAACATACCTCGCT.1      2151       102 #> ctrl_AAACGGCTCTTCGC.1     ctrl ctrl_AAACGGCTCTTCGC.1      1916       103 #> ctrl_AACACTCTAAGTAG.1     ctrl ctrl_AACACTCTAAGTAG.1      1869        95 #> ctrl_AACCGCCTCAGGAG.1     ctrl ctrl_AACCGCCTCAGGAG.1       733        84 #> ctrl_AACGTTCTTCCGTC.1     ctrl ctrl_AACGTTCTTCCGTC.1       573        76 #> ...                        ...                   ...       ...       ... #> stim_TTCATGACTTATCC.1     stim stim_TTCATGACTTATCC.1      1091       101 #> stim_TTCATGACTTCAGG.1     stim stim_TTCATGACTTCAGG.1       431        86 #> stim_TTCGGAGATTTCAC.1     stim stim_TTCGGAGATTTCAC.1      1344       102 #> stim_TTGACACTTCCTGC.1     stim stim_TTGACACTTCCTGC.1      1423       105 #> stim_TTTGCATGAACGAA.1     stim stim_TTTGCATGAACGAA.1      2818       120 #>                            mito      ribo      hemo #>                       <numeric> <numeric> <numeric> #> ctrl_AAACATACCTCGCT.1         0  10.83217         0 #> ctrl_AAACGGCTCTTCGC.1         0  20.25052         0 #> ctrl_AACACTCTAAGTAG.1         0   5.08293         0 #> ctrl_AACCGCCTCAGGAG.1         0  42.70123         0 #> ctrl_AACGTTCTTCCGTC.1         0  38.04538         0 #> ...                         ...       ...       ... #> stim_TTCATGACTTATCC.1         0   8.61595         0 #> stim_TTCATGACTTCAGG.1         0  41.29930         0 #> stim_TTCGGAGATTTCAC.1         0   8.85417         0 #> stim_TTGACACTTCCTGC.1         0  11.94659         0 #> stim_TTTGCATGAACGAA.1         0   9.43932         0 # Add new variable pbmc[[\"newVar\"]] <- 1 cellMeta(pbmc) #> DataFrame with 600 rows and 8 columns #>                        dataset               barcode      nUMI     nGene #>                       <factor>           <character> <numeric> <integer> #> ctrl_AAACATACCTCGCT.1     ctrl ctrl_AAACATACCTCGCT.1      2151       102 #> ctrl_AAACGGCTCTTCGC.1     ctrl ctrl_AAACGGCTCTTCGC.1      1916       103 #> ctrl_AACACTCTAAGTAG.1     ctrl ctrl_AACACTCTAAGTAG.1      1869        95 #> ctrl_AACCGCCTCAGGAG.1     ctrl ctrl_AACCGCCTCAGGAG.1       733        84 #> ctrl_AACGTTCTTCCGTC.1     ctrl ctrl_AACGTTCTTCCGTC.1       573        76 #> ...                        ...                   ...       ...       ... #> stim_TTCATGACTTATCC.1     stim stim_TTCATGACTTATCC.1      1091       101 #> stim_TTCATGACTTCAGG.1     stim stim_TTCATGACTTCAGG.1       431        86 #> stim_TTCGGAGATTTCAC.1     stim stim_TTCGGAGATTTCAC.1      1344       102 #> stim_TTGACACTTCCTGC.1     stim stim_TTGACACTTCCTGC.1      1423       105 #> stim_TTTGCATGAACGAA.1     stim stim_TTTGCATGAACGAA.1      2818       120 #>                            mito      ribo      hemo    newVar #>                       <numeric> <numeric> <numeric> <numeric> #> ctrl_AAACATACCTCGCT.1         0  10.83217         0         1 #> ctrl_AAACGGCTCTTCGC.1         0  20.25052         0         1 #> ctrl_AACACTCTAAGTAG.1         0   5.08293         0         1 #> ctrl_AACCGCCTCAGGAG.1         0  42.70123         0         1 #> ctrl_AACGTTCTTCCGTC.1         0  38.04538         0         1 #> ...                         ...       ...       ...       ... #> stim_TTCATGACTTATCC.1         0   8.61595         0         1 #> stim_TTCATGACTTCAGG.1         0  41.29930         0         1 #> stim_TTCGGAGATTTCAC.1         0   8.85417         0         1 #> stim_TTGACACTTCCTGC.1         0  11.94659         0         1 #> stim_TTTGCATGAACGAA.1         0   9.43932         0         1 # Change existing variable pbmc[[\"newVar\"]][1:3] <- 1:3 cellMeta(pbmc) #> DataFrame with 600 rows and 8 columns #>                        dataset               barcode      nUMI     nGene #>                       <factor>           <character> <numeric> <integer> #> ctrl_AAACATACCTCGCT.1     ctrl ctrl_AAACATACCTCGCT.1      2151       102 #> ctrl_AAACGGCTCTTCGC.1     ctrl ctrl_AAACGGCTCTTCGC.1      1916       103 #> ctrl_AACACTCTAAGTAG.1     ctrl ctrl_AACACTCTAAGTAG.1      1869        95 #> ctrl_AACCGCCTCAGGAG.1     ctrl ctrl_AACCGCCTCAGGAG.1       733        84 #> ctrl_AACGTTCTTCCGTC.1     ctrl ctrl_AACGTTCTTCCGTC.1       573        76 #> ...                        ...                   ...       ...       ... #> stim_TTCATGACTTATCC.1     stim stim_TTCATGACTTATCC.1      1091       101 #> stim_TTCATGACTTCAGG.1     stim stim_TTCATGACTTCAGG.1       431        86 #> stim_TTCGGAGATTTCAC.1     stim stim_TTCGGAGATTTCAC.1      1344       102 #> stim_TTGACACTTCCTGC.1     stim stim_TTGACACTTCCTGC.1      1423       105 #> stim_TTTGCATGAACGAA.1     stim stim_TTTGCATGAACGAA.1      2818       120 #>                            mito      ribo      hemo    newVar #>                       <numeric> <numeric> <numeric> <numeric> #> ctrl_AAACATACCTCGCT.1         0  10.83217         0         1 #> ctrl_AAACGGCTCTTCGC.1         0  20.25052         0         2 #> ctrl_AACACTCTAAGTAG.1         0   5.08293         0         3 #> ctrl_AACCGCCTCAGGAG.1         0  42.70123         0         1 #> ctrl_AACGTTCTTCCGTC.1         0  38.04538         0         1 #> ...                         ...       ...       ...       ... #> stim_TTCATGACTTATCC.1         0   8.61595         0         1 #> stim_TTCATGACTTCAGG.1         0  41.29930         0         1 #> stim_TTCGGAGATTTCAC.1         0   8.85417         0         1 #> stim_TTGACACTTCCTGC.1         0  11.94659         0         1 #> stim_TTTGCATGAACGAA.1         0   9.43932         0         1"},{"path":"/reference/ligerATACDataset-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Subclass of ligerDataset for ATAC modality — ligerATACDataset-class","title":"Subclass of ligerDataset for ATAC modality — ligerATACDataset-class","text":"Inherits ligerDataset class. Contained slots can referred link.","code":""},{"path":"/reference/ligerATACDataset-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Subclass of ligerDataset for ATAC modality — ligerATACDataset-class","text":"rawPeak sparse matrix normPeak sparse matrix","code":""},{"path":"/reference/ligerCommand-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ligerCommand object: Record the input and time of a LIGER function call — ligerCommand-class","title":"ligerCommand object: Record the input and time of a LIGER function call — ligerCommand-class","text":"ligerCommand object: Record input time LIGER function call","code":""},{"path":"/reference/ligerCommand-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ligerCommand object: Record the input and time of a LIGER function call — ligerCommand-class","text":"","code":"# S4 method for ligerCommand show(object)"},{"path":"/reference/ligerCommand-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ligerCommand object: Record the input and time of a LIGER function call — ligerCommand-class","text":"object ligerCommand object","code":""},{"path":"/reference/ligerCommand-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ligerCommand object: Record the input and time of a LIGER function call — ligerCommand-class","text":"funcName Name function time time stamp object call character string converted system call parameters List arguments except liger object. Large object summarized short string. objSummary List attributes liger object snapshot command operated. ligerVersion Character string converted packageVersion(\"rliger\"). dependencyVersion Named character vector version number, dependency library chance included function. dependency might invoked certain conditions, using alternative algorithm, call actually reach , still included call.","code":""},{"path":"/reference/ligerCommand-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ligerCommand object: Record the input and time of a LIGER function call — ligerCommand-class","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  cmd <- commands(pbmc, \"normalize\") cmd #> A liger command record, performed at 03-16-2024 00:41:32 EDT  #> Call: normalize.liger(pbmc)  #> Parameters: #>     useDatasets : \"ctrl\", \"stim\"  #>     verbose : TRUE"},{"path":"/reference/ligerDataset-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ligerDataset class — ligerDataset-class","title":"ligerDataset class — ligerDataset-class","text":"Object storing dastaset specific information. embedded within higher level liger object","code":""},{"path":"/reference/ligerDataset-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ligerDataset class — ligerDataset-class","text":"","code":"rawData(x, dataset = NULL)  rawData(x, dataset = NULL, check = TRUE) <- value  normData(x, dataset = NULL)  normData(x, dataset = NULL, check = TRUE) <- value  scaleData(x, dataset = NULL)  scaleData(x, dataset = NULL, check = TRUE) <- value  scaleUnsharedData(x, dataset = NULL)  scaleUnsharedData(x, dataset = NULL, check = TRUE) <- value  getMatrix(x, slot = \"rawData\", dataset = NULL, returnList = FALSE)  h5fileInfo(x, info = NULL)  h5fileInfo(x, info = NULL, check = TRUE) <- value  getH5File(x, dataset = NULL)  # S4 method for ligerDataset,missing getH5File(x, dataset = NULL)  featureMeta(x, check = NULL)  featureMeta(x, check = TRUE) <- value  # S4 method for ligerDataset show(object)  # S4 method for ligerDataset dim(x)  # S4 method for ligerDataset dimnames(x)  # S4 method for ligerDataset,list dimnames(x) <- value  # S4 method for ligerDataset rawData(x, dataset = NULL)  # S4 method for ligerDataset,ANY,ANY,matrixLike_OR_NULL rawData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset,ANY,ANY,H5D rawData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset normData(x, dataset = NULL)  # S4 method for ligerDataset,ANY,ANY,matrixLike_OR_NULL normData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset,ANY,ANY,H5D normData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset,missing scaleData(x, dataset = NULL)  # S4 method for ligerDataset,ANY,ANY,matrixLike_OR_NULL scaleData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset,ANY,ANY,H5D scaleData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset,ANY,ANY,H5Group scaleData(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerDataset,missing scaleUnsharedData(x, dataset = NULL)  # S4 method for ligerDataset,missing,ANY,matrixLike_OR_NULL scaleUnsharedData(x, check = TRUE) <- value  # S4 method for ligerDataset,missing,ANY,H5D scaleUnsharedData(x, check = TRUE) <- value  # S4 method for ligerDataset,missing,ANY,H5Group scaleUnsharedData(x, check = TRUE) <- value  # S4 method for ligerDataset,ANY,missing,missing getMatrix(   x,   slot = c(\"rawData\", \"normData\", \"scaleData\", \"scaleUnsharedData\", \"H\", \"V\", \"U\", \"A\",     \"B\"),   dataset = NULL )  # S4 method for ligerDataset h5fileInfo(x, info = NULL)  # S4 method for ligerDataset h5fileInfo(x, info = NULL, check = TRUE) <- value  # S4 method for ligerDataset featureMeta(x, check = NULL)  # S4 method for ligerDataset featureMeta(x, check = TRUE) <- value  # S3 method for ligerDataset cbind(x, ..., deparse.level = 1)"},{"path":"/reference/ligerDataset-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ligerDataset class — ligerDataset-class","text":"x, object ligerDataset object. dataset applicable ligerDataset methods. check Whether perform object validity check setting new value. value See detail sections requirements slot slot name using getMatrix. returnList applicable ligerDataset methods. info Name entry h5fileInfo slot. ... See detailed sections explanation. deparse.level used .","code":""},{"path":"/reference/ligerDataset-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ligerDataset class — ligerDataset-class","text":"rawData Raw data. normData Normalized data scaleData Scaled data, usually subset variable features scaleUnsharedData Scaled data features shared datasets varUnsharedFeatures Variable features shared datasets V matrix matrix B matrix H matrix U matrix h5fileInfo list featureMeta Feature metadata, DataFrame colnames character rownames character","code":""},{"path":"/reference/ligerDataset-class.html","id":"matrix-access","dir":"Reference","previous_headings":"","what":"Matrix access","title":"ligerDataset class — ligerDataset-class","text":"ligerDataset object, rawData(), normData, scaleData() scaleUnsharedData() methods exported users access corresponding feature expression matrix. Replacement methods also available modify slots. matrices, \\(H\\) \\(V\\), dataset specific, please use getMatrix() method specifying slot name. Directly accessing slot @ generally recommended.","code":""},{"path":"/reference/ligerDataset-class.html","id":"h-file-and-information-access","dir":"Reference","previous_headings":"","what":"H5 file and information access","title":"ligerDataset class — ligerDataset-class","text":"ligerDataset object slot called h5fileInfo, list object. first element called $H5File, H5File class object connection input file. second element $filename stores absolute path H5 file current machine. third element $formatType stores name preset used, applicable. following keys pair paths H5 file point specific data constructing feature expression matrix. h5fileInfo() method access list described simply retrieves corresponding value. info = NULL, returns whole list. length(info) == 1, returns requested list value. info requested, returns subset list. replacement method modifies list elements corresponding slot value (applicable) time. example, running h5fileInfo(obj, \"rawData\") <- newPath updates list, also updates rawData slot H5D class data \"newPath\" H5File object. getH5File() wrapper equivalent h5fileInfo(obj, \"H5File\").","code":""},{"path":"/reference/ligerDataset-class.html","id":"feature-metadata-access","dir":"Reference","previous_headings":"","what":"Feature metadata access","title":"ligerDataset class — ligerDataset-class","text":"slot featureMeta included ligerDataset object. slot requires DataFrame-class object, cellMeta slot liger object. However, associated S4 methods include access whole table now. Internal information access follows way data.frame operation. example, featureMeta(ligerD)$nCell featureMeta(ligerD)[varFeatures(ligerObj), \"gene_var\"].","code":""},{"path":"/reference/ligerDataset-class.html","id":"dimensionality","dir":"Reference","previous_headings":"","what":"Dimensionality","title":"ligerDataset class — ligerDataset-class","text":"ligerDataset object, column orientation assigned cells rows features. Therefore, ligerDataset objects, dim() returns numeric vector two numbers number features number cells. dimnames() returns list two character vectors, feature names cell barcodes. direct call dimnames<- method, value list character vector feature names first element cell identifiers second element. colnames<- method, character vector cell identifiers. rownames<- method, character vector feature names.","code":""},{"path":"/reference/ligerDataset-class.html","id":"subsetting","dir":"Reference","previous_headings":"","what":"Subsetting","title":"ligerDataset class — ligerDataset-class","text":"detail subsetting liger object ligerDataset object, please check subsetLiger subsetLigerDataset. , set S3 method \"single-bracket\" [ quick wrapper subset ligerDataset object. j serves feature cell subscriptor, respectively, can valid index refering available features cells dataset. ... arugments passed subsetLigerDataset advanced options allowed.","code":""},{"path":"/reference/ligerDataset-class.html","id":"concatenate-ligerdataset","dir":"Reference","previous_headings":"","what":"Concatenate ligerDataset","title":"ligerDataset class — ligerDataset-class","text":"cbind() method implemented concatenating ligerDataset objects cells. applying, feature expression matrix merged taking union features rows.","code":""},{"path":"/reference/ligerDataset-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ligerDataset class — ligerDataset-class","text":"","code":"ctrl <- dataset(pbmc, \"ctrl\")  # Methods for base generics ctrl #> An object of class ligerDataset with 300 cells #> rawData: 266 features print(ctrl) #> An object of class ligerDataset with 300 cells #> rawData: 266 features dim(ctrl) #> [1] 266 300 ncol(ctrl) #> [1] 300 nrow(ctrl) #> [1] 266 colnames(ctrl)[1:5] #> [1] \"ctrl_AAACATACCTCGCT.1\" \"ctrl_AAACGGCTCTTCGC.1\" \"ctrl_AACACTCTAAGTAG.1\" #> [4] \"ctrl_AACCGCCTCAGGAG.1\" \"ctrl_AACGTTCTTCCGTC.1\" rownames(ctrl)[1:5] #> [1] \"ISG15\"    \"ID3\"      \"RPL11\"    \"MARCKSL1\" \"RPS8\"     ctrl[1:5, 1:5] #> An object of class ligerDataset with 5 cells #> rawData: 5 features  # rliger generics ## raw data m <- rawData(ctrl) class(m) #> [1] \"dgCMatrix\" #> attr(,\"package\") #> [1] \"Matrix\" dim(m) #> [1] 266 300 ## normalized data pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  ctrl <- dataset(pbmc, \"ctrl\") m <- normData(ctrl) class(m) #> [1] \"dgCMatrix\" #> attr(,\"package\") #> [1] \"Matrix\" dim(m) #> [1] 266 300 ## scaled data pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  ctrl <- dataset(pbmc, \"ctrl\") m <- scaleData(ctrl) class(m) #> [1] \"dgCMatrix\" #> attr(,\"package\") #> [1] \"Matrix\" dim(m) #> [1] 173 300 n <- scaleData(pbmc, \"ctrl\") identical(m, n) #> [1] TRUE ## Any other matrices if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     pbmc <- runOnlineINMF(pbmc, k = 20, minibatchSize = 100)     ctrl <- dataset(pbmc, \"ctrl\")     V <- getMatrix(ctrl, \"V\")     V[1:5, 1:5]     Vs <- getMatrix(pbmc, \"V\")     length(Vs)     names(Vs)     identical(Vs$ctrl, V) } #> [1] TRUE"},{"path":"/reference/ligerMethDataset-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Subclass of ligerDataset for Methylation modality — ligerMethDataset-class","title":"Subclass of ligerDataset for Methylation modality — ligerMethDataset-class","text":"Inherits ligerDataset class. Contained slots can referred link. scaleNotCenter applied datasets class automatically taken reversing normalized data instead scaling variable features.","code":""},{"path":"/reference/ligerRNADataset-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Subclass of ligerDataset for RNA modality — ligerRNADataset-class","title":"Subclass of ligerDataset for RNA modality — ligerRNADataset-class","text":"Inherits ligerDataset class. Contained slots can referred link. subclass different default ligerDataset class except class name.","code":""},{"path":"/reference/ligerSpatialDataset-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Subclass of ligerDataset for Spatial modality — ligerSpatialDataset-class","title":"Subclass of ligerDataset for Spatial modality — ligerSpatialDataset-class","text":"Inherits ligerDataset class. Contained slots can referred link.","code":""},{"path":"/reference/ligerSpatialDataset-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Subclass of ligerDataset for Spatial modality — ligerSpatialDataset-class","text":"coordinate dense matrix","code":""},{"path":"/reference/ligerToSeurat.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between liger and Seurat object — ligerToSeurat","title":"Convert between liger and Seurat object — ligerToSeurat","text":"converting liger object Seurat object, rawData, normData, scaleData dataset, cellMeta, H.norm varFeatures slot included. Compatible V4 V5. recommended use conversion liger object contains datasets various modalities.","code":""},{"path":"/reference/ligerToSeurat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between liger and Seurat object — ligerToSeurat","text":"","code":"ligerToSeurat(   object,   assay = NULL,   identByDataset = FALSE,   merge = FALSE,   nms = NULL,   renormalize = NULL,   use.liger.genes = NULL,   by.dataset = identByDataset )"},{"path":"/reference/ligerToSeurat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between liger and Seurat object — ligerToSeurat","text":"object liger object converted assay Name assay store data. Default NULL detects dataset modality. object contains various modality, default \"LIGER\". Default dataset modality setting understood \"RNA\". identByDataset Logical, whether combine dataset variable default cluster labeling set Idents. Default FALSE. merge Logical, whether merge layers different datasets one. recommended. Default FALSE. nms [Defunct] ignored new object structure related problem. renormalize [Defunct] ignored since Seurat V5, layers data can exist time better left users . use.liger.genes [Defunct] ignored always set LIGER variable features place. .dataset [Deprecated]. Use identByDataset instead.","code":""},{"path":"/reference/ligerToSeurat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between liger and Seurat object — ligerToSeurat","text":"Always returns Seurat object(s) latest version. default Seurat object split layers, e.g. layers like \"counts.ctrl\" \"counts.stim\". merge = TRUE, return single Seurat object layers datasets merged.","code":""},{"path":"/reference/ligerToSeurat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between liger and Seurat object — ligerToSeurat","text":"","code":"seu <- ligerToSeurat(pbmc)"},{"path":"/reference/linkGenesAndPeaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Linking genes to putative regulatory elements — linkGenesAndPeaks","title":"Linking genes to putative regulatory elements — linkGenesAndPeaks","text":"Evaluate relationships pairs genes peaks based specified distance metric. Usually used inferring correlation gene expression imputed peak counts datasets without modality originally (.e. applied imputeKNN result).","code":""},{"path":"/reference/linkGenesAndPeaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linking genes to putative regulatory elements — linkGenesAndPeaks","text":"","code":"linkGenesAndPeaks(   object,   useDataset,   pathToCoords,   useGenes = NULL,   method = c(\"spearman\", \"pearson\", \"kendall\"),   alpha = 0.05,   verbose = getOption(\"ligerVerbose\", TRUE),   path_to_coords = pathToCoords,   genes.list = useGenes,   dist = method )"},{"path":"/reference/linkGenesAndPeaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linking genes to putative regulatory elements — linkGenesAndPeaks","text":"object liger object, datasets ligerATACDataset class datasets slot. useDataset Name one dataset, normalized gene expression normalized peak counts available. pathToCoords Path tothe gene coordinates file, usually BED file. useGenes Character vector gene names tested. Default NULL uses genes available useDataset. method Choose type correlation calculate, \"spearman\", \"pearson\" \"kendall\". Default \"spearman\" alpha Numeric, significance threshold correlation p-value. Peak-gene correlations p-values threshold considered significant. Default 0.05. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. path_to_coords, genes.list, dist Deprecated. See Usage section replacement.","code":""},{"path":"/reference/linkGenesAndPeaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linking genes to putative regulatory elements — linkGenesAndPeaks","text":"sparse matrix peak names rows gene names columns, element indicating correlation peak gene j, 0 gene peak significantly linked.","code":""},{"path":[]},{"path":"/reference/linkGenesAndPeaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linking genes to putative regulatory elements — linkGenesAndPeaks","text":"","code":"bmmc <- normalize(bmmc) #> ℹ Normalizing datasets \"rna\" #> ℹ Normalizing datasets \"atac\" #> ✔ Normalizing datasets \"atac\" ... done #>  #> ℹ Normalizing datasets \"rna\" #> ✔ Normalizing datasets \"rna\" ... done #>  bmmc <- selectGenes(bmmc) #> ℹ Selecting variable features for dataset \"rna\" #> ✔ ... 83 features selected out of 172 shared features. #> ℹ Selecting variable features for dataset \"atac\" #> ✔ ... 126 features selected out of 172 shared features. #> ✔ Finally 135 shared variable features are selected. bmmc <- scaleNotCenter(bmmc) #> ℹ Scaling dataset \"rna\" #> ✔ Scaling dataset \"rna\" ... done #>  #> ℹ Scaling dataset \"atac\" #> ✔ Scaling dataset \"atac\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     bmmc <- runINMF(bmmc, miniBatchSize = 100)     bmmc <- quantileNorm(bmmc)     bmmc <- normalizePeak(bmmc)     bmmc <- imputeKNN(bmmc, reference = \"atac\", queries = \"rna\")     corr <- linkGenesAndPeaks(         bmmc, useDataset = \"rna\",         pathToCoords = system.file(\"extdata/hg19_genes.bed\", package = \"rliger\")     ) } #> ℹ Normalizing peak of dataset: \"atac\" #> ✔ Normalizing peak of dataset: \"atac\" ... done #>  #> ℹ Imputing 1 query dataset: \"rna\" #> ℹ from reference dataset: \"atac\" #> ℹ Normalizing peak of dataset: \"rna\" #> ✔ Normalizing peak of dataset: \"rna\" ... done #>  #> ℹ 172 genes to be tested against 995 peaks #> ℹ Calculating correlation for gene-peak pairs..."},{"path":"/reference/louvainCluster-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] Louvain algorithm for community detection — louvainCluster-deprecated","title":"[Deprecated] Louvain algorithm for community detection — louvainCluster-deprecated","text":"quantile normalization, users can additionally run Louvain algorithm community detection, widely used single-cell analysis excels merging small clusters broad cell classes.","code":""},{"path":"/reference/louvainCluster-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] Louvain algorithm for community detection — louvainCluster-deprecated","text":"object liger object. run quantile_norm calling. k maximum number nearest neighbours compute. (default 20) resolution Value resolution parameter, use value () 1.0 want obtain larger (smaller) number communities. (default 1.0) prune Sets cutoff acceptable Jaccard index computing neighborhood overlap SNN construction. edges values less equal set 0 removed SNN graph. Essentially sets strigency pruning (0 --- pruning, 1 --- prune everything). (default 1/15) eps error bound nearest neighbor search. (default 0.1) nRandomStarts Number random starts. (default 10) nIterations Maximal number iterations per random start. (default 100) random.seed Seed random number generator. (default 1) verbose Print messages (TRUE default) dims.use Indices factors use clustering. Default NULL uses available factors.","code":""},{"path":"/reference/louvainCluster-deprecated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] Louvain algorithm for community detection — louvainCluster-deprecated","text":"object refined cluster assignment updated \"louvain_cluster\" variable cellMeta slot. Can fetched object$louvain_cluster","code":""},{"path":[]},{"path":"/reference/makeFeatureMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast calculation of feature count matrix — makeFeatureMatrix","title":"Fast calculation of feature count matrix — makeFeatureMatrix","text":"Fast calculation feature count matrix","code":""},{"path":"/reference/makeFeatureMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast calculation of feature count matrix — makeFeatureMatrix","text":"","code":"makeFeatureMatrix(bedmat, barcodes)"},{"path":"/reference/makeFeatureMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast calculation of feature count matrix — makeFeatureMatrix","text":"bedmat feature count list generated bedmap barcodes list barcodes","code":""},{"path":"/reference/makeFeatureMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast calculation of feature count matrix — makeFeatureMatrix","text":"feature count matrix features rows barcodes columns","code":""},{"path":"/reference/makeFeatureMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast calculation of feature count matrix — makeFeatureMatrix","text":"","code":"if (FALSE) { gene.counts <- makeFeatureMatrix(genes.bc, barcodes) promoter.counts <- makeFeatureMatrix(promoters.bc, barcodes) samnple <- gene.counts + promoter.counts }"},{"path":"/reference/makeInteractTrack-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] Export predicted gene-pair interaction — makeInteractTrack-deprecated","title":"[Deprecated] Export predicted gene-pair interaction — makeInteractTrack-deprecated","text":"Export predicted gene-pair interactions calculated upstream function linkGenesAndPeaks Interact Track file compatible UCSC Genome Browser.","code":""},{"path":"/reference/makeInteractTrack-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] Export predicted gene-pair interaction — makeInteractTrack-deprecated","text":"corr.mat sparse matrix correlation peak names rows gene names columns. path_to_coords Path gene coordinates file. genes.list Character vector gene names exported. Default NULL uses genes available corrMat. output_path Path filename output file stored. folder, file named \"Interact_Track.bed\" created. Default current working directory.","code":""},{"path":"/reference/makeInteractTrack-deprecated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] Export predicted gene-pair interaction — makeInteractTrack-deprecated","text":"return value. file located outputPath created.","code":""},{"path":[]},{"path":"/reference/makeRiverplot-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] Generate a river (Sankey) plot — makeRiverplot-deprecated","title":"[Deprecated] Generate a river (Sankey) plot — makeRiverplot-deprecated","text":"Creates riverplot show separate cluster assignments two datasets map onto joint clustering. joint clustering default object clustering, external one can also passed . Uses riverplot package construct riverplot object plot.","code":""},{"path":"/reference/makeRiverplot-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] Generate a river (Sankey) plot — makeRiverplot-deprecated","text":"object liger object. run quantileAlignSNF calling. cluster1 Cluster assignments dataset 1. Note cluster names distinct across datasets. cluster2 Cluster assignments dataset 2. Note cluster names distinct across datasets. cluster_consensus Optional external consensus clustering (use instead object clusters) min.frac Minimum fraction cluster edge shown (default 0.05). min.cells Minumum number cells edge shown (default 10). river.yscale y-scale pass riverplot -- scales edge values factor, can used squeeze vertically (default 1). river.lty Line style pass riverplot (default 0). river.node_margin Node_margin pass riverplot -- much vertical space keep nodes (default 0.1). label.cex Size text labels (default 1). label.col Color text labels (defualt \"black\"). lab.srt Angle text labels (default 0). river.usr Coordinates draw plot form (x0, x1, y0, y1). node.order Order clusters set (list three vectors ordinal numbers). default try automatically order appropriately.","code":""},{"path":"/reference/makeRiverplot-deprecated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] Generate a river (Sankey) plot — makeRiverplot-deprecated","text":"object refined cluster assignment updated \"louvain_cluster\" variable cellMeta slot. Can fetched object$louvain_cluster","code":""},{"path":[]},{"path":"/reference/mapCellMeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Create new variable from categories in cellMeta — mapCellMeta","title":"Create new variable from categories in cellMeta — mapCellMeta","text":"Designed fast variable creation new variable going created existing variable. example, multiple samples can mapped study design condition, clusters can mapped cell types.","code":""},{"path":"/reference/mapCellMeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create new variable from categories in cellMeta — mapCellMeta","text":"","code":"mapCellMeta(object, from, newTo = NULL, ...)"},{"path":"/reference/mapCellMeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create new variable from categories in cellMeta — mapCellMeta","text":"object liger object. name original variable mapped . newTo name new variable store mapped result. Default NULL returns new variable (factor class). ... Mapping criteria, argument names original existing categories values new categories new variable.","code":""},{"path":"/reference/mapCellMeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create new variable from categories in cellMeta — mapCellMeta","text":"newTo = NULL, factor object new variable. Otherwise, input object variable newTo updated cellMeta(object).","code":""},{"path":"/reference/mapCellMeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create new variable from categories in cellMeta — mapCellMeta","text":"","code":"pbmc <- mapCellMeta(pbmc, from = \"dataset\", newTo = \"modal\",                     ctrl = \"rna\", stim = \"rna\")"},{"path":"/reference/mergeH5.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge hdf5 files — mergeH5","title":"Merge hdf5 files — mergeH5","text":"function merges hdf5 files generated different libraries (cell ranger default) preprocessed Liger pipeline.","code":""},{"path":"/reference/mergeH5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge hdf5 files — mergeH5","text":"","code":"mergeH5(   file.list,   library.names,   new.filename,   format.type = \"10X\",   data.name = NULL,   indices.name = NULL,   indptr.name = NULL,   genes.name = NULL,   barcodes.name = NULL )"},{"path":"/reference/mergeH5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge hdf5 files — mergeH5","text":"file.list List path hdf5 files. library.names Vector library names (corresponding file.list) new.filename String new hdf5 file name merging (default new.h5). format.type string HDF5 format (10X CellRanger default). data.name Path data values stored HDF5 file. indices.name Path indices data points stored HDF5 file. indptr.name Path pointers stored HDF5 file. genes.name Path gene names stored HDF5 file. barcodes.name Path barcodes stored HDF5 file.","code":""},{"path":"/reference/mergeH5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge hdf5 files — mergeH5","text":"Directly generates newly merged hdf5 file.","code":""},{"path":"/reference/mergeH5.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge hdf5 files — mergeH5","text":"","code":"if (FALSE) { # For instance, we want to merge two datasets saved in HDF5 files (10X # CellRanger) paths to datasets: \"library1.h5\",\"library2.h5\" # dataset names: \"lib1\", \"lib2\" # name for output HDF5 file: \"merged.h5\" mergeH5(list(\"library1.h5\",\"library2.h5\"), c(\"lib1\",\"lib2\"), \"merged.h5\") }"},{"path":"/reference/mergeSparseAll.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge matrices while keeping the union of rows — mergeSparseAll","title":"Merge matrices while keeping the union of rows — mergeSparseAll","text":"mergeSparseAll takes list DGEs, genes rows cells columns, merges single DGE. Also adds libraryNames colnames DGE expected overlap (common 10X barcodes). Values rawData normData slot ligerDataset object can processed . list dense matrices, usually values scaleData slot ligerDataset object, please use mergeDenseAll works way.","code":""},{"path":"/reference/mergeSparseAll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge matrices while keeping the union of rows — mergeSparseAll","text":"","code":"mergeSparseAll(   datalist,   libraryNames = NULL,   mode = c(\"union\", \"intersection\") )  mergeDenseAll(datalist, libraryNames = NULL)"},{"path":"/reference/mergeSparseAll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge matrices while keeping the union of rows — mergeSparseAll","text":"datalist List dgCMatrix mergeSparseAll list matrix mergeDenseAll. libraryNames Character vector added prefix barcodes matrix datalist. Length match number matrices. Default NULL modify barcodes. mode Whether take \"union\" \"intersection\" features merging. Default \"union\".","code":""},{"path":"/reference/mergeSparseAll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge matrices while keeping the union of rows — mergeSparseAll","text":"dgCMatrix matrix barcodes datalist columns union genes datalist rows.","code":""},{"path":"/reference/mergeSparseAll.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge matrices while keeping the union of rows — mergeSparseAll","text":"","code":"rawDataList <- getMatrix(pbmc, \"rawData\") merged <- mergeSparseAll(rawDataList, libraryNames = names(pbmc))"},{"path":"/reference/modalOf.html","id":null,"dir":"Reference","previous_headings":"","what":"Return preset modality of a ligerDataset object or that of all datasets in a\nliger object — modalOf","title":"Return preset modality of a ligerDataset object or that of all datasets in a\nliger object — modalOf","text":"Return preset modality ligerDataset object datasets liger object","code":""},{"path":"/reference/modalOf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return preset modality of a ligerDataset object or that of all datasets in a\nliger object — modalOf","text":"","code":"modalOf(object)"},{"path":"/reference/modalOf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return preset modality of a ligerDataset object or that of all datasets in a\nliger object — modalOf","text":"object ligerDataset object liger object","code":""},{"path":"/reference/modalOf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return preset modality of a ligerDataset object or that of all datasets in a\nliger object — modalOf","text":"single character modality setting value ligerDataset  object, named vector liger object, names dataset names.","code":""},{"path":"/reference/modalOf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return preset modality of a ligerDataset object or that of all datasets in a\nliger object — modalOf","text":"","code":"modalOf(pbmc) #>      ctrl      stim  #> \"default\" \"default\"  ctrl <- dataset(pbmc, \"ctrl\") modalOf(ctrl) #> [1] \"default\" ctrl.atac <- as.ligerDataset(ctrl, modal = \"atac\") modalOf(ctrl.atac) #> [1] \"atac\""},{"path":"/reference/normalize.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize raw counts data — normalize","title":"Normalize raw counts data — normalize","text":"Perform library size normalization raw counts input. preprocessing step iNMF integration, default multiply normalized values scale factor, take log transformation. Applicable S3 methods can found Usage section. normalizePeak designed datasets \"atac\" modality, .e. stored ligerATACDataset. S3 method various container object supported yet due difference architecture design.","code":""},{"path":"/reference/normalize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize raw counts data — normalize","text":"","code":"normalize(object, ...)  # S3 method for dgCMatrix normalize(object, log = FALSE, scaleFactor = NULL, ...)  # S3 method for ligerDataset normalize(object, chunk = 1000, verbose = getOption(\"ligerVerbose\", TRUE), ...)  # S3 method for liger normalize(   object,   useDatasets = NULL,   verbose = getOption(\"ligerVerbose\", TRUE),   format.type = NULL,   remove.missing = NULL,   ... )  # S3 method for Seurat normalize(object, assay = NULL, layer = \"counts\", save = \"ligerNormData\", ...)  normalizePeak(   object,   useDatasets = NULL,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/normalize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize raw counts data — normalize","text":"object liger object ... Arguments passed S3 methods. \"liger\" method calls \"ligerDataset\" method, calls \"dgCMatrix\" method. normalizePeak directly calls normalize.dgCMatrix. log Logical. Whether log(x + 1) transform normalized data. Default TRUE. scaleFactor Numeric. Scale normalized expression value factor transformation. NULL scaling. Default 1e4. chunk Integer. Number maximum number cells chunk working HDF5 file based ligerDataset. Default 1000. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. useDatasets character vector names, numeric logical vector index datasets normalized. specify ATACseq datasets using normalizePeak. Default NULL normalizes valid datasets. format.type, remove.missing Deprecated. functionality covered parts whole workflow long needed. ignored specified. assay Name assay use. Default NULL uses current active assay. layer input raw counts . Default \"counts\". older Seurat, always retrieve counts slot. save Seurat>=4.9.9, name layer store normalized data. Default \"ligerNormData\". older Seurat, stored data slot.","code":""},{"path":"/reference/normalize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize raw counts data — normalize","text":"Updated object. dgCMatrix method - Returns processed dgCMatrix object ligerDataset method - Updates normData slot object liger method - Updates normData slot chosen datasets Seurat method - Adds named layer chosen assay (V5), update  data slot chosen assay (<=V4) normalizePeak - Updates normPeak slot chosen  datasets.","code":""},{"path":"/reference/normalize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize raw counts data — normalize","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>"},{"path":"/reference/online_iNMF-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] Perform online iNMF on scaled datasets — online_iNMF-deprecated","title":"[Deprecated] Perform online iNMF on scaled datasets — online_iNMF-deprecated","text":"Please turn runOnlineINMF runIntegration. Perform online integrative non-negative matrix factorization represent multiple single-cell datasets terms H, W, V matrices. optimizes iNMF objective function using online learning (non-negative least squares H matrix, hierarchical alternating least squares W V matrices), number factors set k. function allows online learning 3 scenarios: (1) fully observed datasets; (2) iterative refinement using continually arriving datasets; (3) projection new datasets without updating existing factorization. three scenarios require fixed memory independent number cells. dataset, factorization produces H matrix (cells k), V matrix (k genes), shared W matrix (k genes). H matrices represent cell factor loadings. W identical among datasets, represents shared components metagenes across datasets. V matrices represent dataset-specific components metagenes.","code":""},{"path":"/reference/online_iNMF-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] Perform online iNMF on scaled datasets — online_iNMF-deprecated","text":"object liger object data stored HDF5 files. normalize, select genes, scale calling. X_new List new datasets scenario 2 scenario 3. list element name HDF5 file. projection Perform data integration shared metagene (W) projection (scenario 3). (default FALSE) W.init Optional initialization W. (default NULL) V.init Optional initialization V (default NULL) H.init Optional initialization H (default NULL) .init Optional initialization (default NULL) B.init Optional initialization B (default NULL) k Inner dimension factorization--number metagenes (default 20). value range 20-50 works well analyses. lambda Regularization parameter. Larger values penalize dataset-specific effects   strongly (ie. alignment increase lambda increases). recommend   always using default value except   possibly analyses relatively small differences (biological   replicates, male/female comparisons, etc.)   case lower value 1.0 may improve reconstruction quality.   (default 5.0). max.epochs Maximum number epochs (complete passes data). (default 5) miniBatch_max_iters Maximum number block coordinate descent (HALS algorithm) iterations perform update W V (default 1). Changing parameter  recommended. miniBatch_size Total number cells minibatch (default 5000). reasonable default, smaller value 1000 may necessary analyzing small datasets. general, minibatch size larger number cells smallest dataset. h5_chunk_size Chunk size input hdf5 files (default 1000). chunk size larger batch size. seed Random seed allow reproducible results (default 123). verbose Print progress bar/messages (TRUE default)","code":""},{"path":"/reference/online_iNMF-deprecated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] Perform online iNMF on scaled datasets — online_iNMF-deprecated","text":"liger object H, W, V, B slots set.","code":""},{"path":"/reference/optimizeALS-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] Perform iNMF on scaled datasets — optimizeALS-deprecated","title":"[Deprecated] Perform iNMF on scaled datasets — optimizeALS-deprecated","text":"Please turn runINMF runIntegration. Perform integrative non-negative matrix factorization return factorized H, W, V matrices. optimizes iNMF objective function using block coordinate descent (alternating non-negative least squares), number factors set k. TODO: include objective function equation documentation (using deqn) dataset, factorization produces H matrix (cells k), V matrix (k genes), shared W matrix (k genes). H matrices represent cell factor loadings. W held consistent among datasets, represents shared components metagenes across datasets. V matrices represent dataset-specific components metagenes.","code":""},{"path":"/reference/optimizeALS-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] Perform iNMF on scaled datasets — optimizeALS-deprecated","text":"object liger object. normalize, select genes, scale calling. k Inner dimension factorization (number factors). Run suggestK determine appropriate value; general rule thumb higher k needed datasets sub-structure. lambda Regularization parameter. Larger values penalize dataset-specific effects strongly (ie. alignment increase lambda increases). Run suggestLambda determine appropriate value balancing dataset alignment agreement (default 5.0). thresh Convergence threshold. Convergence occurs |obj0-obj|/(mean(obj0,obj)) < thresh. (default 1e-6) max.iters Maximum number block coordinate descent iterations perform (default 30). nrep Number restarts perform (iNMF objective function non-convex, taking best objective multiple successive initializations recommended). easier reproducibility, increments random seed 1 consecutive restart, future factorizations dataset can run one rep necessary. (default 1) H.init Initial values use H matrices. (default NULL) W.init Initial values use W matrix (default NULL) V.init Initial values use V matrices (default NULL) rand.seed Random seed allow reproducible results (default 1). print.obj Print objective function values convergence (default FALSE). verbose Print progress bar/messages (TRUE default) ... Arguments passed methods","code":""},{"path":"/reference/optimizeALS-deprecated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] Perform iNMF on scaled datasets — optimizeALS-deprecated","text":"liger object H, W, V slots set.","code":""},{"path":[]},{"path":"/reference/optimizeNewData.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform factorization for new data — optimizeNewData","title":"Perform factorization for new data — optimizeNewData","text":"Uses efficient strategy updating takes advantage information existing factorization. Assumes variable features presented new datasets. Two modes supported (controlled merge): Append new data existing datasets specified useDatasets. existing \\(V\\) matrices target datasets directly used initialization, new \\(H\\) matrices merged matrices initialized accordingly. Set new data new datasets. Initial \\(V\\) matrices copied datasets specified useDatasets, new \\(H\\) matrices initialized accordingly.","code":""},{"path":"/reference/optimizeNewData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform factorization for new data — optimizeNewData","text":"","code":"optimizeNewData(   object,   dataNew,   useDatasets,   merge = TRUE,   lambda = NULL,   nIteration = 30,   seed = 1,   verbose = getOption(\"ligerVerbose\"),   new.data = dataNew,   which.datasets = useDatasets,   add.to.existing = merge,   max.iters = nIteration,   thresh = NULL )"},{"path":"/reference/optimizeNewData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform factorization for new data — optimizeNewData","text":"object liger object. integrative factorization performed e.g. (runINMF) advance. dataNew Named list raw count matrices, genes cells. useDatasets Selection datasets append new data merge = TRUE, datasets inherit \\(V\\) matrices initialize optimization merge = FALSE. match length order dataNew. merge Logical, whether add new data existing datasets treat totally new datasets (.e. calculate new \\(V\\) matrices). Default TRUE. lambda Numeric regularization parameter. default NULL, use lambda value used latest factorization. nIteration Number block coordinate descent iterations perform. Default 30. seed Random seed allow reproducible results. Default 1. Used runINMF factorization. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. new.data, .datasets, add..existing, max.iters arguments now replaced others removed future. Please see usage replacement. thresh Deprecated. New implementation iNMF require threshold convergence detection. Setting large enough nIteration bring convergence.","code":""},{"path":"/reference/optimizeNewData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform factorization for new data — optimizeNewData","text":"object W slot updated new \\(W\\) matrix, H V slots ligerDataset object datasets slot updated new dataset specific \\(H\\) \\(V\\) matrix, respectively.","code":""},{"path":[]},{"path":"/reference/optimizeNewData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform factorization for new data — optimizeNewData","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  # Only running a few iterations for fast examples if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     pbmc <- runINMF(pbmc, k = 20, nIteration = 2)     # Create fake new data by increasing all non-zero count in \"ctrl\" by 1,     # and make unique cell identifiers     ctrl2 <- rawData(dataset(pbmc, \"ctrl\"))     ctrl2@x <- ctrl2@x + 1     colnames(ctrl2) <- paste0(colnames(ctrl2), 2)     pbmcNew <- optimizeNewData(pbmc, dataNew = list(ctrl2 = ctrl2),                                useDatasets = \"ctrl\", nIteration = 2) } #> Sat Mar 16 00:41:37 2024 ... Initializing with new data merged to existing datasets... #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>"},{"path":"/reference/optimizeNewK.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform factorization for new value of k — optimizeNewK","title":"Perform factorization for new value of k — optimizeNewK","text":"uses efficient strategy updating takes advantage information existing factorization. recommended values kNew smaller current value (k, set running runINMF), likely speed factorization.","code":""},{"path":"/reference/optimizeNewK.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform factorization for new value of k — optimizeNewK","text":"","code":"optimizeNewK(   object,   kNew,   lambda = NULL,   nIteration = 30,   seed = 1,   verbose = getOption(\"ligerVerbose\"),   k.new = kNew,   max.iters = nIteration,   rand.seed = seed,   thresh = NULL )"},{"path":"/reference/optimizeNewK.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform factorization for new value of k — optimizeNewK","text":"object liger object. integrative factorization performed e.g. (runINMF) advance. kNew Number factors factorization. lambda Numeric regularization parameter. default NULL, use lambda value used latest factorization. nIteration Number block coordinate descent iterations perform. Default 30. seed Random seed allow reproducible results. Default 1. Used runINMF factorization initialization kNew greater k. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. k.new, max.iters, rand.seed arguments now replaced others removed future. Please see usage replacement. thresh Deprecated. New implementation iNMF require threshold convergence detection. Setting large enough nIteration bring convergence.","code":""},{"path":"/reference/optimizeNewK.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform factorization for new value of k — optimizeNewK","text":"object W slot updated new \\(W\\) matrix, H V slots ligerDataset object datasets slot updated new dataset specific \\(H\\) \\(V\\) matrix, respectively.","code":""},{"path":[]},{"path":"/reference/optimizeNewK.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform factorization for new value of k — optimizeNewK","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  # Only running a few iterations for fast examples if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     pbmc <- runINMF(pbmc, k = 20, nIteration = 2)     pbmc <- optimizeNewK(pbmc, kNew = 25, nIteration = 2) } #> Sat Mar 16 00:41:37 2024 ... Initializing with new k..."},{"path":"/reference/optimizeNewLambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform factorization for new lambda value — optimizeNewLambda","title":"Perform factorization for new lambda value — optimizeNewLambda","text":"Uses efficient strategy updating takes advantage information existing factorization; always uses previous k. Recommended mainly re-optimizing higher lambda new lambda value significantly different; otherwise may return optimal results.","code":""},{"path":"/reference/optimizeNewLambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform factorization for new lambda value — optimizeNewLambda","text":"","code":"optimizeNewLambda(   object,   lambdaNew,   nIteration = 30,   seed = 1,   verbose = getOption(\"ligerVerbose\"),   new.lambda = lambdaNew,   max.iters = nIteration,   rand.seed = seed,   thresh = NULL )"},{"path":"/reference/optimizeNewLambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform factorization for new lambda value — optimizeNewLambda","text":"object liger object. integrative factorization (e.g. runINMF) performed advance. lambdaNew Numeric regularization parameter. Larger values penalize dataset-specific effects strongly. nIteration Number block coordinate descent iterations perform. Default 30. seed Random seed allow reproducible results. Default 1. Used runINMF factorization. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. new.lambda, max.iters, rand.seed arguments now replaced others removed future. Please see usage replacement. thresh Deprecated. New implementation iNMF require threshold convergence detection. Setting large enough nIteration bring convergence.","code":""},{"path":"/reference/optimizeNewLambda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform factorization for new lambda value — optimizeNewLambda","text":"Input object optimized factorization values updated. including W matrix liger object, H V matrices ligerDataset object datasets slot.","code":""},{"path":[]},{"path":"/reference/optimizeNewLambda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform factorization for new lambda value — optimizeNewLambda","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     # Only running a few iterations for fast examples     pbmc <- runINMF(pbmc, k = 20, nIteration = 2)     pbmc <- optimizeNewLambda(pbmc, lambdaNew = 5.5, nIteration = 2) }"},{"path":"/reference/optimizeSubset.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform factorization for subset of data — optimizeSubset","title":"Perform factorization for subset of data — optimizeSubset","text":"Uses efficient strategy updating takes advantage information existing factorization.","code":""},{"path":"/reference/optimizeSubset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform factorization for subset of data — optimizeSubset","text":"","code":"optimizeSubset(   object,   clusterVar = NULL,   useClusters = NULL,   lambda = NULL,   nIteration = 30,   cellIdx = NULL,   scaleDatasets = NULL,   seed = 1,   verbose = getOption(\"ligerVerbose\"),   cell.subset = cellIdx,   cluster.subset = useClusters,   max.iters = nIteration,   datasets.scale = scaleDatasets,   thresh = NULL )"},{"path":"/reference/optimizeSubset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform factorization for subset of data — optimizeSubset","text":"object liger object. integrative factorization (e.g. runINMF) performed advance. clusterVar, useClusters Together select clusters subset object conveniently. clusterVar name variable cellMeta(object) useClusters vector names clusters variable. clusterVar default default cluster (See runCluster, defaultCluster \"Cell metadata access\"). Users can otherwise select cells explicitly cellIdx complex conditions. useClusters overrides cellIdx. lambda Numeric regularization parameter. default NULL, use lambda value used latest factorization. nIteration Maximum number block coordinate descent iterations perform. Default 30. cellIdx Valid index vector applies whole object. See subsetLiger requirement. Default NULL. scaleDatasets Names datasets re-scale subsetting. Default NULL re-scale. seed Random seed allow reproducible results. Default 1. Used runINMF factorization. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. cell.subset, cluster.subset, max.iters, datasets.scale arguments now replaced others removed future. Please see usage replacement. thresh Deprecated. New implementation iNMF require threshold convergence detection. Setting large enough nIteration bring convergence.","code":""},{"path":"/reference/optimizeSubset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform factorization for subset of data — optimizeSubset","text":"Subset object factorization matrices optimized, including W matrix liger object, W V matrices ligerDataset object datasets slot. scaleData ligerDataset objects datasets specified scaleDatasets also updated reflect subset.","code":""},{"path":"/reference/optimizeSubset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform factorization for subset of data — optimizeSubset","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     # Only running a few iterations for fast examples     pbmc <- runINMF(pbmc, k = 20, nIteration = 2)     pbmc <- optimizeSubset(pbmc, cellIdx = sort(sample(ncol(pbmc), 200)),                            nIteration = 2) } #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>"},{"path":"/reference/pbmc.html","id":null,"dir":"Reference","previous_headings":"","what":"liger object of PBMC subsample data with Control and Stimulated datasets — pbmc","title":"liger object of PBMC subsample data with Control and Stimulated datasets — pbmc","text":"liger object PBMC subsample data Control Stimulated datasets","code":""},{"path":"/reference/pbmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"liger object of PBMC subsample data with Control and Stimulated datasets — pbmc","text":"","code":"pbmc"},{"path":"/reference/pbmc.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"liger object of PBMC subsample data with Control and Stimulated datasets — pbmc","text":"liger object two datasets named \"ctrl\" \"stim\".","code":""},{"path":"/reference/pbmc.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"liger object of PBMC subsample data with Control and Stimulated datasets — pbmc","text":"https://www.nature.com/articles/nbt.4042","code":""},{"path":"/reference/pbmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"liger object of PBMC subsample data with Control and Stimulated datasets — pbmc","text":"Hyun Min Kang et. al., Nature Biotechnology, 2018","code":""},{"path":"/reference/pbmcPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"liger object of PBMC subsample data with plotting information available — pbmcPlot","title":"liger object of PBMC subsample data with plotting information available — pbmcPlot","text":"data generated data \"pbmc\" default parameter integration pipeline: normalize, selectGenes, scaleNotCenter, runINMF, runCluster, runUMAP. minimize object size distributed package, rawData scaleData removed. Genes downsampled top 50 variable genes, smaller normData \\(W\\) matrix.","code":""},{"path":"/reference/pbmcPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"liger object of PBMC subsample data with plotting information available — pbmcPlot","text":"","code":"pbmcPlot"},{"path":"/reference/pbmcPlot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"liger object of PBMC subsample data with plotting information available — pbmcPlot","text":"liger object two datasets named \"ctrl\" \"stim\".","code":""},{"path":"/reference/pbmcPlot.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"liger object of PBMC subsample data with plotting information available — pbmcPlot","text":"https://www.nature.com/articles/nbt.4042","code":""},{"path":"/reference/pbmcPlot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"liger object of PBMC subsample data with plotting information available — pbmcPlot","text":"Hyun Min Kang et. al., Nature Biotechnology, 2018","code":""},{"path":"/reference/peak.html","id":null,"dir":"Reference","previous_headings":"","what":"Access ligerATACDataset peak data — rawPeak","title":"Access ligerATACDataset peak data — rawPeak","text":"Similar default ligerDataset data accessed.","code":""},{"path":"/reference/peak.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access ligerATACDataset peak data — rawPeak","text":"","code":"rawPeak(x, dataset)  rawPeak(x, dataset, check = TRUE) <- value  normPeak(x, dataset)  normPeak(x, dataset, check = TRUE) <- value  # S4 method for liger,character rawPeak(x, dataset)  # S4 method for liger,character rawPeak(x, dataset, check = TRUE) <- value  # S4 method for liger,character normPeak(x, dataset)  # S4 method for liger,character normPeak(x, dataset, check = TRUE) <- value  # S4 method for ligerATACDataset,missing rawPeak(x, dataset = NULL)  # S4 method for ligerATACDataset,missing rawPeak(x, dataset = NULL, check = TRUE) <- value  # S4 method for ligerATACDataset,missing normPeak(x, dataset = NULL)  # S4 method for ligerATACDataset,missing normPeak(x, dataset = NULL, check = TRUE) <- value"},{"path":"/reference/peak.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access ligerATACDataset peak data — rawPeak","text":"x ligerATACDataset object liger object. dataset Name numeric index ATAC dataset. check Logical, whether perform object validity check setting new value. value dgCMatrix-class matrix.","code":""},{"path":"/reference/peak.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access ligerATACDataset peak data — rawPeak","text":"retrieved peak count matrix updated x object.","code":""},{"path":"/reference/plotCellViolin.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate violin/box plot(s) using liger object — plotCellViolin","title":"Generate violin/box plot(s) using liger object — plotCellViolin","text":"function allows using available cell metadata, feature expression factor loading generate violin plot, grouping data available categorical cell metadata. Available categorical cell metadata can used form color annotation. different grouping, forms nested grouping. Multiple y-axis variables allowed specification slot, returns list violin plot . Users can split plot(s) grouping cells (e.g. datasets).","code":""},{"path":"/reference/plotCellViolin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate violin/box plot(s) using liger object — plotCellViolin","text":"","code":"plotCellViolin(   object,   y,   groupBy = NULL,   slot = c(\"cellMeta\", \"rawData\", \"normData\", \"scaleData\", \"H.norm\", \"H\"),   yFunc = NULL,   cellIdx = NULL,   colorBy = NULL,   splitBy = NULL,   titles = NULL,   ... )"},{"path":"/reference/plotCellViolin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate violin/box plot(s) using liger object — plotCellViolin","text":"object liger object y Available variable name slot look value visualize. groupBy, colorBy Available variable name cellMeta slot look categorical grouping. See details. Default NULL produces grouping -black graphic elements. slot Choose slot find y variable. See Details. Default \"cellMeta\". yFunc function object expects vector/factor/data.frame retrieved y input, returns object size, y-axis replaced output. Useful , example, users need scale gene expression shown plot. cellIdx Character, logical numeric index can subscribe cells. Missing NULL cells. splitBy Character vector categorical variable names cellMeta slot. Split cells groupings /variable(s) produce violin plot containing cells group. Default NULL. titles Title text. character scalar character vector many elements multiple plots supposed generated. Default NULL. ... plot setting arguments. See .ggCellViolin .ggplotLigerTheme.","code":""},{"path":"/reference/plotCellViolin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate violin/box plot(s) using liger object — plotCellViolin","text":"ggplot object single plot intended. list ggplot objects, multiple y variables /splitBy set. plotly = TRUE, ggplot objects become plotly (htmlwidget) objects.","code":""},{"path":"/reference/plotCellViolin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate violin/box plot(s) using liger object — plotCellViolin","text":"Available option slot include: \"cellMeta\", \"rawData\", \"normData\", \"scaleData\", \"H.norm\" \"H\". \"rawData\", \"normData\" \"scaleData\", y character vector feature names. \"H.norm\" \"H\", colorBy can valid index select one factor interests. Note character index follows \"Factor_[k]\" format, replacing [k] integer. \"cellMeta\", y available column name table. Note , y well groupBy, colorBy splitBy since matrix object feasible cellMeta table, using column (e.g. named \"column1\" certain matrix (e.g. named \"matrixVar\") follow syntax \"matrixVar.column1\". matrix \"colname\" attribute, subscription goes \"matrixVar.V1\", \"matrixVar.V2\" etc. based nature .data.frame method DataFrame object. groupBy basically send ggplot2::aes(x), colorBy \"colour\" aesthetics. Specifying colorBy without groupBy visually creates grouping varying values x-axis, boxWidth forced value violinWidth situation.","code":""},{"path":"/reference/plotCellViolin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate violin/box plot(s) using liger object — plotCellViolin","text":"","code":"plotCellViolin(pbmcPlot, y = \"nUMI\", groupBy = \"dataset\", slot = \"cellMeta\")  plotCellViolin(pbmcPlot, y = \"nUMI\", groupBy = \"leiden_cluster\",                slot = \"cellMeta\", splitBy = \"dataset\",                colorBy = \"leiden_cluster\",                box = TRUE, dot = TRUE,                ylab = \"Total counts per cell\",                colorValues = RColorBrewer::brewer.pal(8, \"Set1\")) #> $nUMI.ctrl #> Warning: Duplicated `override.aes` is ignored.  #>  #> $nUMI.stim #> Warning: Duplicated `override.aes` is ignored.  #>  plotCellViolin(pbmcPlot, y = \"S100A8\", slot = \"normData\",                yFunc = function(x) log2(10000*x + 1),                groupBy = \"dataset\", colorBy = \"leiden_cluster\",                box = TRUE, ylab = \"S100A8 Expression\") #> Warning: Duplicated `override.aes` is ignored."},{"path":"/reference/plotClusterFactorDot.html","id":null,"dir":"Reference","previous_headings":"","what":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","title":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","text":"function produces dot plots. column represent group cells specified groupBy, row factor specified useDims. color dots reflects mean factor loading specified factors cell group sizes reflects percentage cells loadings factor group. utilize ComplexHeatmap simplified management adding annotation slicing subplots. inspired implementation scCustomize.","code":""},{"path":"/reference/plotClusterFactorDot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","text":"","code":"plotClusterFactorDot(   object,   groupBy = NULL,   useDims = NULL,   useRaw = FALSE,   splitBy = NULL,   factorScaleFunc = NULL,   cellIdx = NULL,   legendColorTitle = \"Mean Factor\\nLoading\",   legendSizeTitle = \"Percent\\nLoaded\",   viridisOption = \"viridis\",   verbose = FALSE,   ... )"},{"path":"/reference/plotClusterFactorDot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","text":"object liger object groupBy names columns cellMeta slot storing categorical variables. Loading data aggregated basing , together splitBy. Default uses default clusters. useDims Numeric vector specify exact factors interests. Default NULL uses available factors. useRaw Whether use un-aligned cell factor loadings (\\(H\\) matrices). Default FALSE. splitBy names columns cellMeta slot storing categorical variables. Dotplot panel splitting based . Default NULL. factorScaleFunc function object applied factor loading matrix scaling value better visualization. Default NULL. cellIdx Valid cell subscription. See subsetLiger. Default NULL using cells. legendColorTitle Title colorbar legend. Default \"Mean Factor\\nLoading\". legendSizeTitle Title size legend. Default \"Percent\\nLoaded\" viridisOption Name available viridis palette. See viridis. Default \"viridis\". verbose Logical. Whether show progress information. Mainly subsetting data. Default FALSE. ... Additional theme setting arguments passed .complexHeatmapDotPlot heatmap setting arguments passed Heatmap. See Details.","code":""},{"path":"/reference/plotClusterFactorDot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","text":"HeatmapList object.","code":""},{"path":"/reference/plotClusterFactorDot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","text":"..., please notice arguments colorMat, sizeMat, featureAnnDF, cellSplitVar, cellLabels viridisOption .complexHeatmapDotPlot already occupied function internally. lot arguments Heatmap also occupied: matrix, name, heatmap_legend_param, rect_gp, col, layer_fun, km, border, border_gp, column_gap, row_gap, cluster_row_slices, cluster_rows, row_title_gp, row_names_gp, row_split, row_labels, cluster_column_slices, cluster_columns, column_split, column_title_gp, column_title, column_labels, column_names_gp, top_annotation.","code":""},{"path":"/reference/plotClusterFactorDot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make dot plot of factor loading in cell groups — plotClusterFactorDot","text":"","code":"plotClusterFactorDot(pbmcPlot)"},{"path":"/reference/plotClusterGeneDot.html","id":null,"dir":"Reference","previous_headings":"","what":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","title":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","text":"function produces dot plots. column represent group cells specified groupBy, row gene specified features. color dots reflects mean normalized expression specified genes cell group sizes reflects percentage cells expressing gene group. utilize ComplexHeatmap simplified management adding annotation slicing subplots. inspired implementation scCustomize.","code":""},{"path":"/reference/plotClusterGeneDot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","text":"","code":"plotClusterGeneDot(   object,   features,   groupBy = NULL,   splitBy = NULL,   featureScaleFunc = function(x) log2(10000 * x + 1),   cellIdx = NULL,   legendColorTitle = \"Mean\\nExpression\",   legendSizeTitle = \"Percent\\nExpressed\",   viridisOption = \"magma\",   verbose = FALSE,   ... )"},{"path":"/reference/plotClusterGeneDot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","text":"object liger object features Use character vector gene names make plain dot plot like heatmap. Use data.frame first column gene names second column grouping variable (e.g. subset runMarkerDEG output) groupBy names columns cellMeta slot storing categorical variables. Expression data aggregated basing , together splitBy. Default uses default clusters. splitBy names columns cellMeta slot storing categorical variables. Dotplot panel splitting based . Default NULL. featureScaleFunc function object applied normalized data scaling value better visualization. Default function(x) log2(10000*x + 1) cellIdx Valid cell subscription. See subsetLiger. Default NULL using cells. legendColorTitle Title colorbar legend. Default \"Mean\\nExpression\". legendSizeTitle Title size legend. Default \"Percent\\nExpressed\" viridisOption Name available viridis palette. See viridis. Default \"magma\". verbose Logical. Whether show progress information. Mainly subsetting data. Default FALSE. ... Additional theme setting arguments passed .complexHeatmapDotPlot heatmap setting arguments passed Heatmap. See Details.","code":""},{"path":"/reference/plotClusterGeneDot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","text":"HeatmapList object.","code":""},{"path":"/reference/plotClusterGeneDot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","text":"..., please notice arguments colorMat, sizeMat, featureAnnDF, cellSplitVar, cellLabels viridisOption .complexHeatmapDotPlot already occupied function internally. lot arguments Heatmap also occupied: matrix, name, heatmap_legend_param, rect_gp, col, layer_fun, km, border, border_gp, column_gap, row_gap, cluster_row_slices, cluster_rows, row_title_gp, row_names_gp, row_split, row_labels, cluster_column_slices, cluster_columns, column_split, column_title_gp, column_title, column_labels, column_names_gp, top_annotation.","code":""},{"path":"/reference/plotClusterGeneDot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make dot plot of gene expression in cell groups — plotClusterGeneDot","text":"","code":"# Use character vector of genes features <- varFeatures(pbmcPlot)[1:10] plotClusterGeneDot(pbmcPlot, features = features)   # Use data.frame with grouping information, with more tweak on plot features <- data.frame(features, rep(letters[1:5], 2)) plotClusterGeneDot(pbmcPlot, features = features,                    clusterFeature = TRUE, clusterCell = TRUE, maxDotSize = 6)"},{"path":"/reference/plotDensityDimRed.html","id":null,"dir":"Reference","previous_headings":"","what":"Create density plot basing on specified coordinates — plotDensityDimRed","title":"Create density plot basing on specified coordinates — plotDensityDimRed","text":"function shows cell density presented 2D dimensionality reduction coordinates. Density shown coloring contour lines. scatter plot dimensionality reduction added well. density plot can splitted categorical variables (e.g. \"dataset\"), scatter plot always shown cells subplots reference global structure.","code":""},{"path":"/reference/plotDensityDimRed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create density plot basing on specified coordinates — plotDensityDimRed","text":"","code":"plotDensityDimRed(   object,   useDimRed = NULL,   splitBy = NULL,   combinePlot = TRUE,   minDensity = 8,   contour = TRUE,   contourLineWidth = 0.3,   contourBins = 5,   dot = TRUE,   dotColor = \"grey\",   dotSize = 0.6,   dotAlpha = 0.3,   dotRaster = NULL,   title = NULL,   legendFillTitle = \"Density\",   colorPalette = \"magma\",   colorDirection = -1,   ... )"},{"path":"/reference/plotDensityDimRed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create density plot basing on specified coordinates — plotDensityDimRed","text":"object liger object useDimRed Name variable storing dimensionality reduction result cellMeta slot. Default uses default dimension reduction. splitBy Character vector categorical variable names cellMeta slot. Split cells groupings /variable(s) produce density plot containing cells group. Default NULL. combinePlot Logical, whether utilize plot_grid combine multiple plots one. Default TRUE returns combined ggplot. FALSE returns list ggplot single ggplot one plot requested. minDensity positive number filter low density region colored plot. Default 8. Setting zero show density whole panel. contour Logical, whether draw contour line. Default TRUE. contourLineWidth Numeric, width contour line. Default 0.3. contourBins Number contour bins. Higher value generates contour lines. Default 5. dot Logical, whether add scatter plot cells, even density plot splitted splitBy. Default TRUE. dotColor, dotSize, dotAlpha Numeric, controls appearance dots. Default \"grey\", 0.6 0.3, respectively. dotRaster Logical, whether rasterize scatter plot. Default NULL automatically rasterizes dots number total cells plotted exceeds 100,000. title Text main title plots. Default NULL. Length character vector input match number plots generated. legendFillTitle Text legend title. Default \"Density\". colorPalette Name option scale_fill_viridis_c. Default \"magma\". colorDirection Color gradient direction scale_fill_viridis_c. Default -1. ... theme setting arguments passed .ggplotLigerTheme.","code":""},{"path":"/reference/plotDensityDimRed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create density plot basing on specified coordinates — plotDensityDimRed","text":"ggplot object one plot generated, ggplot object combined plot_grid multiple plots combinePlot = TRUE. list ggplot multiple plots combinePlot = FALSE.","code":""},{"path":"/reference/plotDensityDimRed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create density plot basing on specified coordinates — plotDensityDimRed","text":"","code":"# Example dataset has small number of cells, thus cutoff adjusted. plotDensityDimRed(pbmcPlot, minDensity = 1)"},{"path":"/reference/plotDimRed.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate scatter plot(s) using liger object — plotDimRed","title":"Generate scatter plot(s) using liger object — plotDimRed","text":"function allows using available cell metadata build x-/y-axis. Available per-cell data can used form color/shape annotation, including cell metadata, raw processed gene expression, unnormalized aligned factor loading. Multiple coloring variable allowed specification slot, returns list plots different coloring values. Users can split plot(s) grouping cells (e.g. datasets). text","code":""},{"path":"/reference/plotDimRed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate scatter plot(s) using liger object — plotDimRed","text":"","code":"plotDimRed(   object,   colorBy = NULL,   useDimRed = NULL,   slot = c(\"cellMeta\", \"rawData\", \"normData\", \"scaleData\", \"H.norm\", \"H\", \"normPeak\",     \"rawPeak\"),   colorByFunc = NULL,   cellIdx = NULL,   splitBy = NULL,   shapeBy = NULL,   titles = NULL,   ... )  plotClusterDimRed(object, useCluster = NULL, useDimRed = NULL, ...)  plotDatasetDimRed(object, useDimRed = NULL, ...)  plotByDatasetAndCluster(   object,   useDimRed = NULL,   useCluster = NULL,   combinePlots = TRUE,   ... )  plotGeneDimRed(   object,   features,   useDimRed = NULL,   log = TRUE,   scaleFactor = 10000,   zeroAsNA = TRUE,   colorPalette = \"C\",   ... )  plotPeakDimRed(   object,   features,   useDimRed = NULL,   log = TRUE,   scaleFactor = 10000,   zeroAsNA = TRUE,   colorPalette = \"C\",   ... )  plotFactorDimRed(   object,   factors,   useDimRed = NULL,   trimHigh = 0.03,   zeroAsNA = TRUE,   colorPalette = \"D\",   ... )"},{"path":"/reference/plotDimRed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate scatter plot(s) using liger object — plotDimRed","text":"object liger object. colorBy Available variable name specified slot look color annotation information. See details. Default NULL generates -black dots. useDimRed Name variable storing dimensionality reduction result cellMeta(object). Default NULL use default dimRed. slot Choose slot find colorBy variable. See details. Default \"cellMeta\". colorByFunc Default NULL. function object expects vector/factor/data.frame retrieved colorBy input, returns object size, color \"aes\" replaced output. Useful , example, users need scale gene expression shown plot. cellIdx Character, logical numeric index can subscribe cells. Missing NULL cells. splitBy Character vector categorical variable names cellMeta slot. Split cells groupings /variable(s) produce scatter plot containing cells group. Default NULL. shapeBy Available variable name cellMeta slot look categorical annotation reflected dot shapes. Default NULL. titles Title text. character scalar character vector many elements multiple plots supposed generated. Default NULL. ... plot setting arguments. See .ggScatter .ggplotLigerTheme. useCluster Name variable cellMeta(object). Default NULL uses default cluster. combinePlots Logical, whether utilize plot_grid combine multiple plots one. Default TRUE returns combined ggplot. FALSE returns list ggplot. features, factors Name genes index factors need visualized. log Logical. Whether log transform normalized expression genes. Default TRUE. scaleFactor Number multiplied normalized expression genes log transformation. Default 1e4. NULL scaling. zeroAsNA Logical, whether swap zero values NA naColor used represent non-expressing features. Default TRUE. colorPalette Name viridis palette. See viridis options. Default \"C\" (\"plasma\") gene expression \"D\" (\"viridis\") factor loading. trimHigh Number highest cut-limit outliers. Factor loading value trimmed value. Default 0.03.","code":""},{"path":"/reference/plotDimRed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate scatter plot(s) using liger object — plotDimRed","text":"ggplot object single plot intended. list ggplot objects, multiple colorBy variables /splitBy set. plotly = TRUE, ggplot objects become plotly (htmlwidget) objects. ggplot object one feature (e.g. cluster variable, gene, factor) set. List object multiple specified.","code":""},{"path":"/reference/plotDimRed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate scatter plot(s) using liger object — plotDimRed","text":"Available option slot include: \"cellMeta\", \"rawData\", \"normData\", \"scaleData\", \"H.norm\" \"H\". \"rawData\", \"normData\" \"scaleData\", colorBy character vector feature names. \"H.norm\" \"H\", colorBy can valid index select one factor interests. Note character index follows \"Factor_[k]\" format, replacing [k] integer. \"cellMeta\", colorBy available column name table. Note , colorBy well x, y, shapeBy splitBy, since matrix object feasible cellMeta table, using column (e.g. named \"column1\" certain matrix (e.g. named \"matrixVar\") follow syntax \"matrixVar.column1\". matrix \"colname\" attribute, subscription goes \"matrixVar.V1\", \"matrixVar.V2\" etc. Use \"UMAP.1\", \"UMAP.2\", \"TSNE.1\" \"TSNE.2\" 2D embeddings generated rliger package. based nature .data.frame method DataFrame object.","code":""},{"path":[]},{"path":"/reference/plotDimRed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate scatter plot(s) using liger object — plotDimRed","text":"","code":"plotDimRed(pbmcPlot, colorBy = \"dataset\", slot = \"cellMeta\",            labelText = FALSE) #> ℹ Plotting feature \"dataset\" on 600 cells #> ✔ Plotting feature \"dataset\" on 600 cells ... done #>   plotDimRed(pbmcPlot, colorBy = \"S100A8\", slot = \"normData\",            dotOrder = \"ascending\", dotSize = 2) #> ℹ Plotting feature \"S100A8\" on 600 cells #> ✔ Plotting feature \"S100A8\" on 600 cells ... done #>   plotDimRed(pbmcPlot, colorBy = 2, slot = \"H.norm\",            dotOrder = \"ascending\", dotSize = 2, colorPalette = \"viridis\") #> ℹ Plotting feature \"Factor_2\" on 600 cells #> ✔ Plotting feature \"Factor_2\" on 600 cells ... done #>   plotClusterDimRed(pbmcPlot) #> ℹ Plotting feature \"leiden_cluster\" on 600 cells #> ✔ Plotting feature \"leiden_cluster\" on 600 cells ... done #>   plotDatasetDimRed(pbmcPlot) #> ℹ Plotting feature \"dataset\" on 600 cells #> ✔ Plotting feature \"dataset\" on 600 cells ... done #>   plotByDatasetAndCluster(pbmcPlot) #> ℹ Plotting feature \"dataset\" on 600 cells #> ✔ Plotting feature \"dataset\" on 600 cells ... done #>  #> ℹ Plotting feature \"leiden_cluster\" on 600 cells #> ✔ Plotting feature \"leiden_cluster\" on 600 cells ... done #>   plotGeneDimRed(pbmcPlot, varFeatures(pbmcPlot)[1]) #> ℹ Plotting feature \"ISG15\" on 600 cells #> ✔ Plotting feature \"ISG15\" on 600 cells ... done #>   plotFactorDimRed(pbmcPlot, 2) #> ℹ Plotting feature \"Factor_2\" on 600 cells #> ✔ Plotting feature \"Factor_2\" on 600 cells ... done #>"},{"path":"/reference/plotGeneLoadings.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize factor expression and gene loading — plotGeneLoadings","title":"Visualize factor expression and gene loading — plotGeneLoadings","text":"Visualize factor expression gene loading","code":""},{"path":"/reference/plotGeneLoadings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize factor expression and gene loading — plotGeneLoadings","text":"","code":"plotGeneLoadings(   object,   markerTable,   useFactor,   useDimRed = NULL,   nLabel = 15,   nPlot = 30,   ... )  plotGeneLoadingRank(   object,   markerTable,   useFactor,   nLabel = 15,   nPlot = 30,   ... )"},{"path":"/reference/plotGeneLoadings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize factor expression and gene loading — plotGeneLoadings","text":"object liger object valid factorization result. markerTable Returned result getFactorMarkers. useFactor Integer index factor visualize. useDimRed Name variable storing dimensionality reduction result cellMeta slot. Default \"UMAP\". nLabel Integer, number top genes shown text labels. Default 15. nPlot Integer, number top genes shown loading rank plot. Default 30. ... Additional plot theme setting arguments passed .ggScatter .ggplotLigerTheme.","code":""},{"path":"/reference/plotGeneLoadings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize factor expression and gene loading — plotGeneLoadings","text":"","code":"result <- getFactorMarkers(pbmcPlot, \"ctrl\", \"stim\") #> ! Factor 7 did not appear as max in any cell in either dataset #>  plotGeneLoadings(pbmcPlot, result, useFactor = 2) #> ℹ Plotting feature \"Factor_2\" on 600 cells #> ✔ Plotting feature \"Factor_2\" on 600 cells ... done #>"},{"path":"/reference/plotGroupClusterDimRed.html","id":null,"dir":"Reference","previous_headings":"","what":"Comprehensive group splited cluster plot on dimension reduction with\nproportion — plotGroupClusterDimRed","title":"Comprehensive group splited cluster plot on dimension reduction with\nproportion — plotGroupClusterDimRed","text":"function produces combined plot group level (e.g. dataset, metadata variable like biological conditions). Scatter plot dimension reduction cluster labeled generated per group. Furthermore, stacked barplot cluster proportion within group also combined subplot group.","code":""},{"path":"/reference/plotGroupClusterDimRed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comprehensive group splited cluster plot on dimension reduction with\nproportion — plotGroupClusterDimRed","text":"","code":"plotGroupClusterDimRed(   object,   useGroup = \"dataset\",   useCluster = NULL,   useDimRed = NULL,   combinePlot = TRUE,   droplevels = TRUE,   relHeightMainLegend = c(5, 1),   relHeightDRBar = c(10, 1),   mainNRow = NULL,   mainNCol = NULL,   legendNRow = 1,   ... )"},{"path":"/reference/plotGroupClusterDimRed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comprehensive group splited cluster plot on dimension reduction with\nproportion — plotGroupClusterDimRed","text":"object liger object dimension reduction, grouping variable cluster assignment cellMeta(object). useGroup Variable name group division metadata. Default \"dataset\". useCluster Name variable cellMeta(object). Default NULL uses default cluster. useDimRed Name variable storing dimensionality reduction result cellMeta(object). Default NULL use default dimRed. combinePlot Whether return combined plot. Default TRUE. FALSE, return list containing scatter plots. droplevels Logical, whether perform droplevels() selected grouping variable. Default TRUE show groups listed categories indeed cells. relHeightMainLegend Relative heights main combination panel legend bottom. Must numeric vector 2 numbers. Default c(5, 1). relHeightDRBar Relative heights scatter plot barplot within subpanel. Must numeric vector 2 numbers. Default c(10, 1). mainNRow, mainNCol Arrangement main plotting region, number rows columns. Default NULL automatically handled plot_grid. legendNRow Arrangement legend, number rows. Default 1. ... Additional graphic setting arguments passed plotDimRed.","code":""},{"path":"/reference/plotGroupClusterDimRed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comprehensive group splited cluster plot on dimension reduction with\nproportion — plotGroupClusterDimRed","text":"ggplot object one feature (e.g. cluster variable, gene, factor) set. List object multiple specified.","code":""},{"path":[]},{"path":"/reference/plotGroupClusterDimRed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Comprehensive group splited cluster plot on dimension reduction with\nproportion — plotGroupClusterDimRed","text":"","code":"plotGroupClusterDimRed(pbmcPlot) #> ℹ Plotting feature \"leiden_cluster_ctrl\" on 600 cells #> ✔ Plotting feature \"leiden_cluster_ctrl\" on 600 cells ... done #>  #> ℹ Plotting feature \"leiden_cluster_stim\" on 600 cells #> ✔ Plotting feature \"leiden_cluster_stim\" on 600 cells ... done #>"},{"path":"/reference/plotHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Heatmap of Gene Expression or Factor Loading — plotGeneHeatmap","title":"Plot Heatmap of Gene Expression or Factor Loading — plotGeneHeatmap","text":"Plot Heatmap Gene Expression Factor Loading","code":""},{"path":"/reference/plotHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Heatmap of Gene Expression or Factor Loading — plotGeneHeatmap","text":"","code":"plotGeneHeatmap(   object,   features,   cellIdx = NULL,   slot = c(\"normData\", \"rawData\", \"scaleData\", \"scaleUnsharedData\"),   useCellMeta = NULL,   cellAnnotation = NULL,   featureAnnotation = NULL,   cellSplitBy = NULL,   featureSplitBy = NULL,   viridisOption = \"C\",   ... )  plotFactorHeatmap(   object,   factors = NULL,   cellIdx = NULL,   slot = c(\"H.norm\", \"H\"),   useCellMeta = NULL,   cellAnnotation = NULL,   factorAnnotation = NULL,   cellSplitBy = NULL,   factorSplitBy = NULL,   trim = c(0, 0.03),   viridisOption = \"D\",   ... )"},{"path":"/reference/plotHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Heatmap of Gene Expression or Factor Loading — plotGeneHeatmap","text":"object liger object, data plot available. features, factors Character vector genes interests numeric index factor involved. features required, factors default factors (reads object recorded k value uns slot). cellIdx Valid index subscribe cells included. See subsetLiger. Default NULL use cells. slot Use chosen matrix heatmap. plotGeneHeatmap, default \"normData\", alternatively \"rawData\", \"scaleData\" \"scaleUnsharedData\". plotFactorHeatmap, default \"H.norm\", alternatively \"H\". useCellMeta Character vector available variable names cellMeta, variables added annotation heatmap. Default NULL. cellAnnotation data.frame object using external annotation, column variable row cell. Row names data.frame used matching cells involved heatmap. cells found data.frame, NAs added warning. Default NULL. featureAnnotation, factorAnnotation Similar cellAnnotation, row gene factor, respectively. Default NULL. cellSplitBy Character vector variable names available annotation given useCellMeta cellAnnotation. slices heatmap specified variables. Default NULL. featureSplitBy, factorSplitBy Similar cellSplitBy. Default NULL viridisOption See option argument viridis. Default \"C\" (plasma) plotGeneHeatmap \"D\" (viridis) plotFactorHeatmap. ... Additional arguments passed general function .plotHeatmap Heatmap. trim Numeric vector two numbers. Higher value limits maximum value lower value limits minimum value. Default c(0, 0.03).","code":""},{"path":"/reference/plotHeatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Heatmap of Gene Expression or Factor Loading — plotGeneHeatmap","text":"HeatmapList-class object","code":""},{"path":"/reference/plotHeatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Heatmap of Gene Expression or Factor Loading — plotGeneHeatmap","text":"","code":"plotGeneHeatmap(pbmcPlot, varFeatures(pbmcPlot)) #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>   plotGeneHeatmap(pbmcPlot, varFeatures(pbmcPlot),                 useCellMeta = c(\"leiden_cluster\", \"dataset\"),                 cellSplitBy = \"leiden_cluster\") #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>    plotFactorHeatmap(pbmcPlot)  plotFactorHeatmap(pbmcPlot, cellIdx = pbmcPlot$leiden_cluster %in% 1:3,                   useCellMeta = c(\"leiden_cluster\", \"dataset\"),                   cellSplitBy = \"leiden_cluster\")"},{"path":"/reference/plotMarkerHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create heatmap for showing top marker expression in conditions — plotMarkerHeatmap","title":"Create heatmap for showing top marker expression in conditions — plotMarkerHeatmap","text":"Create heatmap showing top marker expression conditions","code":""},{"path":"/reference/plotMarkerHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create heatmap for showing top marker expression in conditions — plotMarkerHeatmap","text":"","code":"plotMarkerHeatmap(   object,   result,   topN = 5,   lfcThresh = 1,   padjThresh = 0.05,   pctInThresh = 50,   pctOutThresh = 50,   dedupBy = c(\"logFC\", \"padj\"),   groupBy = NULL,   groupSize = 50,   column_title = NULL,   ... )"},{"path":"/reference/plotMarkerHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create heatmap for showing top marker expression in conditions — plotMarkerHeatmap","text":"object liger object, normalized data metadata annotate available. result data.frame returned runMarkerDEG. topN Number top features plot group. Default 5. lfcThresh Hard threshold logFC value. Default 1. padjThresh Hard threshold adjusted P-value. Default 0.05. pctInThresh, pctOutThresh Threshold expression percentage. mean feature pass filter expressed pctInThresh percent cells corresponding cluster. Similarly pctOutThresh. Default 50 percent . dedupBy ranking padj logFC feature ranked top multiple clusters, assign feature marker cluster largest \"logFC\" cluster lowest \"padj\". Default \"logFC\". groupBy Cell metadata variable names cell grouping. Downsample balancing also aware . Default c(\"dataset\", \"leiden_cluster\"). groupSize Maximum number cells group downsampled plotting. Default 50. column_title Title column. Default NULL. ... Parameter passed wrapped functions inheritance order: plotGeneHeatmap, .plotHeatmap, ComplexHeatmap::Heatmap","code":""},{"path":"/reference/plotMarkerHeatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create heatmap for showing top marker expression in conditions — plotMarkerHeatmap","text":"","code":"markerTable <- runMarkerDEG(pbmcPlot) #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  plotMarkerHeatmap(pbmcPlot, markerTable) #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>"},{"path":"/reference/plotProportion.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize proportion across two categorical variables — plotProportion","title":"Visualize proportion across two categorical variables — plotProportion","text":"plotProportionBar creates bar plots comparing cross-category proportion. plotProportionDot creates dot plots. plotClusterProportions variable pre-specified calls dot plot. plotProportion produces combination bar plots dot plot. package \"ggrepel\" installed can help adding tidier percentage annotation pie chart.","code":""},{"path":"/reference/plotProportion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize proportion across two categorical variables — plotProportion","text":"","code":"plotProportion(   object,   class1 = NULL,   class2 = \"dataset\",   method = c(\"stack\", \"group\", \"pie\"),   ... )  plotProportionDot(   object,   class1 = NULL,   class2 = \"dataset\",   showLegend = FALSE,   panelBorder = TRUE,   ... )  plotProportionBar(   object,   class1 = NULL,   class2 = \"dataset\",   method = c(\"stack\", \"group\"),   inclRev = FALSE,   panelBorder = TRUE,   combinePlot = TRUE,   ... )  plotClusterProportions(object, useCluster = NULL, return.plot = FALSE, ...)  plotProportionPie(   object,   class1 = NULL,   class2 = \"dataset\",   labelSize = 4,   labelColor = \"white\",   ... )"},{"path":"/reference/plotProportion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize proportion across two categorical variables — plotProportion","text":"object liger object. class1, class2 single name categorical variable available cellMeta slot. Number cells categories class2 served denominator calculating proportions. default class1 = NULL uses default clusters class2 = \"dataset\". method bar plot, choose whether draw \"stack\" \"group\" bar plot. Default \"stack\". showLegend, panelBorder, ... ggplot theme setting arguments passed .ggplotLigerTheme. inclRev Logical, barplot, whether reverse specification class1 class2 produce two plots. Default FALSE. combinePlot Logical, whether combine two plots plot_grid two plots created. Default TRUE. useCluster plotClusterProportions. class1 class2 hardcoded \"dataset\". return.plot defuncted. labelSize, labelColor Settings pie chart percentage label. Default 4 \"white\".","code":""},{"path":"/reference/plotProportion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize proportion across two categorical variables — plotProportion","text":"ggplot list ggplot","code":""},{"path":"/reference/plotProportion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize proportion across two categorical variables — plotProportion","text":"","code":"plotProportion(pbmcPlot)  plotProportionBar(pbmcPlot, method = \"group\")  plotProportionPie(pbmcPlot)"},{"path":"/reference/plotSankey.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","title":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","text":"Creates riverplot/Sankey diagram show independent cluster assignments two datasets map onto joint clustering. Prior knowledge cell annotation given datasets required make sense visualization. Dataset original annotation can added syntax shown example code manual. joint clustering generated runCluster set metadata annotation. Dataset original annotation can inserted running function using cellMeta<- method. Please see example . function depends CRAN available package \"sankey\" installed order make function work.","code":""},{"path":"/reference/plotSankey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","text":"","code":"plotSankey(   object,   cluster1,   cluster2,   clusterConsensus = NULL,   minFrac = 0.01,   minCell = 10,   titles = NULL,   prefixes = NULL,   labelCex = 1,   titleCex = 1.1,   colorValues = scPalette,   mar = c(2, 2, 4, 2) )"},{"path":"/reference/plotSankey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","text":"object liger object three clustering variables available. cluster1, cluster2 Name variables cellMeta(object) cluster assignments dataset 1 2, respectively. clusterConsensus Name joint cluster variable use. Default uses default clustering object. Can select variable name cellMeta(object). minFrac Numeric. Minimum fraction cluster edge shown. Default 0.05. minCell Numeric. Minimum number cells edge shown. Default 10. titles Character vector three. Customizes column title text shown. Default uses variable names cluster1, clusterConsensus cluster2. prefixes Character vector three. Cluster names unique across three variables, provided deduplicate clusters adding \"prefixes[]-\" actual label. applied duplicate found. Default NULL uses variable names. NA value string character (.e. \"\") add prefix corresponding variable. labelCex Numeric. Amount node label text magnified relative default. Default 1. titleCex Numeric. Amount node label text magnified relative default. Default 1.1. colorValues Character vector color codes set color level consensus clustering. Default scPalette. mar Numeric vector form c(bottom, left, top, right) gives number lines margin specified four sides plot. Increasing 2nd 4th values can helpful cluster labels long extend side plotting region. Default c(2, 2, 4, 2).","code":""},{"path":"/reference/plotSankey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","text":"returned value. sankey diagram displayed instead.","code":""},{"path":"/reference/plotSankey.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","text":"function works replacement function makeRiverplot rliger <1.99. decide make new function dependency adopted older version archived CRAN longer available.","code":""},{"path":"/reference/plotSankey.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make Riverplot/Sankey diagram that shows label mapping across datasets — plotSankey","text":"","code":"# Make fake dataset specific labels from joint clustering result cellMeta(pbmcPlot, \"ctrl_cluster\", \"ctrl\") <-     cellMeta(pbmcPlot, \"leiden_cluster\", \"ctrl\") cellMeta(pbmcPlot, \"stim_cluster\", \"stim\") <-     cellMeta(pbmcPlot, \"leiden_cluster\", \"stim\") plotSankey(pbmcPlot, \"ctrl_cluster\", \"stim_cluster\",            titles = c(\"control\", \"LIGER\", \"stim\"),            prefixes = c(\"c\", NA, \"s\"))"},{"path":"/reference/plotSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a spatial dataset — plotSpatial2D","title":"Visualize a spatial dataset — plotSpatial2D","text":"Visualize spatial dataset","code":""},{"path":"/reference/plotSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a spatial dataset — plotSpatial2D","text":"","code":"plotSpatial2D(object, ...)  # S3 method for liger plotSpatial2D(object, dataset, useCluster = NULL, legendColorTitle = NULL, ...)  # S3 method for ligerSpatialDataset plotSpatial2D(   object,   useCluster = NULL,   legendColorTitle = NULL,   useDims = c(1, 2),   xlab = NULL,   ylab = NULL,   labelText = FALSE,   ... )"},{"path":"/reference/plotSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a spatial dataset — plotSpatial2D","text":"object Either liger object containing spatial dataset ligerSpatialDataset object. ... Arguments passed methods. .liger method passes everything .ligerSpatialDataset method, latter passes everything .ggScatter .ggplotLigerTheme. dataset Name one spatial dataset. useCluster Either name one variable cellMeta(object) factor object annotation matches cells specified dataset. Default NULL uses default clusters. legendColorTitle Alternative title text legend. Default NULL uses variable name set useCluster, \"Annotation\" useCluster customized factor object. useDims Numeric vector two, choosing coordinates drawn 2D space. (STARmap data 3 dimensions.) Default c(1, 2). xlab, ylab Text label x-/y-axis. Default NULL show . labelText Logical, whether label annotation onto scatter plot. Default FALSE.","code":""},{"path":"/reference/plotSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a spatial dataset — plotSpatial2D","text":"ggplot object","code":""},{"path":"/reference/plotSpatial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a spatial dataset — plotSpatial2D","text":"","code":"ctrl.fake.spatial <- as.ligerDataset(dataset(pbmc, \"ctrl\"), modal = \"spatial\") fake.coords <- matrix(rnorm(2 * ncol(ctrl.fake.spatial)), ncol = 2) dimnames(fake.coords) <- list(colnames(ctrl.fake.spatial), c(\"x\", \"y\")) coordinate(ctrl.fake.spatial) <- fake.coords dataset(pbmc, \"ctrl\") <- ctrl.fake.spatial plotSpatial2D(pbmc, dataset = \"ctrl\")"},{"path":"/reference/plotVarFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the variance vs mean of feature expression — plotVarFeatures","title":"Plot the variance vs mean of feature expression — plotVarFeatures","text":"dataset feature variablitity calculated, plot log10 feature expression variance log10 mean produced. Features considered variable highlighted red.","code":""},{"path":"/reference/plotVarFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the variance vs mean of feature expression — plotVarFeatures","text":"","code":"plotVarFeatures(object, combinePlot = TRUE, dotSize = 1, ...)"},{"path":"/reference/plotVarFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the variance vs mean of feature expression — plotVarFeatures","text":"object liger object. selectGenes needs run advance. combinePlot Logical. TRUE, sub-figures datasets combined one plot. FALSE, list plots returned. Default TRUE. dotSize Controls size dots main plot. Default 0.8. ... theme setting parameters passed .ggplotLigerTheme.","code":""},{"path":"/reference/plotVarFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the variance vs mean of feature expression — plotVarFeatures","text":"ggplot object combinePlot = TRUE, list ggplot objects combinePlot = FALSE","code":""},{"path":"/reference/plotVarFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the variance vs mean of feature expression — plotVarFeatures","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. plotVarFeatures(pbmc)"},{"path":"/reference/plotViolin.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize gene expression or cell metadata with violin plot — plotGeneViolin","title":"Visualize gene expression or cell metadata with violin plot — plotGeneViolin","text":"Visualize gene expression cell metadata violin plot","code":""},{"path":"/reference/plotViolin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize gene expression or cell metadata with violin plot — plotGeneViolin","text":"","code":"plotGeneViolin(object, gene, byDataset = TRUE, groupBy = NULL, ...)  plotTotalCountViolin(object, groupBy = \"dataset\", ...)  plotGeneDetectedViolin(object, groupBy = \"dataset\", ...)"},{"path":"/reference/plotViolin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize gene expression or cell metadata with violin plot — plotGeneViolin","text":"object liger object. gene Character gene names. byDataset Logical, whether violin plot splitted dataset. Default TRUE. groupBy Names available categorical variable cellMeta slot. Use FALSE grouping. Default NULL looks clustering result group clustering found. ... Additional arguments passed plotCellViolin.","code":""},{"path":"/reference/plotViolin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize gene expression or cell metadata with violin plot — plotGeneViolin","text":"ggplot using single gene splitting dataset. Otherwise, list ggplot.","code":""},{"path":"/reference/plotViolin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize gene expression or cell metadata with violin plot — plotGeneViolin","text":"","code":"plotGeneViolin(pbmcPlot, varFeatures(pbmcPlot)[1],                groupBy = \"leiden_cluster\") #> $ISG15.ctrl  #>  #> $ISG15.stim  #>  plotTotalCountViolin(pbmc)  plotGeneDetectedViolin(pbmc, dot = TRUE, box = TRUE, colorBy = \"dataset\") #> Warning: Duplicated `override.aes` is ignored."},{"path":"/reference/plotVolcano.html","id":null,"dir":"Reference","previous_headings":"","what":"Create volcano plot for Wilcoxon test result — plotVolcano","title":"Create volcano plot for Wilcoxon test result — plotVolcano","text":"plotVolcano simple implementation shares arguments rliger plotting functions. plotEnhancedVolcano wrapper function EnhancedVolcano, provides substantial amount arguments graphical control. However, requires installation package \"EnhancedVolcano\".","code":""},{"path":"/reference/plotVolcano.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create volcano plot for Wilcoxon test result — plotVolcano","text":"","code":"plotVolcano(   result,   group,   logFCThresh = 1,   padjThresh = 0.01,   labelTopN = 20,   dotSize = 2,   dotAlpha = 0.8,   legendPosition = \"top\",   labelSize = 4,   ... )  plotEnhancedVolcano(result, group, ...)"},{"path":"/reference/plotVolcano.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create volcano plot for Wilcoxon test result — plotVolcano","text":"result Data frame table returned runWilcoxon group Selection one group available result$group logFCThresh Number threshold absolute value log2 fold change statistics. Default 1. padjThresh Number threshold adjusted p-value statistics. Default 0.01. labelTopN Number top differential expressed features labeled top dots. Default 20. dotSize, dotAlpha Numbers universal aesthetics control dots. Default 2 0.8. legendPosition Text indicating place legend. Choose \"top\", \"bottom\", \"left\" \"right\". Default \"top\". labelSize Size labeled top features line annotations. Default 4. ... plotVolcano, theme setting arguments passed .ggplotLigerTheme. plotEnhancedVolcano, arguments passed EnhancedVolcano.","code":""},{"path":"/reference/plotVolcano.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create volcano plot for Wilcoxon test result — plotVolcano","text":"ggplot","code":""},{"path":"/reference/plotVolcano.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create volcano plot for Wilcoxon test result — plotVolcano","text":"","code":"result <- runMarkerDEG(pbmcPlot) #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  plotVolcano(result, 1) #> Warning: Removed 1 rows containing missing values (`geom_text_repel()`)."},{"path":"/reference/quantileAlignSNF.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile align (normalize) factor loadings — quantileAlignSNF","title":"Quantile align (normalize) factor loadings — quantileAlignSNF","text":"deprecated function. Calling 'quantileNorm' instead.","code":""},{"path":"/reference/quantileAlignSNF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile align (normalize) factor loadings — quantileAlignSNF","text":"","code":"quantileAlignSNF(   object,   knn_k = 20,   k2 = 500,   prune.thresh = 0.2,   ref_dataset = NULL,   min_cells = 20,   quantiles = 50,   nstart = 10,   resolution = 1,   dims.use = 1:ncol(x = object@H[[1]]),   dist.use = \"CR\",   center = FALSE,   small.clust.thresh = 0,   id.number = NULL,   print.mod = FALSE,   print.align.summary = FALSE )"},{"path":"/reference/quantileAlignSNF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile align (normalize) factor loadings — quantileAlignSNF","text":"object liger object. run optimizeALS calling. knn_k Number nearest neighbors within-dataset knn graph (default 20). k2 Horizon parameter shared nearest factor graph. Distances k2 nearest neighbors set 0 (cuts memory usage large graphs). (default 500) prune.thresh Minimum allowed edge weight. edges removed (given weight 0) (default 0.2) ref_dataset Name dataset use \"reference\" normalization. default, dataset largest number cells used. min_cells Minimum number cells consider cluster shared across datasets (default 2) quantiles Number quantiles use quantile normalization (default 50). nstart Number times perform Louvain community detection different random starts (default 10). resolution Controls number communities detected. Higher resolution -> communities. (default 1) dims.use Indices factors use shared nearest factor determination (default 1:ncol(H[[1]])). dist.use Distance metric use calculating nearest neighbors (default \"CR\"). center Centers data scaling factors (useful less sparse modalities like methylation data). (default FALSE) small.clust.thresh Extracts small clusters loading highly single factor fewer cells regular alignment (default 0 -- small cluster extraction). id.number Number use identifying edge file (running parallel) (generates random value default). print.mod Print modularity output clustering algorithm (default FALSE). print.align.summary Print summary clusters align normally (default FALSE).","code":""},{"path":"/reference/quantileAlignSNF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile align (normalize) factor loadings — quantileAlignSNF","text":"liger object H.norm cluster slots set.","code":""},{"path":"/reference/quantileAlignSNF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile align (normalize) factor loadings — quantileAlignSNF","text":"process builds shared factor neighborhood graph jointly cluster cells, quantile normalizes corresponding clusters. first step, building shared factor neighborhood graph, performed SNF(), produces graph representation edge weights cells (across datasets) correspond similarity shared factor neighborhood space. important parameter knn_k, number neighbors used build shared factor space (see SNF()). Afterwards, modularity-based community detection performed graph (Louvain clustering) order identify shared clusters across datasets. method first developed Waltman van Eck (2013) source code available http://www.ludowaltman.nl/slm/. important parameter resolution, corresponds number communities detected. Next perform quantile alignment dataset, factor, cluster (stretching/compressing datasets' quantiles better match reference dataset). aligned factor loadings combined single matrix returned H.norm.","code":""},{"path":"/reference/quantileAlignSNF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile align (normalize) factor loadings — quantileAlignSNF","text":"","code":"if (FALSE) { # liger object, factorization complete ligerex # do basic quantile alignment ligerex <- quantileAlignSNF(ligerex) # higher resolution for more clusters (note that SNF is conserved) ligerex <- quantileAlignSNF(ligerex, resolution = 1.2) # change knn_k for more fine-grained local clustering ligerex <- quantileAlignSNF(ligerex, knn_k = 15, resolution = 1.2) }"},{"path":"/reference/quantileNorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Align (Normalize) Factor Loadings — quantileNorm","title":"Quantile Align (Normalize) Factor Loadings — quantileNorm","text":"process builds shared factor neighborhood graph jointly cluster cells, quantile normalizes corresponding clusters. first step, building shared factor neighborhood graph, performed SNF(), produces graph representation edge weights cells (across datasets) correspond similarity shared factor neighborhood space. important parameter nNeighbors, number neighbors used build shared factor space. Next perform quantile alignment dataset, factor, cluster (stretching/compressing datasets' quantiles better match reference dataset).","code":""},{"path":"/reference/quantileNorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Align (Normalize) Factor Loadings — quantileNorm","text":"","code":"quantileNorm(object, ...)  # S3 method for liger quantileNorm(   object,   quantiles = 50,   reference = NULL,   minCells = 20,   nNeighbors = 20,   useDims = NULL,   center = FALSE,   maxSample = 1000,   eps = 0.9,   refineKNN = TRUE,   clusterName = \"quantileNorm_cluster\",   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for Seurat quantileNorm(   object,   reduction = \"inmf\",   quantiles = 50,   reference = NULL,   minCells = 20,   nNeighbors = 20,   useDims = NULL,   center = FALSE,   maxSample = 1000,   eps = 0.9,   refineKNN = TRUE,   clusterName = \"quantileNorm_cluster\",   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/quantileNorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Align (Normalize) Factor Loadings — quantileNorm","text":"object liger Seurat object valid factorization result available (.e. runIntegration performed advance). ... Arguments passed S3 methods function. quantiles Number quantiles use quantile normalization. Default 50. reference Character, numeric logical selection one dataset, available datasets object, use \"reference\" normalization. Default NULL use dataset largest number cells. minCells Minimum number cells consider cluster shared across datasets. Default 20. nNeighbors Number nearest neighbors within-dataset knn graph. Default 20. useDims Indices factors use shared nearest factor determination. Default NULL uses factors. center Whether center data scaling factors. useful less sparse modalities like methylation data. Default FALSE. maxSample Maximum number cells used quantile normalization cluster factor. Default 1000. eps error bound nearest neighbor search. Lower values give accurate nearest neighbor graphs take much longer compute. Default 0.9. refineKNN whether increase robustness cluster assignments using KNN graph. Default TRUE. clusterName Variable name store clustering result metadata liger object Seurat object. Default \"quantileNorm_cluster\" seed Random seed allow reproducible results. Default 1. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. reduction Name reduction LIGER integration result stored. Default \"inmf\".","code":""},{"path":"/reference/quantileNorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Align (Normalize) Factor Loadings — quantileNorm","text":"Updated input object liger method Update H.norm slot alignment cell factor          loading, ready running graph based community detection          clustering dimensionality reduction visualization. Update cellMata slot cluster assignment basing          cell factor loading Seurat method Update reductions slot new DimReduc          object containing aligned cell factor loading. Update metadata cluster assignment basing cell          factor loading","code":""},{"path":"/reference/quantileNorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Align (Normalize) Factor Loadings — quantileNorm","text":"","code":"pbmc <- quantileNorm(pbmcPlot)"},{"path":"/reference/quantile_norm-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] Quantile align (normalize) factor loading — quantile_norm-deprecated","title":"[Deprecated] Quantile align (normalize) factor loading — quantile_norm-deprecated","text":"Please turn quantileNorm. process builds shared factor neighborhood graph jointly cluster cells, quantile normalizes corresponding clusters. first step, building shared factor neighborhood graph, performed SNF(), produces graph representation edge weights cells (across datasets) correspond similarity shared factor neighborhood space. important parameter knn_k, number neighbors used build shared factor space. Next perform quantile alignment dataset, factor, cluster (stretching/compressing datasets' quantiles better match reference dataset). aligned factor loadings combined single matrix returned H.norm.","code":""},{"path":"/reference/quantile_norm-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] Quantile align (normalize) factor loading — quantile_norm-deprecated","text":"object liger object. run optimizeALS calling. knn_k Number nearest neighbors within-dataset knn graph (default 20). ref_dataset Name dataset use \"reference\" normalization. default, dataset largest number cells used. min_cells Minimum number cells consider cluster shared across datasets (default 20) quantiles Number quantiles use quantile normalization (default 50). eps error bound nearest neighbor search. (default 0.9) Lower values give accurate nearest neighbor graphs take much longer computer. dims.use Indices factors use shared nearest factor determination (default 1:ncol(H[[1]])). .center Centers data scaling factors (useful less sparse modalities like methylation data). (default FALSE) max_sample Maximum number cells used quantile normalization cluster factor. (default 1000) refine.knn whether increase robustness cluster assignments using KNN graph.(default TRUE) rand.seed Random seed allow reproducible results (default 1)","code":""},{"path":"/reference/quantile_norm-deprecated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] Quantile align (normalize) factor loading — quantile_norm-deprecated","text":"liger object 'H.norm' 'clusters' slot set.","code":""},{"path":[]},{"path":"/reference/read10X.html","id":null,"dir":"Reference","previous_headings":"","what":"Load in data from 10X — read10X","title":"Load in data from 10X — read10X","text":"Enables easy loading sparse data matrices provided 10X genomics. read10X works generally 10X cellranger pipelines including: CellRanger < 3.0 & >= 3.0 CellRanger-ARC. read10XRNA invokes read10X takes \"Gene Expression\" , result can directly used construct liger object. See Examples demonstration. read10XATAC works cellRanger-ARC cellRanger-ATAC pipelines needs user arguments correct recognition. Similarly, returned value can directly used constructing liger object.","code":""},{"path":"/reference/read10X.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load in data from 10X — read10X","text":"","code":"read10X(   path,   sampleNames = NULL,   useFiltered = NULL,   reference = NULL,   geneCol = 2,   cellCol = 1,   returnList = FALSE,   verbose = getOption(\"ligerVerbose\", TRUE),   sample.dirs = path,   sample.names = sampleNames,   use.filtered = useFiltered,   data.type = NULL,   merge = NULL,   num.cells = NULL,   min.umis = NULL )  read10XRNA(   path,   sampleNames = NULL,   useFiltered = NULL,   reference = NULL,   returnList = FALSE,   ... )  read10XATAC(   path,   sampleNames = NULL,   useFiltered = NULL,   pipeline = c(\"atac\", \"arc\"),   arcFeatureType = \"Peaks\",   returnList = FALSE,   geneCol = 2,   cellCol = 1,   verbose = getOption(\"ligerVerbose\", TRUE) )"},{"path":"/reference/read10X.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load in data from 10X — read10X","text":"path [.] Directory containing matrix.mtx, genes.tsv (features.tsv), barcodes.tsv files provided 10X. vector, named vector, list named list can given order load several data directories. [B.] 10X root directory subdirectories per-sample output folders can found. Sample names default take name vector, list subfolders. sampleNames vector names override detected set sample names given path. Default NULL. name detected multiple samples given, name numbers. useFiltered Logical, path given case B, whether use filtered feature barcode matrix instead raw (unfiltered). Default TRUE. reference case specifying CellRanger<3 root folder path, import matrix output using reference. needed multiple references present. Default NULL. geneCol Specify column genes.tsv features.tsv use gene names. Default 2. cellCol Specify column barcodes.tsv use cell names. Default 1. returnList Logical, whether still return structured list instead single matrix object, case one sample one feature type can found. Otherwise always return list. Default FALSE. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. sample.dirs, sample.names, use.filtered arguments renamed deprecated future. Please see usage corresponding arguments. data.type, merge, num.cells, min.umis arguments defuncted functionality can/fulfilled functions. ... Arguments passed read10X pipeline cellRanger pipeline type find ATAC data. Choose \"atac\" read peak matrix cellranger-atac pipeline output folder(s), \"arc\" split ATAC feature subset multiomic cellranger-arc pipeline output folder(s). Default \"atac\". arcFeatureType pipeline = \"arc\", feature type ATAC data interests. Default \"Peaks\". possible feature types can \"Chromatin Accessibility\". Error message show available options argument specification found.","code":""},{"path":"/reference/read10X.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load in data from 10X — read10X","text":"one sample given detected, one feature type  detected using CellRanger < 3.0, returnList = FALSE,  sparse matrix object (dgCMatrix class) returned. using read10XRNA read10XATAC, modality  specific, returns list named samples, element  corresponding sparse matrix object (dgCMatrix class). read10X generally returns list named samples. sample  element another list named feature types even one feature  type detected (using CellRanger < 3.0) data structure consistency.  feature type \"Gene Expression\" always comes first type  available.","code":""},{"path":"/reference/read10X.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load in data from 10X — read10X","text":"","code":"if (FALSE) { # For output from CellRanger < 3.0 dir <- 'path/to/data/directory' list.files(dir) # Should show barcodes.tsv, genes.tsv, and matrix.mtx mat <- read10X(dir) class(mat) # Should show dgCMatrix  # For root directory from CellRanger < 3.0 dir <- 'path/to/root' list.dirs(dir) # Should show sample names matList <- read10X(dir) names(matList) # Should show the sample names class(matList[[1]][[\"Gene Expression\"]]) # Should show dgCMatrix  # For output from CellRanger >= 3.0 with multiple data types dir <- 'path/to/data/directory' list.files(dir) # Should show barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz matList <- read10X(dir, sampleNames = \"tissue1\") names(matList) # Shoud show \"tissue1\" names(matList$tissue1) # Should show feature types, e.g. \"Gene Expression\" and etc.  # For root directory from CellRanger >= 3.0 with multiple data types dir <- 'path/to/root' list.dirs(dir) # Should show sample names, e.g. \"rep1\", \"rep2\", \"rep3\" matList <- read10X(dir) names(matList) # Should show the sample names: \"rep1\", \"rep2\", \"rep3\" names(matList$rep1) # Should show the avalable feature types for rep1 } if (FALSE) { # For creating LIGER object from root directory of CellRanger >= 3.0 dir <- 'path/to/root' list.dirs(dir) # Should show sample names, e.g. \"rep1\", \"rep2\", \"rep3\" matList <- read10XRNA(dir) names(matList) # Should show the sample names: \"rep1\", \"rep2\", \"rep3\" sapply(matList, class) # Should show matrix class all are \"dgCMatrix\" lig <- createLigerObject(matList) }"},{"path":"/reference/readLiger.html","id":null,"dir":"Reference","previous_headings":"","what":"Read liger object from RDS file — readLiger","title":"Read liger object from RDS file — readLiger","text":"file reads liger object stored RDS files kinds types. 1. liger object -memory data created package version since 1.99. 2. liger object -disk H5 data associated, link H5 files automatically restored. 3. liger object created older package version, can updated latest data structure default.","code":""},{"path":"/reference/readLiger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read liger object from RDS file — readLiger","text":"","code":"readLiger(   filename,   dimredName = \"tsne_coords\",   clusterName = \"clusters\",   h5FilePath = NULL,   update = TRUE )"},{"path":"/reference/readLiger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read liger object from RDS file — readLiger","text":"filename Path RDS file liger object old versions. dimredName name variable cellMeta slot store dimensionality reduction matrix, originally located tsne.coords slot. Default \"tsne.coords\". clusterName name variable cellMeta slot store clustering assignment, originally located clusters slot. Default \"clusters\". h5FilePath Named list, specify path H5 file dataset location changed. Default NULL looks file paths stored object. update Logical, whether update old (<=1.0.0) liger object currect version structure. Default TRUE.","code":""},{"path":"/reference/readLiger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read liger object from RDS file — readLiger","text":"New version liger object","code":""},{"path":"/reference/readLiger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read liger object from RDS file — readLiger","text":"","code":"# Save and read regular current-version liger object tempPath <- tempfile(fileext = \".rds\") saveRDS(pbmc, tempPath) pbmc <- readLiger(tempPath)  # Save and read H5-based liger object h5Path <- system.file(\"extdata/ctrl.h5\", package = \"rliger\") lig <- createLiger(list(ctrl = h5Path)) #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> ℹ calculating QC for dataset \"ctrl\" #>  #> ✔ calculating QC for dataset \"ctrl\" ... done #>  tempPath <- tempfile(fileext = \".rds\") saveRDS(lig, tempPath) lig <- readLiger(tempPath) #> ℹ Restoring dataset \"ctrl\" #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> ✔ Restoring dataset \"ctrl\" ... done #>"},{"path":"/reference/readSubset.html","id":null,"dir":"Reference","previous_headings":"","what":"[Deprecated] See downsample — readSubset","title":"[Deprecated] See downsample — readSubset","text":"function mainly aims downsampling datasets size suitable plotting.","code":""},{"path":"/reference/readSubset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"[Deprecated] See downsample — readSubset","text":"","code":"readSubset(   object,   slot.use = \"normData\",   balance = NULL,   max.cells = 1000,   chunk = 1000,   datasets.use = NULL,   genes.use = NULL,   rand.seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE) )"},{"path":"/reference/readSubset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"[Deprecated] See downsample — readSubset","text":"object liger object slot.use create subset one \"rawData\", \"normData\" \"scaleData\". Default NULL subsets whole object including downstream results. balance \"\" sampling maxCells cells datasets specified useDatasets. \"cluster\" sampling maxCells cells per cluster per dataset. \"dataset\" maxCells cells per dataset. max.cells Max number cells sample grouping based balance. chunk Integer. Number maximum number cells chunk, Default 1000. datasets.use Index selection datasets consider. Default NULL using datasets. genes.use Character vector. Subset features specified range. Default NULL subset features. rand.seed Random seed reproducibility. Default 1. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set.","code":""},{"path":"/reference/readSubset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"[Deprecated] See downsample — readSubset","text":"Subset liger  object.","code":""},{"path":[]},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. magrittr %>%","code":""},{"path":"/reference/removeMissing.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove missing cells or features from liger object — removeMissing","title":"Remove missing cells or features from liger object — removeMissing","text":"Remove missing cells features liger object","code":""},{"path":"/reference/removeMissing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove missing cells or features from liger object — removeMissing","text":"","code":"removeMissing(   object,   orient = c(\"both\", \"feature\", \"cell\"),   minCells = NULL,   minFeatures = NULL,   useDatasets = NULL,   newH5 = TRUE,   filenameSuffix = \"removeMissing\",   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  removeMissingObs(   object,   slot.use = NULL,   use.cols = TRUE,   verbose = getOption(\"ligerVerbose\", TRUE) )"},{"path":"/reference/removeMissing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove missing cells or features from liger object — removeMissing","text":"object liger object orient Choose remove non-expressing features (\"feature\"), empty barcodes (\"cell\"), (\"\"). Default \"\". minCells Keep features expressed least number cells, calculated per-dataset base. single value datasets vector dataset. Default NULL removes none expressing features. minFeatures Keep cells express least number features, calculated per-dataset base. single value datasets vector dataset. Default NULL removes none expressing cells. useDatasets character vector names, numeric logical vector index datasets processed. Default NULL removes empty entries datasets. newH5 Logical, whether create new H5 file disk H5-based dataset subset. Default TRUE filenameSuffix subsetting H5-based datasets new H5 files, suffix added filenames. Default \"removeMissing\". verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. ... Arguments passed subsetLigerDataset slot.use Deprecated. Always look rawData slot inner ligerDataset objects. use.cols Deprecated. Previously means \"treating column cell\" TRUE, now means orient=\"cell\".","code":""},{"path":"/reference/removeMissing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove missing cells or features from liger object — removeMissing","text":"Updated (subset) object.","code":""},{"path":"/reference/removeMissing.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Remove missing cells or features from liger object — removeMissing","text":"removeMissingObs deprecated. removeMissing covers expands use case easier understand.","code":""},{"path":"/reference/removeMissing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove missing cells or features from liger object — removeMissing","text":"","code":"# The example dataset does not contain non-expressing genes or empty barcodes pbmc <- removeMissing(pbmc)"},{"path":"/reference/restoreH5Liger.html","id":null,"dir":"Reference","previous_headings":"","what":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","title":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","text":"loading saved liger object HDF5 data new R session, links HDF5 files closed. function enables restoration links new analyses can carried .","code":""},{"path":"/reference/restoreH5Liger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","text":"","code":"restoreH5Liger(object, filePath = NULL)  restoreOnlineLiger(object, file.path = NULL)"},{"path":"/reference/restoreH5Liger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","text":"object liger ligerDataset object. filePath Paths HDF5 files. single character path ligerDataset input list paths named datasets liger object input. Default NULL looks path(s) last valid loading. file.path deprecated restoreOnlineLiger. filePath.","code":""},{"path":"/reference/restoreH5Liger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","text":"object restored links.","code":""},{"path":"/reference/restoreH5Liger.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","text":"restoreOnlineLiger deprecated clarifying terms used data structure.","code":""},{"path":"/reference/restoreH5Liger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restore links (to HDF5 files) for reloaded liger/ligerDataset object — restoreH5Liger","text":"","code":"h5Path <- system.file(\"extdata/ctrl.h5\", package = \"rliger\") lig <- createLiger(list(ctrl = h5Path)) #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> ℹ calculating QC for dataset \"ctrl\" #>  #> ✔ calculating QC for dataset \"ctrl\" ... done #>  # Now it is actually an invalid object! which is equivalent to what users # will get with `saveRDS(lig, \"object.rds\"); lig <- readRDS(\"object.rds\")`` lig <- closeAllH5(lig) lig <- restoreH5Liger(lig) #> ℹ Restoring dataset \"ctrl\" #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> ℹ Restoring HDF5 link from: /private/var/folders/k9/nwtr_c_57kd43cmbtz82ywlr000… #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> Found more than one class \"H5D\" in cache; using the first, from namespace 'rliger' #> Also defined by ‘hdf5r’ #> ✔ Restoring HDF5 link from: /private/var/folders/k9/nwtr_c_57kd43cmbtz82ywlr000… #>  #> ℹ Restoring dataset \"ctrl\" #> ✔ Restoring dataset \"ctrl\" ... done #>"},{"path":"/reference/retrieveCellFeature.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve a single matrix of cells from a slot — retrieveCellFeature","title":"Retrieve a single matrix of cells from a slot — retrieveCellFeature","text":"retrieve data specific slot reduce memory used whole liger object subset. Useful plotting. Internally used plotDimRed plotCellViolin.","code":""},{"path":"/reference/retrieveCellFeature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve a single matrix of cells from a slot — retrieveCellFeature","text":"","code":"retrieveCellFeature(   object,   feature,   slot = c(\"rawData\", \"normData\", \"scaleData\", \"H\", \"H.norm\", \"cellMeta\", \"rawPeak\",     \"normPeak\"),   cellIdx = NULL,   ... )"},{"path":"/reference/retrieveCellFeature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve a single matrix of cells from a slot — retrieveCellFeature","text":"object liger object feature Gene names, factor index cell metadata variable names. available specified slot. slot Exactly choose \"rawData\", \"normData\", \"scaleData\", \"H\", \"H.norm\" \"cellMeta\". cellIdx valid type index subset cells. Default NULL uses cells. ... Additional arguments passed subsetLiger slot one \"rawData\", \"normData\" \"scaleData\".","code":""},{"path":"/reference/retrieveCellFeature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve a single matrix of cells from a slot — retrieveCellFeature","text":"matrix object rows cells columns specified features.","code":""},{"path":"/reference/retrieveCellFeature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve a single matrix of cells from a slot — retrieveCellFeature","text":"","code":"S100A8Exp <- retrieveCellFeature(pbmc, \"S100A8\") #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>  qcMetrics <- retrieveCellFeature(pbmc, c(\"nUMI\", \"nGene\", \"mito\"),                                  slot = \"cellMeta\")"},{"path":"/reference/reverseMethData.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ","title":"Create ","text":"gene body mCH proportions negatively correlated gene expression level neurons, need reverse direction methylation data. simply subtracting values maximum methylation value. resulting values positively correlated gene expression. applied variable genes detected prior.","code":""},{"path":"/reference/reverseMethData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ","text":"","code":"reverseMethData(object, useDatasets, verbose = getOption(\"ligerVerbose\", TRUE))"},{"path":"/reference/reverseMethData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ","text":"object liger object, variable genes identified. useDatasets Required. character vector names, numeric logical vector index datasets identified methylation data reversed data created. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set.","code":""},{"path":"/reference/reverseMethData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ","text":"input liger object, scaleData slot specified datasets updated value described Description.","code":""},{"path":"/reference/reverseMethData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ","text":"","code":"# Assuming the second dataset in example data \"pbmc\" is methylation data pbmc <- normalize(pbmc, useDatasets = 1) #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc, datasets.use = 1) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ✔ Finally 168 shared variable features are selected. pbmc <- scaleNotCenter(pbmc, useDatasets = 1) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  pbmc <- reverseMethData(pbmc, useDatasets = 2) #> ℹ Substracting methylation data: \"stim\""},{"path":"/reference/rliger-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated functions in package rliger. — makeInteractTrack","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"functions listed deprecated defunct   near future. possible, alternative functions similar   functionality replacement also mentioned. Help pages   deprecated functions available help(\"<function>-deprecated\").","code":""},{"path":"/reference/rliger-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"","code":"makeInteractTrack(   corr.mat,   path_to_coords,   genes.list = NULL,   output_path = getwd() )  louvainCluster(   object,   resolution = 1,   k = 20,   prune = 1/15,   eps = 0.1,   nRandomStarts = 10,   nIterations = 100,   random.seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE),   dims.use = NULL )  optimizeALS(   object,   k,   lambda = 5,   thresh = NULL,   max.iters = 30,   nrep = 1,   H.init = NULL,   W.init = NULL,   V.init = NULL,   use.unshared = FALSE,   rand.seed = 1,   print.obj = NULL,   verbose = TRUE,   ... )  online_iNMF(   object,   X_new = NULL,   projection = FALSE,   W.init = NULL,   V.init = NULL,   H.init = NULL,   A.init = NULL,   B.init = NULL,   k = 20,   lambda = 5,   max.epochs = 5,   miniBatch_max_iters = 1,   miniBatch_size = 5000,   h5_chunk_size = 1000,   seed = 123,   verbose = TRUE )  quantile_norm(   object,   quantiles = 50,   ref_dataset = NULL,   min_cells = 20,   knn_k = 20,   dims.use = NULL,   do.center = FALSE,   max_sample = 1000,   eps = 0.9,   refine.knn = TRUE,   clusterName = \"H.norm_cluster\",   rand.seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE) )  makeRiverplot(   object,   cluster1,   cluster2,   cluster_consensus = NULL,   min.frac = 0.05,   min.cells = 10,   river.yscale = 1,   river.lty = 0,   river.node_margin = 0.1,   label.cex = 1,   label.col = \"black\",   lab.srt = 0,   river.usr = NULL,   node.order = \"auto\" )"},{"path":"/reference/rliger-deprecated.html","id":"makeinteracttrack","dir":"Reference","previous_headings":"","what":"makeInteractTrack","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"makeInteractTrack, use exportInteractTrack.","code":""},{"path":"/reference/rliger-deprecated.html","id":"louvaincluster","dir":"Reference","previous_headings":"","what":"louvainCluster","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"louvainCluster, use runCluster(method = \"louvain\") replacement, runCluster default method = \"leiden\" recommended.","code":""},{"path":"/reference/rliger-deprecated.html","id":"optimizeals","dir":"Reference","previous_headings":"","what":"optimizeALS","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"optimizeALS, use runIntegration runINMF. case optimizeALS(use.unshared = TRUE), use runIntegration method = \"UINMF\" runUINMF instead.","code":""},{"path":"/reference/rliger-deprecated.html","id":"online-inmf","dir":"Reference","previous_headings":"","what":"online_iNMF","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"online_iNMF, use runIntegration method = \"online\" runOnlineINMF.","code":""},{"path":"/reference/rliger-deprecated.html","id":"quantile-norm","dir":"Reference","previous_headings":"","what":"quantile_norm","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"quantile_norm, use quantileNorm.","code":""},{"path":"/reference/rliger-deprecated.html","id":"makeriverplot","dir":"Reference","previous_headings":"","what":"makeRiverplot","title":"Deprecated functions in package rliger. — makeInteractTrack","text":"makeRiverplot, use plotSankey replacement.","code":""},{"path":"/reference/runCINMF.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform consensus iNMF on scaled datasets — runCINMF","title":"Perform consensus iNMF on scaled datasets — runCINMF","text":"Performs consensus integrative non-negative matrix factorization (c-iNMF) return factorized \\(H\\), \\(W\\), \\(V\\) matrices. run regular iNMF multiple times different random starts, take consensus frequently appearing factors gene loading matrices, \\(W\\) \\(V\\). cell factor loading \\(H\\) matrices eventually solved consensus \\(W\\) \\(V\\) matrices. Please see runINMF detailed introduction regular iNMF algorithm run multiple times function. consensus iNMF algorithm developed basing consensus NMF (cNMF) method (D. Kotliar et al., 2019).","code":""},{"path":"/reference/runCINMF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform consensus iNMF on scaled datasets — runCINMF","text":"","code":"runCINMF(object, k = 20, lambda = 5, rho = 0.3, ...)  # S3 method for liger runCINMF(   object,   k = 20,   lambda = 5,   rho = 0.3,   nIteration = 30,   nRandomStarts = 10,   HInit = NULL,   WInit = NULL,   VInit = NULL,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for Seurat runCINMF(   object,   k = 20,   lambda = 5,   rho = 0.3,   datasetVar = \"orig.ident\",   layer = \"ligerScaleData\",   assay = NULL,   reduction = \"cinmf\",   nIteration = 30,   nRandomStarts = 10,   HInit = NULL,   WInit = NULL,   VInit = NULL,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/runCINMF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform consensus iNMF on scaled datasets — runCINMF","text":"object liger object Seurat object non-negative scaled data variable features (Done scaleNotCenter). k Inner dimension factorization (number factors). Generally, higher k needed datasets sub-structure. Default 20. lambda Regularization parameter. Larger values penalize dataset-specific effects strongly (.e. alignment increase lambda increases). Default 5. rho Numeric number 0 1. Fraction determining number nearest neighbors look consensus (rho * nRandomStarts). Default 0.3. ... Arguments passed methods. nIteration Total number block coordinate descent iterations perform. Default 30. nRandomStarts Number replicate runs creating pool factorization results. Default 10. HInit Initial values use \\(H\\) matrices. list object element initial \\(H\\) matrix dataset. Default NULL. WInit Initial values use \\(W\\) matrix. matrix object. Default NULL. VInit Initial values use \\(V\\) matrices. list object element initial \\(V\\) matrix dataset. Default NULL. seed Random seed allow reproducible results. Default 1. nCores number parallel tasks speed computation. Default 2L. supported platform OpenMP support. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. datasetVar Metadata variable name stores dataset source annotation. Default \"orig.ident\". layer Seurat>=4.9.9, name layer retrieve input non-negative scaled data. Default \"ligerScaleData\". older Seurat, always retrieve scale.data slot. assay Name assay use. Default NULL uses current active assay. reduction Name reduction store result. Also used feature key. Default \"cinmf\".","code":""},{"path":"/reference/runCINMF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform consensus iNMF on scaled datasets — runCINMF","text":"liger method - Returns updated input liger object list \\(H\\) matrices can accessed          getMatrix(object, \"H\") list \\(V\\) matrices can accessed          getMatrix(object, \"V\") \\(W\\) matrix can accessed          getMatrix(object, \"W\") Seurat method - Returns updated input Seurat object \\(H\\) matrices datasets concatenated          transposed (cells k), form DimReduc object          reductions slot named argument reduction. \\(W\\) matrix presented feature.loadings          DimReduc object. \\(V\\) matrices, objective error value dataset          variable used factorization currently stored          misc slot DimReduc object.","code":""},{"path":"/reference/runCINMF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform consensus iNMF on scaled datasets — runCINMF","text":"Joshua D. Welch et al., Single-Cell Multi-omic Integration Compares Contrasts Features Brain Cell Identity, Cell, 2019 Dylan Kotliar et al., Identifying gene expression programs cell-type identity cellular activity single-cell RNA-Seq, eLife, 2019","code":""},{"path":"/reference/runCINMF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform consensus iNMF on scaled datasets — runCINMF","text":"","code":"# \\donttest{ pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     pbmc <- runCINMF(pbmc) } #> Replicating iNMF runs ■■■■■■■■■■■■■■■■                  50% | [ 5 / 10 ] ETA:  … #> Replicating iNMF runs ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | [ 10 / 10 ] ETA: … #> ℹ Taking the consensus #> ✔ Taking the consensus ... done #>  #> ℹ ANLS optimization with consensus fixed #> ✔ ANLS optimization with consensus fixed  ... objective error: 35793.3194637341 #>  # }"},{"path":"/reference/runCluster.html","id":null,"dir":"Reference","previous_headings":"","what":"SNN Graph Based Community Detection — runCluster","title":"SNN Graph Based Community Detection — runCluster","text":"quantile normalization, users can additionally run Leiden Louvain algorithm community detection, widely used single-cell analysis excels merging small clusters broad cell classes. using quantile normalized factor loadings (result quantileNorm) recommended, function looks unnormalized factor loadings (result runIntegration) former available.","code":""},{"path":"/reference/runCluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SNN Graph Based Community Detection — runCluster","text":"","code":"runCluster(   object,   resolution = 1,   nNeighbors = 20,   prune = 1/15,   eps = 0.1,   nRandomStarts = 10,   nIterations = 5,   method = c(\"leiden\", \"louvain\"),   useRaw = NULL,   useDims = NULL,   groupSingletons = TRUE,   clusterName = paste0(method, \"_cluster\"),   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE) )"},{"path":"/reference/runCluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SNN Graph Based Community Detection — runCluster","text":"object liger object. valid factorization result available. resolution Numeric, value resolution parameter, larger value results larger number communities smaller sizes. Default 1.0. nNeighbors Integer, maximum number nearest neighbors compute. Default 20. prune Numeric. Sets cutoff acceptable Jaccard index computing neighborhood overlap SNN construction. edges values less equal set 0 removed SNN graph. Essentially sets stringency pruning. 0 pruning, 1 prunes everything. Default 1/15. eps Numeric, error bound nearest neighbor search. Default 0.1. nRandomStarts Integer number random starts. pick membership highest quality return. Default 10. nIterations Integer, maximal number iterations per random start. Default 5. method Community detection algorithm use. Choose \"leiden\" \"louvain\". Default \"leiden\". useRaw Whether use un-aligned cell factor loadings (\\(H\\) matrices). Default NULL search quantile-normalized loadings first un-aligned loadings . useDims Indices factors use clustering. Default NULL uses available factors. groupSingletons Whether group single cells make cluster cluster connected . Default TRUE, FALSE, assign singletons \"singleton\" group. clusterName Name variable store clustering result cellMeta slot object. Default \"leiden_cluster\" \"louvain_cluster\". seed Seed random number generator. Default 1. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set.","code":""},{"path":"/reference/runCluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SNN Graph Based Community Detection — runCluster","text":"object refined cluster assignment updated clusterName variable cellMeta slot. Can fetched object[[clusterName]]","code":""},{"path":"/reference/runCluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SNN Graph Based Community Detection — runCluster","text":"","code":"pbmcPlot <- runCluster(pbmcPlot) #> ℹ leiden clustering on quantile normalized cell factor loadings #> ✔ leiden clustering on quantile normalized cell factor loadings ... Found 8 clu… #>  #> ℹ cellMeta variable \"leiden_cluster\" is now set as default. head(pbmcPlot$leiden_cluster) #> ctrl_AAACATACCTCGCT.1 ctrl_AAACGGCTCTTCGC.1 ctrl_AACACTCTAAGTAG.1  #>                     0                     0                     0  #> ctrl_AACCGCCTCAGGAG.1 ctrl_AACGTTCTTCCGTC.1 ctrl_AAGAACGAAACGAA.1  #>                     3                     1                     0  #> Levels: 0 1 2 3 4 5 6 7 pbmcPlot <- runCluster(pbmcPlot, method = \"louvain\") #> ℹ louvain clustering on quantile normalized cell factor loadings #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Reading input file... #>  #> Number of nodes: 600 #> Number of edges: 17528 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.7580 #> Number of communities: 8 #> Elapsed time: 0 seconds #> ✔ louvain clustering on quantile normalized cell factor loadings ... Found 8 cl… #>  #> ℹ cellMeta variable \"louvain_cluster\" is now set as default. head(pbmcPlot$louvain_cluster) #> ctrl_AAACATACCTCGCT.1 ctrl_AAACGGCTCTTCGC.1 ctrl_AACACTCTAAGTAG.1  #>                     0                     0                     0  #> ctrl_AACCGCCTCAGGAG.1 ctrl_AACGTTCTTCCGTC.1 ctrl_AAGAACGAAACGAA.1  #>                     3                     1                     0  #> Levels: 0 1 2 3 4 5 6 7"},{"path":"/reference/runDoubletFinder.html","id":null,"dir":"Reference","previous_headings":"","what":"Doublet detection with DoubletFinder — runDoubletFinder","title":"Doublet detection with DoubletFinder — runDoubletFinder","text":"Detect doublet DoubletFinder. Package \"Seurat\" \"DoubletFinder\" required run function. wrapper runs Seurat PCA workflow (NormalizeData, FindVariableFeatures, ScaleData, RunPCA) default settings dataset, calls DoubletFinder::doubletFinder. Users prefer control preprocessing part might consider creating single-sample Seurat object CreateSeuratObject(rawData(object, \"datasetName\")).","code":""},{"path":"/reference/runDoubletFinder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Doublet detection with DoubletFinder — runDoubletFinder","text":"","code":"runDoubletFinder(   object,   useDatasets = NULL,   PCs = 1:10,   nNeighbors = 20,   nExp = NULL,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/runDoubletFinder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Doublet detection with DoubletFinder — runDoubletFinder","text":"object liger object. useDatasets character vector names, numeric logical vector index datasets run DoubletFinder::doubletFinder . Default NULL applies datasets. PCs Specific principal components use. Default 1:10. nNeighbors Number PC neighborhood size used compute pANN. See \"See Also\". Scalar used datasets vector . Default 20. nExp total number doublet predictions produced. Scalar used datasets vector . Default NULL sets 0.15 proportion. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. ... Additional arguments passed DoubletFinder::doubletFinder.","code":""},{"path":"/reference/runDoubletFinder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Doublet detection with DoubletFinder — runDoubletFinder","text":"Updated object variables DoubletFinder_pANN DoubletFinder_classification updated cellMeta slot","code":""},{"path":"/reference/runDoubletFinder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Doublet detection with DoubletFinder — runDoubletFinder","text":"","code":"if (requireNamespace(\"DoubletFinder\", quietly = TRUE)) {     pbmc <- runDoubletFinder(pbmc)     print(cellMeta(pbmc)) } #> ℹ Running DoubletFinder on dataset \"ctrl\" #> Loading required package: Seurat #> Loading required package: SeuratObject #> Loading required package: sp #> ‘SeuratObject’ was built under R 4.3.1 but the current version is #> 4.3.2; it is recomended that you reinstall ‘SeuratObject’ as the ABI #> for R may have changed #> ‘SeuratObject’ was built with package ‘Matrix’ 1.6.3 but the current #> version is 1.6.5; it is recomended that you reinstall ‘SeuratObject’ as #> the ABI for ‘Matrix’ may have changed #>  #> Attaching package: ‘SeuratObject’ #> The following object is masked from ‘package:base’: #>  #>     intersect #> Loading required package: fields #> Loading required package: spam #> Spam version 2.10-0 (2023-10-23) is loaded. #> Type 'help( Spam)' or 'demo( spam)' for a short introduction  #> and overview of this package. #> Help for individual functions is also obtained by adding the #> suffix '.spam' to the function name, e.g. 'help( chol.spam)'. #>  #> Attaching package: ‘spam’ #> The following objects are masked from ‘package:base’: #>  #>     backsolve, forwardsolve #> Loading required package: viridisLite #>  #> Try help(fields) to get started. #> Loading required package: KernSmooth #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> [1] \"Creating 100 artificial doublets...\" #> [1] \"Creating Seurat object...\" #> [1] \"Normalizing Seurat object...\" #> Normalizing layer: counts #> [1] \"Finding variable genes...\" #> Finding variable features for layer counts #> [1] \"Scaling data...\" #> Centering and scaling data matrix #> [1] \"Running PCA...\" #> [1] \"Calculating PC distance matrix...\" #> [1] \"Computing pANN...\" #> [1] \"Classifying doublets..\" #> ✔ Running DoubletFinder on dataset \"ctrl\" ... done #>  #> ℹ Running DoubletFinder on dataset \"stim\" #> [1] \"Creating 100 artificial doublets...\" #> [1] \"Creating Seurat object...\" #> [1] \"Normalizing Seurat object...\" #> Normalizing layer: counts #> [1] \"Finding variable genes...\" #> Finding variable features for layer counts #> [1] \"Scaling data...\" #> Centering and scaling data matrix #> [1] \"Running PCA...\" #> [1] \"Calculating PC distance matrix...\" #> [1] \"Computing pANN...\" #> [1] \"Classifying doublets..\" #> ✔ Running DoubletFinder on dataset \"stim\" ... done #>  #> DataFrame with 600 rows and 9 columns #>                        dataset               barcode      nUMI     nGene #>                       <factor>           <character> <numeric> <integer> #> ctrl_AAACATACCTCGCT.1     ctrl ctrl_AAACATACCTCGCT.1      2151       102 #> ctrl_AAACGGCTCTTCGC.1     ctrl ctrl_AAACGGCTCTTCGC.1      1916       103 #> ctrl_AACACTCTAAGTAG.1     ctrl ctrl_AACACTCTAAGTAG.1      1869        95 #> ctrl_AACCGCCTCAGGAG.1     ctrl ctrl_AACCGCCTCAGGAG.1       733        84 #> ctrl_AACGTTCTTCCGTC.1     ctrl ctrl_AACGTTCTTCCGTC.1       573        76 #> ...                        ...                   ...       ...       ... #> stim_TTCATGACTTATCC.1     stim stim_TTCATGACTTATCC.1      1091       101 #> stim_TTCATGACTTCAGG.1     stim stim_TTCATGACTTCAGG.1       431        86 #> stim_TTCGGAGATTTCAC.1     stim stim_TTCGGAGATTTCAC.1      1344       102 #> stim_TTGACACTTCCTGC.1     stim stim_TTGACACTTCCTGC.1      1423       105 #> stim_TTTGCATGAACGAA.1     stim stim_TTTGCATGAACGAA.1      2818       120 #>                            mito      ribo      hemo DoubletFinder_pANN #>                       <numeric> <numeric> <numeric>          <numeric> #> ctrl_AAACATACCTCGCT.1         0  10.83217         0             0.0125 #> ctrl_AAACGGCTCTTCGC.1         0  20.25052         0             0.0125 #> ctrl_AACACTCTAAGTAG.1         0   5.08293         0             0.0125 #> ctrl_AACCGCCTCAGGAG.1         0  42.70123         0             0.0125 #> ctrl_AACGTTCTTCCGTC.1         0  38.04538         0             0.0125 #> ...                         ...       ...       ...                ... #> stim_TTCATGACTTATCC.1         0   8.61595         0             0.0125 #> stim_TTCATGACTTCAGG.1         0  41.29930         0             0.0125 #> stim_TTCGGAGATTTCAC.1         0   8.85417         0             0.0125 #> stim_TTGACACTTCCTGC.1         0  11.94659         0             0.0125 #> stim_TTTGCATGAACGAA.1         0   9.43932         0             0.0125 #>                       DoubletFinder_classification #>                                        <character> #> ctrl_AAACATACCTCGCT.1                      Doublet #> ctrl_AAACGGCTCTTCGC.1                      Doublet #> ctrl_AACACTCTAAGTAG.1                      Doublet #> ctrl_AACCGCCTCAGGAG.1                      Doublet #> ctrl_AACGTTCTTCCGTC.1                      Doublet #> ...                                            ... #> stim_TTCATGACTTATCC.1                      Singlet #> stim_TTCATGACTTCAGG.1                      Singlet #> stim_TTCGGAGATTTCAC.1                      Singlet #> stim_TTGACACTTCCTGC.1                      Singlet #> stim_TTTGCATGAACGAA.1                      Singlet"},{"path":"/reference/runGOEnrich.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","title":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","text":"function forms genesets basing differential expression result, calls gene ontology (GO) analysis method provided gprofiler2.","code":""},{"path":"/reference/runGOEnrich.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","text":"","code":"runGOEnrich(   result,   group = NULL,   useBg = TRUE,   orderBy = \"padj\",   logFCThresh = 1,   padjThresh = 0.05,   splitReg = FALSE,   ... )"},{"path":"/reference/runGOEnrich.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","text":"result Data frame unfiltered output runMarkerDEG runPairwiseDEG. group Selection one group available result$group. Default NULL uses groups involved DE result table. useBg Logical, whether set genes involved DE analysis (threshold filtering) domain background GO analysis. Default TRUE. orderBy Name DE statistics metric order gene list group. Choose \"logFC\" (default), \"pval\" \"padj\". set NULL turn ranked mode. logFCThresh log2FC threshold genes used. Default 1. padjThresh adjusted p-value threshold less genes used. Default 0.05. splitReg Whether queries -regulated -regulated genes group. Default FALSE queries -regulated genes preferred result comes marker detection test. result comes group--group DE test, recommended set splitReg = TRUE. ... Additional arguments passed gprofiler2::gost. Arguments query, custom_bg, domain_scope, ordered_query pre-specified wrapper function. Users must set organism = \"mmusculus\" working mouse data.","code":""},{"path":"/reference/runGOEnrich.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","text":"list object element result list group. result list contains two elements: result data.frame main GO analysis result. meta Meta information query. See gost. detailed explanation.","code":""},{"path":"/reference/runGOEnrich.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","text":"Kolberg, L. et al, 2020 Raudvere, U. et al, 2019","code":""},{"path":"/reference/runGOEnrich.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Gene Ontology enrichment analysis on differentially expressed genes. — runGOEnrich","text":"","code":"res <- runMarkerDEG(pbmcPlot) #> ℹ Running Wilcoxon rank-sum test #> ✔ Running Wilcoxon rank-sum test ... done #>  # Setting `significant = FALSE` because it's hard for a gene list obtained # from small test dataset to represent real-life biology. # \\donttest{ go <- runGOEnrich(res, group = 0, significant = FALSE) # }"},{"path":"/reference/runGSEA.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze biological interpretations of metagene — runGSEA","title":"Analyze biological interpretations of metagene — runGSEA","text":"Identify biological pathways (gene sets Reactome) metagene (factor) might belongs .","code":""},{"path":"/reference/runGSEA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze biological interpretations of metagene — runGSEA","text":"","code":"runGSEA(   object,   genesets = NULL,   useW = TRUE,   useV = NULL,   customGenesets = NULL,   gene_sets = genesets,   mat_w = useW,   mat_v = useV,   custom_gene_sets = customGenesets )"},{"path":"/reference/runGSEA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze biological interpretations of metagene — runGSEA","text":"object liger object valid factorization result. genesets Character vector Reactome gene sets names tested. Default NULL uses gene sets Reactome. useW Logical, whether use shared factor loadings (\\(W\\)). Default TRUE. useV character vector names, numeric logical vector index datasets \\(V\\) matrices included analysis. Default NULL uses datasets. customGenesets named list character vectors entrez gene ids. Default NULL uses gene symbols input matrix. gene_sets, mat_w, mat_v, custom_gene_sets Deprecated. See Usage section replacement.","code":""},{"path":"/reference/runGSEA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze biological interpretations of metagene — runGSEA","text":"list matrices GSEA analysis factor","code":""},{"path":"/reference/runGSEA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze biological interpretations of metagene — runGSEA","text":"","code":"# \\donttest{ runGSEA(pbmcPlot) #>  #> 'select()' returned 1:1 mapping between keys and columns #> 'select()' returned 1:many mapping between keys and columns #> 'select()' returned 1:1 mapping between keys and columns #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (40.43% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (38.3% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (40.43% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (29.79% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (42.55% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (34.04% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (29.79% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (42.55% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (46.81% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (38.3% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (44.68% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (31.91% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (51.06% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (38.3% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (53.19% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (34.04% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (34.04% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (40.43% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (40.43% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> Warning: You are trying to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. #> Warning: There are ties in the preranked stats (31.91% of the list). #> The order of those tied genes will be arbitrary, which may produce unexpected results. #> Warning: All values in the stats vector are greater than zero and scoreType is \"std\", maybe you should switch to scoreType = \"pos\". #> $Factor_1 #>                    pathway        pval        padj        ES      NES #> 1 Viral Infection Pathways 0.001391118 0.005564473 0.6841373 1.848427 #> 2       Infectious disease 0.006055455 0.012110910 0.6324946 1.732690 #> 3                  Disease 0.035265547 0.047020730 0.5555992 1.539175 #> 4            Immune System 0.402103474 0.402103474 0.3869393 1.060003 #>   nMoreExtreme size  leadingEdge #> 1           12   16 6232, 61.... #> 2           56   18 6232, 61.... #> 3          333   21 6232, 61.... #> 4         3784   18 5473, 91.... #>  #> $Factor_2 #>                    pathway         pval         padj         ES       NES #> 1       Infectious disease 0.0004224757 0.0008449514  0.7516368  2.048992 #> 2 Viral Infection Pathways 0.0002133561 0.0008449514  0.7945198  2.127748 #> 3                  Disease 0.0014753926 0.0019671901  0.6878732  1.890748 #> 4            Immune System 0.4189944134 0.4189944134 -0.2442762 -1.005201 #>   nMoreExtreme size  leadingEdge #> 1            3   18 7852, 62.... #> 2            1   16 7852, 62.... #> 3           13   21 7852, 62.... #> 4          224   18 929, 362.... #>  #> $Factor_3 #>                    pathway      pval      padj        ES      NES nMoreExtreme #> 1                  Disease 0.1021156 0.2902135 0.5033034 1.363403          974 #> 2       Infectious disease 0.1451067 0.2902135 0.4849868 1.296973         1372 #> 3 Viral Infection Pathways 0.2918218 0.3890957 0.4347337 1.148921         2743 #> 4            Immune System 0.4154513 0.4154513 0.3933589 1.051938         3930 #>   size  leadingEdge #> 1   21 3553, 92.... #> 2   18 3553, 22.... #> 3   16 6202, 90.... #> 4   18 3553, 92.... #>  #> $Factor_4 #>                    pathway      pval      padj        ES       NES nMoreExtreme #> 1       Infectious disease 0.1959253 0.3918505 0.4457936 1.2418414         1855 #> 2 Viral Infection Pathways 0.1652452 0.3918505 0.4642226 1.2730006         1549 #> 3                  Disease 0.5654097 0.7538796 0.3355193 0.9424895         5367 #> 4            Immune System 0.9053098 0.9053098 0.2307424 0.6427760         8575 #>   size  leadingEdge #> 1   18 9636, 61.... #> 2   16 9636, 61.... #> 3   21 9636, 61.... #> 4   18 91543, 9.... #>  #> $Factor_5 #>                    pathway       pval      padj        ES       NES #> 1       Infectious disease 0.06196468 0.1239294 0.5286897 1.4474224 #> 2 Viral Infection Pathways 0.05807003 0.1239294 0.5352879 1.4438988 #> 3                  Disease 0.26604925 0.3547323 0.4263150 1.1795495 #> 4            Immune System 0.90440943 0.9044094 0.2309144 0.6321869 #>   nMoreExtreme size  leadingEdge #> 1          585   18 3553, 96.... #> 2          543   16 9636, 62.... #> 3         2527   21 3553, 96.... #> 4         8552   18 972, 355.... #>  #> $Factor_6 #>                    pathway       pval       padj        ES      NES #> 1            Immune System 0.02084869 0.08339476 0.5831827 1.576855 #> 2       Infectious disease 0.27787722 0.37050297 0.4286276 1.158957 #> 3 Viral Infection Pathways 0.24860011 0.37050297 0.4431857 1.186587 #> 4                  Disease 0.40515615 0.40515615 0.3858369 1.055685 #>   nMoreExtreme size  leadingEdge #> 1          197   18 2214, 51.... #> 2         2638   18 2214, 96.... #> 3         2352   16 9636, 61.... #> 4         3865   21 2214, 96.... #>  #> $Factor_7 #>                    pathway        pval        padj        ES       NES #> 1       Infectious disease 0.001468275 0.005873099 0.6880527 1.8578428 #> 2                  Disease 0.012445095 0.016593460 0.6088180 1.6578106 #> 3 Viral Infection Pathways 0.008969083 0.016593460 0.6283282 1.6766993 #> 4            Immune System 0.965285789 0.965285789 0.2017394 0.5447259 #>   nMoreExtreme size  leadingEdge #> 1           13   18 2214, 62.... #> 2          118   21 2214, 62.... #> 3           84   16 6228, 90.... #> 4         9203   18 10578, 2.... #>  #> $Factor_8 #>                    pathway         pval         padj        ES      NES #> 1       Infectious disease 0.0001065757 0.0002146614 0.7910399 2.175216 #> 2 Viral Infection Pathways 0.0001073307 0.0002146614 0.8328494 2.265038 #> 3                  Disease 0.0004227883 0.0005637177 0.7311131 2.035824 #> 4            Immune System 0.8661408931 0.8661408931 0.2444750 0.672262 #>   nMoreExtreme size  leadingEdge #> 1            0   18 6133, 61.... #> 2            0   16 6133, 61.... #> 3            3   21 6133, 61.... #> 4         8126   18 10578, 6.... #>  #> $Factor_9 #>                    pathway       pval       padj        ES      NES #> 1            Immune System 0.01214187 0.04856747 0.6100554 1.659854 #> 2                  Disease 0.37211274 0.51569892 0.3951049 1.085591 #> 3 Viral Infection Pathways 0.38677419 0.51569892 0.4006452 1.078623 #> 4       Infectious disease 0.51869209 0.51869209 0.3590636 0.976949 #>   nMoreExtreme size  leadingEdge #> 1          113   18 9636, 91.... #> 2         3511   21 9636, 62.... #> 3         3596   16 9636, 61.... #> 4         4869   18 9636, 61.... #>  #> $Factor_10 #>                    pathway        pval       padj         ES       NES #> 1 Viral Infection Pathways 0.003203075 0.01281230  0.6689367  1.819988 #> 2       Infectious disease 0.009693225 0.01938645  0.6113634  1.680414 #> 3                  Disease 0.060532432 0.08070991  0.5244344  1.459576 #> 4            Immune System 0.288492707 0.28849271 -0.2735749 -1.155878 #>   nMoreExtreme size  leadingEdge #> 1           29   16 7852, 62.... #> 2           90   18 7852, 62.... #> 3          572   21 7852, 62.... #> 4          177   18 929, 355.... #>  #> $Factor_11 #>                    pathway      pval      padj        ES      NES nMoreExtreme #> 1       Infectious disease 0.1345868 0.2691736 0.4849411 1.318384         1266 #> 2 Viral Infection Pathways 0.1274247 0.2691736 0.4949309 1.326601         1188 #> 3                  Disease 0.4201841 0.5602454 0.3823529 1.052155         3971 #> 4            Immune System 0.9417888 0.9417888 0.2086250 0.567178         8865 #>   size  leadingEdge #> 1   18 2214, 61.... #> 2   16 6133, 61.... #> 3   21 2214, 61.... #> 4   18 2207, 62.... #>  #> $Factor_12 #>                    pathway       pval       padj        ES      NES #> 1                  Disease 0.02467465 0.09869859 0.5886130 1.573397 #> 2       Infectious disease 0.09727301 0.15975875 0.5168881 1.364840 #> 3 Viral Infection Pathways 0.11981906 0.15975875 0.5088522 1.330409 #> 4            Immune System 0.32305924 0.32305924 0.4253640 1.123171 #>   nMoreExtreme size  leadingEdge #> 1          236   21 6279, 62.... #> 2          930   18 3553, 61.... #> 3         1138   16 6135, 61.... #> 4         3091   18 6279, 62.... #>  #> $Factor_13 #>                    pathway         pval        padj         ES        NES #> 1       Infectious disease 0.0005426525 0.001085305  0.7125681  1.9947014 #> 2 Viral Infection Pathways 0.0003276540 0.001085305  0.7171567  1.9818528 #> 3                  Disease 0.0062205062 0.008294008  0.6230769  1.7643122 #> 4            Immune System 0.9898605830 0.989860583 -0.1143908 -0.4973585 #>   nMoreExtreme size  leadingEdge #> 1            4   18 4869, 90.... #> 2            2   16 4869, 90.... #> 3           57   21 4869, 90.... #> 4          780   18 929, 513.... #>  #> $Factor_14 #>                    pathway         pval         padj         ES       NES #> 1                  Disease 0.0001050641 0.0001415879  0.8417415  2.308089 #> 2       Infectious disease 0.0001055632 0.0001415879  0.8800578  2.382872 #> 3 Viral Infection Pathways 0.0001061909 0.0001415879  0.9076006  2.432131 #> 4            Immune System 0.2687969925 0.2687969925 -0.2882457 -1.176610 #>   nMoreExtreme size  leadingEdge #> 1            0   21 6164, 61.... #> 2            0   18 6164, 61.... #> 3            0   16 6164, 61.... #> 4          142   18 929, 362.... #>  #> $Factor_15 #>                    pathway         pval         padj        ES       NES #> 1 Viral Infection Pathways 0.0002189381 0.0008757526 0.7639766 2.1129491 #> 2       Infectious disease 0.0006509004 0.0013018008 0.7089421 1.9856468 #> 3                  Disease 0.0050690250 0.0067587000 0.6304771 1.7843747 #> 4            Immune System 0.8229550879 0.8229550879 0.2552083 0.7148025 #>   nMoreExtreme size  leadingEdge #> 1            1   16 4869, 62.... #> 2            5   18 4869, 62.... #> 3           46   21 4869, 62.... #> 4         7585   18   5473, 4869 #>  #> $Factor_16 #>                    pathway         pval        padj         ES       NES #> 1 Viral Infection Pathways 0.0009634943 0.003853977  0.7242736  1.988848 #> 2       Infectious disease 0.0020129251 0.004025850  0.6729600  1.872986 #> 3                  Disease 0.0122647494 0.016352999  0.5949352  1.670171 #> 4            Immune System 0.3605683837 0.360568384 -0.2577690 -1.064250 #>   nMoreExtreme size  leadingEdge #> 1            8   16 7852, 62.... #> 2           18   18 7852, 62.... #> 3          115   21 7852, 62.... #> 4          202   18 929, 513.... #>  #> $Factor_17 #>                    pathway         pval        padj         ES        NES #> 1       Infectious disease 0.0004203889 0.001681555  0.7231558  1.9422854 #> 2 Viral Infection Pathways 0.0011650074 0.002330015  0.7091217  1.8841903 #> 3                  Disease 0.0035553697 0.004740493  0.6524684  1.7706436 #> 4            Immune System 0.5881147541 0.588114754 -0.2288559 -0.9160614 #>   nMoreExtreme size  leadingEdge #> 1            3   18 6164, 62.... #> 2           10   16 6164, 62.... #> 3           33   21 6164, 62.... #> 4          286   18 929, 513.... #>  #> $Factor_18 #>                    pathway       pval      padj        ES      NES nMoreExtreme #> 1            Immune System 0.08980426 0.3078081 0.5036946 1.400687          834 #> 2       Infectious disease 0.15390407 0.3078081 0.4669226 1.298430         1430 #> 3 Viral Infection Pathways 0.33178929 0.4423857 0.4085270 1.124577         3079 #> 4                  Disease 0.45788521 0.4578852 0.3603539 1.017387         4299 #>   size  leadingEdge #> 1   18 3627, 26.... #> 2   18 2214, 96.... #> 3   16 9636, 62.... #> 4   21 2214, 96.... #>  #> $Factor_19 #>                    pathway         pval        padj        ES       NES #> 1 Viral Infection Pathways 0.0004265302 0.001706121 0.7083495 1.9105478 #> 2       Infectious disease 0.0021128248 0.004225650 0.6656027 1.8229746 #> 3                  Disease 0.0118784821 0.015837976 0.6023632 1.6642634 #> 4            Immune System 0.8160785971 0.816078597 0.2716142 0.7439058 #>   nMoreExtreme size  leadingEdge #> 1            3   16 6232, 78.... #> 2           19   18 6232, 78.... #> 3          112   21 6232, 78.... #> 4         7724   18 6402, 26.... #>  #> $Factor_20 #>                    pathway       pval       padj        ES       NES #> 1       Infectious disease 0.03930039 0.07860078 0.5537159 1.4995176 #> 2 Viral Infection Pathways 0.03593005 0.07860078 0.5629286 1.5040992 #> 3                  Disease 0.17402243 0.23202991 0.4622005 1.2645045 #> 4            Immune System 0.60056896 0.60056896 0.3386207 0.9170184 #>   nMoreExtreme size  leadingEdge #> 1          372   18 7852, 62.... #> 2          338   16 7852, 62.... #> 3         1659   21 7852, 62.... #> 4         5699   18 10578, 5.... #>  # }"},{"path":"/reference/runGeneralQC.html","id":null,"dir":"Reference","previous_headings":"","what":"General QC for liger object — runGeneralQC","title":"General QC for liger object — runGeneralQC","text":"Calculate number UMIs, number detected features percentage feature subset (e.g. mito) expression per cell.","code":""},{"path":"/reference/runGeneralQC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General QC for liger object — runGeneralQC","text":"","code":"runGeneralQC(   object,   mito = TRUE,   ribo = TRUE,   hemo = TRUE,   features = NULL,   pattern = NULL,   useDatasets = NULL,   chunkSize = 1000,   verbose = getOption(\"ligerVerbose\", TRUE) )"},{"path":"/reference/runGeneralQC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General QC for liger object — runGeneralQC","text":"object liger object rawData available ligerDataset embedded mito, ribo, hemo Whether calculate expression percentage mitochondrial, ribosomal hemoglobin genes, respectively. Default TRUE. features Feature names matching feature subsets users want calculate expression percentage . vector single subset, named list multiple subset. Default NULL. pattern Regex patterns matching feature subsets users want calculate expression percentage . vector single subset, named list multiple subset. Default NULL. useDatasets character vector names, numeric logical vector index datasets included QC. Default NULL performs QC datasets. chunkSize Integer number cells include chunk working HDF5 based dataset. Default 1000 verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set.","code":""},{"path":"/reference/runGeneralQC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General QC for liger object — runGeneralQC","text":"Updated object nUMI, nGene updated cellMeta(object), well expression percentage value feature subset.","code":""},{"path":"/reference/runGeneralQC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General QC for liger object — runGeneralQC","text":"","code":"pbmc <- runGeneralQC(pbmc) #> ℹ calculating QC for dataset \"ctrl\" #> ✔ calculating QC for dataset \"ctrl\" ... done #>  #> ℹ calculating QC for dataset \"stim\" #> ✔ calculating QC for dataset \"stim\" ... done #>"},{"path":"/reference/runINMF.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform iNMF on scaled datasets — runINMF","title":"Perform iNMF on scaled datasets — runINMF","text":"Performs integrative non-negative matrix factorization (iNMF) (J.D. Welch, 2019) using block coordinate descent (alternating non-negative least squares, ANLS) return factorized \\(H\\), \\(W\\), \\(V\\) matrices. objective function stated $$\\arg\\min_{H\\ge0,W\\ge0,V\\ge0}\\sum_{}^{d}||E_i-(W+V_i)Hi||^2_F+ \\lambda\\sum_{}^{d}||V_iH_i||_F^2$$ \\(E_i\\) input non-negative matrix 'th dataset, \\(d\\) total number datasets. \\(E_i\\) size \\(m \\times n_i\\) \\(m\\) variable genes \\(n_i\\) cells, \\(H_i\\) size \\(n_i \\times k\\), \\(V_i\\) size \\(m \\times k\\), \\(W\\) size \\(m \\times k\\). factorization produces shared \\(W\\) matrix (genes k), dataset, \\(H\\) matrix (k cells) \\(V\\) matrix (genes k). \\(H\\) matrices represent cell factor loadings. \\(W\\) held consistent among datasets, represents shared components metagenes across datasets. \\(V\\) matrices represent dataset-specific components metagenes. function adopts highly optimized fast memory efficient implementation extended Planc (Kannan, 2016). Pre-installation extension package RcppPlanc required. underlying algorithm adopts identical ANLS strategy optimizeALS old version LIGER.","code":""},{"path":"/reference/runINMF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform iNMF on scaled datasets — runINMF","text":"","code":"runINMF(object, k = 20, lambda = 5, ...)  # S3 method for liger runINMF(   object,   k = 20,   lambda = 5,   nIteration = 30,   nRandomStarts = 1,   HInit = NULL,   WInit = NULL,   VInit = NULL,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for Seurat runINMF(   object,   k = 20,   lambda = 5,   datasetVar = \"orig.ident\",   layer = \"ligerScaleData\",   assay = NULL,   reduction = \"inmf\",   nIteration = 30,   nRandomStarts = 1,   HInit = NULL,   WInit = NULL,   VInit = NULL,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/runINMF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform iNMF on scaled datasets — runINMF","text":"object liger object Seurat object non-negative scaled data variable features (Done scaleNotCenter). k Inner dimension factorization (number factors). Generally, higher k needed datasets sub-structure. Default 20. lambda Regularization parameter. Larger values penalize dataset-specific effects strongly (.e. alignment increase lambda increases). Default 5. ... Arguments passed methods. nIteration Total number block coordinate descent iterations perform. Default 30. nRandomStarts Number restarts perform (iNMF objective function non-convex, taking best objective multiple successive initialization recommended). easier reproducibility, increments random seed 1 consecutive restart, future factorization dataset can run one rep necessary. Default 1. HInit Initial values use \\(H\\) matrices. list object element initial \\(H\\) matrix dataset. Default NULL. WInit Initial values use \\(W\\) matrix. matrix object. Default NULL. VInit Initial values use \\(V\\) matrices. list object element initial \\(V\\) matrix dataset. Default NULL. seed Random seed allow reproducible results. Default 1. nCores number parallel tasks speed computation. Default 2L. supported platform OpenMP support. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. datasetVar Metadata variable name stores dataset source annotation. Default \"orig.ident\". layer Seurat>=4.9.9, name layer retrieve input non-negative scaled data. Default \"ligerScaleData\". older Seurat, always retrieve scale.data slot. assay Name assay use. Default NULL uses current active assay. reduction Name reduction store result. Also used feature key. Default \"inmf\".","code":""},{"path":"/reference/runINMF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform iNMF on scaled datasets — runINMF","text":"liger method - Returns updated input liger object list \\(H\\) matrices can accessed          getMatrix(object, \"H\") list \\(V\\) matrices can accessed          getMatrix(object, \"V\") \\(W\\) matrix can accessed          getMatrix(object, \"W\") Seurat method - Returns updated input Seurat object \\(H\\) matrices datasets concatenated          transposed (cells k), form DimReduc object          reductions slot named argument reduction. \\(W\\) matrix presented feature.loadings          DimReduc object. \\(V\\) matrices, objective error value dataset          variable used factorization currently stored          misc slot DimReduc object.","code":""},{"path":"/reference/runINMF.html","id":"difference-from-optimizeals-","dir":"Reference","previous_headings":"","what":"Difference from optimizeALS()","title":"Perform iNMF on scaled datasets — runINMF","text":"old version implementation, compute objective error end iteration, compares algorithm reaching convergence, using argument thresh. Now, since computation objective error indeed expensive, canceled feature directly runs default 30 (nIteration) iterations, empirically leads convergence time. Given new version highly optimized, running many iteration acceptable.","code":""},{"path":"/reference/runINMF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform iNMF on scaled datasets — runINMF","text":"Joshua D. Welch et al., Single-Cell Multi-omic Integration Compares Contrasts Features Brain Cell Identity, Cell, 2019","code":""},{"path":"/reference/runINMF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform iNMF on scaled datasets — runINMF","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     pbmc <- runINMF(pbmc) }"},{"path":"/reference/runIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate scaled datasets with iNMF or variant methods — runIntegration","title":"Integrate scaled datasets with iNMF or variant methods — runIntegration","text":"LIGER provides dataset integration methods based iNMF (integrative Non-negative Matrix Factorization [1]) variants (online iNMF [2] UINMF [3]). function wraps runINMF, runOnlineINMF runUINMF, help pages detailed description.","code":""},{"path":"/reference/runIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate scaled datasets with iNMF or variant methods — runIntegration","text":"","code":"runIntegration(   object,   k = 20,   lambda = 5,   method = c(\"iNMF\", \"onlineINMF\", \"UINMF\"),   ... )  # S3 method for liger runIntegration(   object,   k = 20,   lambda = 5,   method = c(\"iNMF\", \"onlineINMF\", \"UINMF\"),   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for Seurat runIntegration(   object,   k = 20,   lambda = 5,   method = c(\"iNMF\", \"onlineINMF\"),   datasetVar = \"orig.ident\",   useLayer = \"ligerScaleData\",   assay = NULL,   seed = 1,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/runIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrate scaled datasets with iNMF or variant methods — runIntegration","text":"object liger object Seurat object non-negative scaled data variable features (Done scaleNotCenter). k Inner dimension factorization (number factors). Generally, higher k needed datasets sub-structure. Default 20. lambda Regularization parameter. Larger values penalize dataset-specific effects strongly (.e. alignment increase lambda increases). Default 5. method iNMF variant algorithm use integration. Choose \"iNMF\", \"onlineINMF\", \"UINMF\". Default \"iNMF\". ... Arguments passed methods wrapped functions. seed Random seed allow reproducible results. Default 1. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. datasetVar Metadata variable name stores dataset source annotation. Default \"orig.ident\". useLayer Seurat>=4.9.9, name layer retrieve input non-negative scaled data. Default \"ligerScaleData\". older Seurat, always retrieve scale.data slot. assay Name assay use. Default NULL uses current active assay.","code":""},{"path":"/reference/runIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrate scaled datasets with iNMF or variant methods — runIntegration","text":"Updated input object. detail, please refer refered method linked Description.","code":""},{"path":"/reference/runIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Integrate scaled datasets with iNMF or variant methods — runIntegration","text":"Joshua D. Welch et al., Single-Cell Multi-omic Integration Compares Contrasts Features Brain Cell Identity, Cell, 2019 Chao Gao et al., Iterative single-cell multi-omic integration using online learning, Nat Biotechnol., 2021 April R. Kriebel Joshua D. Welch, UINMF performs mosaic integration single-cell multi-omic datasets using nonnegative matrix factorization, Nat. Comm., 2022","code":""},{"path":"/reference/runIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrate scaled datasets with iNMF or variant methods — runIntegration","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     pbmc <- runIntegration(pbmc) }"},{"path":"/reference/runOnlineINMF.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform online iNMF on scaled datasets — runOnlineINMF","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"Perform online integrative non-negative matrix factorization represent multiple single-cell datasets terms \\(H\\), \\(W\\), \\(V\\) matrices. optimizes iNMF objective function (see runINMF) using online learning (non-negative least squares \\(H\\) matrices, hierarchical alternating least squares (HALS) \\(V\\) matrices \\(W\\)), number factors set k. function allows online learning 3 scenarios: Fully observed datasets; Iterative refinement using continually arriving datasets; Projection new datasets without updating existing factorization three scenarios require fixed memory independent number cells. dataset, factorization produces \\(H\\) matrix (k cell), \\(V\\) matrix (genes k), shared \\(W\\) matrix (genes k). \\(H\\) matrices represent cell factor loadings. \\(W\\) identical among datasets, represents shared components metagenes across datasets. \\(V\\) matrices represent dataset-specific components metagenes.","code":""},{"path":"/reference/runOnlineINMF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"","code":"runOnlineINMF(object, k = 20, lambda = 5, ...)  # S3 method for liger runOnlineINMF(   object,   k = 20,   lambda = 5,   newDatasets = NULL,   projection = FALSE,   maxEpochs = 5,   HALSiter = 1,   minibatchSize = 5000,   WInit = NULL,   VInit = NULL,   AInit = NULL,   BInit = NULL,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for Seurat runOnlineINMF(   object,   k = 20,   lambda = 5,   datasetVar = \"orig.ident\",   layer = \"ligerScaleData\",   assay = NULL,   reduction = \"onlineINMF\",   maxEpochs = 5,   HALSiter = 1,   minibatchSize = 5000,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/runOnlineINMF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"object liger object. Scaled data required. k Inner dimension factorization--number metagenes. value range 20-50 works well analyses. Default 20. lambda Regularization parameter. Larger values penalize dataset-specific effects strongly (.e. alignment increase lambda increases). recommend always using default value except possibly analyses relatively small differences (biological replicates, male/female comparisons, etc.) case lower value 1.0 may improve reconstruction quality. Default 5.0. ... Arguments passed S3 methods function. newDatasets Named list dgCMatrix. New datasets scenario 2 scenario 3. Default NULL triggers scenario 1. projection Whether perform data integration scenario 3 newDatasets specified. See description. Default FALSE. maxEpochs number epochs iterate . See detail. Default 5. HALSiter Maximum number block coordinate descent (HALS algorithm) iterations perform update \\(W\\) \\(V\\). Default 1. Changing parameter recommended. minibatchSize Total number cells minibatch. See detail. Default 5000. WInit, VInit, AInit, BInit Optional initialization \\(W\\), \\(V\\), \\(\\), \\(B\\) matrices, respectively. Must presented together. See detail. Default NULL. seed Random seed allow reproducible results. Default 1. nCores number parallel tasks speed computation. Default 2L. supported platform OpenMP support. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. datasetVar Metadata variable name stores dataset source annotation. Default \"orig.ident\". layer Seurat>=4.9.9, name layer retrieve input non-negative scaled data. Default \"ligerScaleData\". older Seurat, always retrieve scale.data slot. assay Name assay use. Default NULL uses current active assay. reduction Name reduction store result. Also used feature key. Default \"onlineINMF\".","code":""},{"path":"/reference/runOnlineINMF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"liger method - Returns updated input liger object. list \\(H\\) matrices can accessed          getMatrix(object, \"H\") list \\(V\\) matrices can accessed          getMatrix(object, \"V\") \\(W\\) matrix can accessed          getMatrix(object, \"W\") Meanwhile, intermediate matrices \\(\\) \\(B\\) produced          HALS update can also accessed similarly. Seurat method - Returns updated input Seurat object. \\(H\\) matrices datasets concatenated          transposed (cells k), form DimReduc object          reductions slot named argument reduction. \\(W\\) matrix presented feature.loadings          DimReduc object. \\(V\\) matrices, \\(\\) matrices, \\(B\\) matricesm objective          error value dataset variable used factorization          currently stored misc slot DimReduc object.","code":""},{"path":"/reference/runOnlineINMF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"performing scenario 2 3, complete set factorization result run scenario 1 required. Given structure liger object, required information can retrieved automatically. circumstance users need customized information existing factorization, arguments WInit, VInit, AInit BInit exposed. requirements argument follows: WInit - matrix object size \\(m \\times k\\). (see      runINMF notation) VInit - list object matrices size \\(m \\times k\\).      Number matrices match newDatasets. AInit - list object matrices size \\(k \\times k\\).      Number matrices match newDatasets. BInit - list object matrices size \\(m \\times k\\).      Number matrices match newDatasets. Minibatch iterations performed small subset cells. exact minibatch size applied dataset minibatchSize multiplied proportion cells dataset cells. general, minibatchSize larger number cells smallest dataset (considering object newDatasets). Therefore, smaller value may necessary analyzing small datasets. epoch one completion calculation cells number iterations minibatches. Therefore, total number iterations determined setting maxEpochs, total number cells, minibatchSize. Currently, Seurat S3 method support working Scenario 2 3, simple solution organizing number miscellaneous matrices single Seurat object. strongly recommend users create liger object specific structure.","code":""},{"path":"/reference/runOnlineINMF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"Chao Gao et al., Iterative single-cell multi-omic integration using online learning, Nat Biotechnol., 2021","code":""},{"path":"/reference/runOnlineINMF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform online iNMF on scaled datasets — runOnlineINMF","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (requireNamespace(\"RcppPlanc\", quietly = TRUE)) {     # Scenario 1     pbmc <- runOnlineINMF(pbmc, minibatchSize = 200)     # Scenario 2     # Fake new dataset by increasing all non-zero value in \"ctrl\" by 1     ctrl2 <- rawData(dataset(pbmc, \"ctrl\"))     ctrl2@x <- ctrl2@x + 1     colnames(ctrl2) <- paste0(colnames(ctrl2), 2)     pbmc2 <- runOnlineINMF(pbmc, k = 20, newDatasets = list(ctrl2 = ctrl2),                            minibatchSize = 100)     # Scenario 3     pbmc3 <- runOnlineINMF(pbmc, k = 20, newDatasets = list(ctrl2 = ctrl2),                            projection = TRUE) } #> ! Colnames of `value` do not all start with \"ctrl2_\". #> Prefix added. #> ℹ Normalizing datasets \"ctrl2\" #> ✔ Normalizing datasets \"ctrl2\" ... done #>  #> ℹ Scaling dataset \"ctrl2\" #> ✔ Scaling dataset \"ctrl2\" ... done #>  #> ! Colnames of `value` do not all start with \"ctrl2_\". #> Prefix added. #> ℹ Normalizing datasets \"ctrl2\" #> ✔ Normalizing datasets \"ctrl2\" ... done #>  #> ℹ Scaling dataset \"ctrl2\" #> ✔ Scaling dataset \"ctrl2\" ... done #>"},{"path":"/reference/runTSNE.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform t-SNE dimensionality reduction — runTSNE","title":"Perform t-SNE dimensionality reduction — runTSNE","text":"Runs t-SNE quantile normalized cell factors (result quantileNorm), unnormalized cell factors (result runIntegration)) generate 2D embedding visualization. default Rtsne (Barnes-Hut implementation t-SNE) method invoked, alternative \"fftRtsne\" method (FFT-accelerated Interpolation-based t-SNE, using Kluger Lab implementation) also supported. large datasets, recommended use method = \"fftRtsne\" due efficiency scalability. Extra external installation steps required using \"fftRtsne\" method. Please consult detailed guide.","code":""},{"path":"/reference/runTSNE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform t-SNE dimensionality reduction — runTSNE","text":"","code":"runTSNE(   object,   useRaw = NULL,   useDims = NULL,   nDims = 2,   usePCA = FALSE,   perplexity = 30,   theta = 0.5,   method = c(\"Rtsne\", \"fftRtsne\"),   dimredName = \"TSNE\",   fitsnePath = NULL,   seed = 42,   verbose = getOption(\"ligerVerbose\", TRUE),   k = nDims,   use.raw = useRaw,   dims.use = useDims,   use.pca = usePCA,   fitsne.path = fitsnePath,   rand.seed = seed )"},{"path":"/reference/runTSNE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform t-SNE dimensionality reduction — runTSNE","text":"object liger object factorization results. useRaw Whether use un-aligned cell factor loadings (\\(H\\) matrices). Default NULL search quantile-normalized loadings first un-aligned loadings . useDims Index factors use computing UMAP embedding. Default NULL uses factors. nDims Number dimensions reduce . Default 2. usePCA Whether perform initial PCA step Rtsne. Default FALSE. perplexity Numeric parameter pass Rtsne (expected number neighbors). Default 30. theta Speed/accuracy trade-(increase less accuracy), set 0.0 exact TSNE. Default 0.5. method Choose \"Rtsne\" \"fftRtsne\". See Description. Default \"Rtsne\". dimredName Name variable cellMeta slot store result matrix. Default \"TSNE\". fitsnePath Path cloned FIt-SNE directory (.e. '/path//dir/FIt-SNE'). Required first time using runTSNE method = \"fftRtsne\". Default NULL. seed Random seed reproducibility. Default 42. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. use.raw, dims.use, k, use.pca, fitsne.path, rand.seed Deprecated. See Usage section replacement.","code":""},{"path":"/reference/runTSNE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform t-SNE dimensionality reduction — runTSNE","text":"object \"TSNE\" variable updated cellMeta slot whole 2D embedding matrix.","code":""},{"path":[]},{"path":"/reference/runTSNE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform t-SNE dimensionality reduction — runTSNE","text":"","code":"pbmc <- runTSNE(pbmcPlot) #> ℹ Generating TSNE (Rtsne) on quantile normalized cell factor loadings #> ✔ Generating TSNE (Rtsne) on quantile normalized cell factor loadings ... done #>  #> ! No rownames detected. Assume cells match to the same order as in the object. #> ℹ DimRed \"TSNE\" is now set as default."},{"path":"/reference/runUINMF.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"Performs mosaic integrative non-negative matrix factorization (UINMF) (.R. Kriebel, 2022) using block coordinate descent (alternating non-negative least squares, ANLS) return factorized \\(H\\), \\(W\\), \\(V\\) \\(U\\) matrices. objective function stated $$\\arg\\min_{H\\ge0,W\\ge0,V\\ge0,U\\ge0}\\sum_{}^{d} ||\\begin{bmatrix}E_i \\\\ P_i \\end{bmatrix} - (\\begin{bmatrix}W \\\\ 0 \\end{bmatrix}+ \\begin{bmatrix}V_i \\\\ U_i \\end{bmatrix})Hi||^2_F+ \\lambda_i\\sum_{}^{d}||\\begin{bmatrix}V_i \\\\ U_i \\end{bmatrix}H_i||_F^2$$ \\(E_i\\) input non-negative matrix \\(\\)'th dataset, \\(P_i\\) input non-negative matrix unshared features, \\(d\\) total number datasets. \\(E_i\\) size \\(m \\times n_i\\) \\(m\\) shared features \\(n_i\\) cells, \\(P_i\\) size \\(u_i \\times n_i\\) \\(u_i\\) unshared feaetures, \\(H_i\\) size \\(k \\times n_i\\), \\(V_i\\) size \\(m \\times k\\), \\(W\\) size \\(m \\times k\\) \\(U_i\\) size \\(u_i \\times k\\). factorization produces shared \\(W\\) matrix (genes k). dataset, \\(H\\) matrix (k cells), \\(V\\) matrix (genes k) \\(U\\) matrix (unshared genes k). \\(H\\) matrices represent cell factor loadings. \\(W\\) held consistent among datasets, represents shared components metagenes across datasets. \\(V\\) matrices represent dataset-specific components metagenes, \\(U\\) matrices similar \\(V\\)s represents loading contributed unshared features. function adopts highly optimized fast memory efficient implementation extended Planc (Kannan, 2016). Pre-installation extension package RcppPlanc required. underlying algorithm adopts identical ANLS strategy optimizeALS(unshared = TRUE) old version LIGER.","code":""},{"path":"/reference/runUINMF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"","code":"runUINMF(object, k = 20, lambda = 5, ...)  # S3 method for liger runUINMF(   object,   k = 20,   lambda = 5,   nIteration = 30,   nRandomStarts = 1,   seed = 1,   nCores = 2L,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/runUINMF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"object liger object. run selectGenes unshared = TRUE run scaleNotCenter advance. k Inner dimension factorization (number factors). Generally, higher k needed datasets sub-structure. Default 20. lambda Regularization parameter. Larger values penalize dataset-specific effects strongly (.e. alignment increase lambda increases). Default 5. ... Arguments passed methods wrapped functions. nIteration Total number block coordinate descent iterations perform. Default 30. nRandomStarts Number restarts perform (iNMF objective function non-convex, taking best objective multiple successive initialization recommended). easier reproducibility, increments random seed 1 consecutive restart, future factorization dataset can run one rep necessary. Default 1. seed Random seed allow reproducible results. Default 1. nCores number parallel tasks speed computation. Default 2L. supported platform OpenMP support. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set.","code":""},{"path":"/reference/runUINMF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"liger method - Returns updated input liger object. list \\(H\\) matrices can accessed          getMatrix(object, \"H\") list \\(V\\) matrices can accessed          getMatrix(object, \"V\") \\(W\\) matrix can accessed          getMatrix(object, \"W\") list \\(U\\) matrices can accessed          getMatrix(object, \"U\")","code":""},{"path":"/reference/runUINMF.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"Currently, Seurat S3 method supported UINMF simple solution organizing number miscellaneous matrices single Seurat object. strongly recommend users create liger object specific structure.","code":""},{"path":"/reference/runUINMF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"April R. Kriebel Joshua D. Welch, UINMF performs mosaic integration single-cell multi-omic datasets using nonnegative matrix factorization, Nat. Comm., 2022","code":""},{"path":"/reference/runUINMF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features — runUINMF","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc, useUnsharedDatasets = c(\"ctrl\", \"stim\")) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ✔ ... 0 features selected out of 17 unshared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ ... 0 features selected out of 13 unshared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>  if (!is.null(getMatrix(pbmc, \"scaleUnsharedData\", \"ctrl\")) &&     !is.null(getMatrix(pbmc, \"scaleUnsharedData\", \"stim\"))) {     # TODO: unshared variable features cannot be detected from this example     pbmc <- runUINMF(pbmc) }"},{"path":"/reference/runUMAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform UMAP Dimensionality Reduction — runUMAP","title":"Perform UMAP Dimensionality Reduction — runUMAP","text":"Run UMAP quantile normalized cell factors (result quantileNorm), unnormalized cell factors (result runIntegration)) generate 2D embedding visualization (general dimensionality reduction). option run subset factors. generally recommended use method dimensionality reduction extremely large datasets. underlying UMAP calculation imports uwot umap.","code":""},{"path":"/reference/runUMAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform UMAP Dimensionality Reduction — runUMAP","text":"","code":"runUMAP(   object,   useRaw = NULL,   useDims = NULL,   nDims = 2,   distance = c(\"cosine\", \"euclidean\", \"manhattan\", \"hamming\"),   nNeighbors = 20,   minDist = 0.1,   dimredName = \"UMAP\",   seed = 42,   verbose = getOption(\"ligerVerbose\", TRUE),   k = nDims,   use.raw = useRaw,   dims.use = useDims,   n_neighbors = nNeighbors,   min_dist = minDist,   rand.seed = seed )"},{"path":"/reference/runUMAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform UMAP Dimensionality Reduction — runUMAP","text":"object liger object factorization results. useRaw Whether use un-aligned cell factor loadings (\\(H\\) matrices). Default NULL search quantile-normalized loadings first un-aligned loadings . useDims Index factors use computing UMAP embedding. Default NULL uses factors. nDims Number dimensions reduce . Default 2. distance Character. Metric used measure distance input space. Default \"cosine\", alternative options include: \"euclidean\", \"manhattan\" \"hamming\". nNeighbors Number neighboring points used local approximations manifold structure. Default 10. minDist Numeric. Controls tightly embedding allowed compress points together. Default 0.1. dimredName Name variable cellMeta slot store result matrix. Default \"UMAP\". seed Random seed reproducibility. Default 42. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. k, use.raw, dims.use, n_neighbors, min_dist, rand.seed Deprecated. See Usage section replacement.","code":""},{"path":"/reference/runUMAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform UMAP Dimensionality Reduction — runUMAP","text":"object \"UMAP\" variable updated cellMeta slot whole 2D embedding matrix.","code":""},{"path":"/reference/runUMAP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform UMAP Dimensionality Reduction — runUMAP","text":"nNeighbors, larger values result global structure preserved loss detailed local structure. general parameter often range 5 50, choice 10 15 sensible default. minDist, larger values ensure embedded points evenly distributed, smaller values allow algorithm optimize accurately regard local structure. Sensible values range 0.001 0.5, 0.1 reasonable default.","code":""},{"path":[]},{"path":"/reference/runUMAP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform UMAP Dimensionality Reduction — runUMAP","text":"","code":"pbmc <- runUMAP(pbmcPlot) #> ℹ Generating UMAP on quantile normalized cell factor loadings #> Found more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by ‘spam’ #> Found more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics' #> Also defined by ‘spam’ #> ✔ Generating UMAP on quantile normalized cell factor loadings ... done #>  #> ℹ DimRed \"UMAP\" is now set as default."},{"path":"/reference/scaleNotCenter.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale genes by root-mean-square across cells — scaleNotCenter","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"function scales normalized gene expression data variable genes selected. mean-center data scaling order address non-negativity constraint NMF. Computation applied normalized dataset matrix can form following equation: $$S_{,j}=\\frac{N_{,j}}{\\sqrt{\\sum_{p}^{n}\\frac{N_{,p}^2}{n-1}}}$$ \\(N\\) denotes normalized matrix individual dataset, \\(S\\) output scaled matrix dataset, \\(n\\) number cells dataset. \\(, j\\) denotes specific gene cell index, \\(p\\) cell iterator. Please see detailed section explanation methylation dataset.","code":""},{"path":"/reference/scaleNotCenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"","code":"scaleNotCenter(object, ...)  # S3 method for dgCMatrix scaleNotCenter(object, ...)  # S3 method for ligerDataset scaleNotCenter(   object,   features = NULL,   chunk = 1000,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for ligerMethDataset scaleNotCenter(   object,   features = NULL,   verbose = getOption(\"ligerVerbose\", TRUE),   ... )  # S3 method for liger scaleNotCenter(   object,   useDatasets = NULL,   features = varFeatures(object),   verbose = getOption(\"ligerVerbose\", TRUE),   remove.missing = NULL,   ... )  # S3 method for Seurat scaleNotCenter(   object,   assay = NULL,   layer = \"ligerNormData\",   save = \"ligerScaleData\",   datasetVar = \"orig.ident\",   features = NULL,   ... )"},{"path":"/reference/scaleNotCenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"object liger object, ligerDataset object, dgCMatrix, Seurat object. ... Arguments passed methods. order goes : \"liger\" method calls \"ligerDataset\" method\", calls \"dgCMatrix\" method. \"Seurat\" method directly calls \"dgCMatrix\" method. features Character, numeric logical index choose variable feature scaled. \"liger\" method default uses varFeatures(object). \"ligerDataset\" method default uses features. \"Seurat\" method default uses VariableFeatures(object). chunk Integer. Number maximum number cells chunk, scaling applied HDF5 based dataset. Default 1000. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. useDatasets character vector names, numeric logical vector index datasets scaled centered. Default NULL applies datasets. remove.missing Deprecated. functionality covered parts whole workflow long needed. ignored specified. assay Name assay use. Default NULL uses current active assay. layer Seurat>=4.9.9, name layer retrieve normalized data. Default \"ligerNormData\". older Seurat, always retrieve data slot. save Seurat>=4.9.9, name layer store normalized data. Default \"ligerScaleData\". older Seurat, stored scale.data slot. datasetVar Metadata variable name stores dataset source annotation. Default \"orig.ident\".","code":""},{"path":"/reference/scaleNotCenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"Updated object dgCMatrix method - Returns scaled dgCMatrix object ligerDataset method - Updates scaleData        scaledUnsharedData (unshared variable feature available) slot        object liger method - Updates scaleData        scaledUnsharedData (unshared variable feature available) slot        chosen datasets Seurat method - Adds named layer chosen assay (V5), update  scale.data slot chosen assay (<=V4)","code":""},{"path":"/reference/scaleNotCenter.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"Since scaling genes applied per dataset base, scaling methods apply whole concatenated matrix multiple datasets might considered equivalent alternatives, even options like center set FALSE. Hence implemented efficient solution works circumstance, provided Seurat S3 method.","code":""},{"path":"/reference/scaleNotCenter.html","id":"methylation-dataset","dir":"Reference","previous_headings":"","what":"Methylation dataset","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"gene body mCH proportions negatively correlated gene expression level neurons, need reverse direction methylation data performing integration. simply subtracting values maximum methylation value. resulting values positively correlated gene expression. applied variable genes detected prior. Please make sure argument modal set accordingly running createLiger. way, function can automatically detect take proper action. set, users can still manually equivalent processing done scaleNotCenter(lig, useDataset = c(\"\", \"datasets\")), reverseMethData(lig, useDataset = c(\"meth\", \"datasets\")).","code":""},{"path":"/reference/scaleNotCenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale genes by root-mean-square across cells — scaleNotCenter","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  pbmc <- selectGenes(pbmc) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. pbmc <- scaleNotCenter(pbmc) #> ℹ Scaling dataset \"ctrl\" #> ✔ Scaling dataset \"ctrl\" ... done #>  #> ℹ Scaling dataset \"stim\" #> ✔ Scaling dataset \"stim\" ... done #>"},{"path":"/reference/selectGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"Select a subset of informative genes — selectGenes","title":"Select a subset of informative genes — selectGenes","text":"function identifies highly variable genes dataset combines gene sets (either union intersection) use downstream analysis. Assuming gene expression approximately follows Poisson distribution, function identifies genes gene expression variance given variance threshold (relative mean gene expression). Alternatively, allow selecting desired number genes dataset ranking relative variance, take combination.","code":""},{"path":"/reference/selectGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select a subset of informative genes — selectGenes","text":"","code":"selectGenes(object, thresh = 0.1, nGenes = NULL, alpha = 0.99, ...)  # S3 method for liger selectGenes(   object,   thresh = 0.1,   nGenes = NULL,   alpha = 0.99,   useDatasets = NULL,   useUnsharedDatasets = NULL,   unsharedThresh = 0.1,   combine = c(\"union\", \"intersection\"),   chunk = 1000,   verbose = getOption(\"ligerVerbose\", TRUE),   var.thresh = thresh,   alpha.thresh = alpha,   num.genes = nGenes,   datasets.use = useDatasets,   unshared.datasets = useUnsharedDatasets,   unshared.thresh = unsharedThresh,   tol = NULL,   do.plot = NULL,   cex.use = NULL,   unshared = NULL,   ... )  # S3 method for Seurat selectGenes(   object,   thresh = 0.1,   nGenes = NULL,   alpha = 0.99,   useDatasets = NULL,   layer = \"ligerNormData\",   assay = NULL,   datasetVar = \"orig.ident\",   combine = c(\"union\", \"intersection\"),   verbose = getOption(\"ligerVerbose\", TRUE),   ... )"},{"path":"/reference/selectGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select a subset of informative genes — selectGenes","text":"object liger, ligerDataset Seurat object, normalized data available (scale factor multipled log transformed). thresh Variance threshold used identify variable genes. Higher threshold results fewer selected genes. Liger Seurat S3 methods accept single value vector specific threshold dataset useDatasets.* Default 0.1. nGenes Number genes find dataset. setting , optimize threshold used dataset get nGenes selected features dataset. Accepts single value vector dataset specific setting matching useDataset.* Default NULL optimize. alpha Alpha threshold. Controls upper bound expected mean gene expression. Lower threshold means higher upper bound. Default 0.99. ... Arguments passed methods. useDatasets character vector names, numeric logical vector index datasets use shared variable feature selection. Default NULL uses datasets. useUnsharedDatasets character vector names, numeric logical vector index datasets use finding unshared variable features. Default NULL attempt find unshared features. unsharedThresh thing thresh applied test unshared features. single value datasets useUnsharedDatasets vector dataset-specific setting.* Default 0.1. combine combine variable genes selected datasets. Choose \"union\" \"intersection\". Default \"union\". chunk Integer. Number maximum number cells chunk, gene selection applied HDF5 based dataset. Default 1000. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. var.thresh, alpha.thresh, num.genes, datasets.use, unshared.datasets, unshared.thresh Deprecated. arguments renamed removed future. Please see function usage replacement. tol, .plot, cex.use, unshared Deprecated. Gene variability metric now visualized separated function plotVarFeatures. Users can now set none-NULL useUnsharedDatasets select unshared genes, instead switch unshared . layer input normalized counts . Default \"ligerNormData\". older Seurat, always retrieve data slot. assay Name assay use. Default NULL uses current active assay. datasetVar Metadata variable name stores dataset source annotation. Default \"orig.ident\".","code":""},{"path":"/reference/selectGenes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select a subset of informative genes — selectGenes","text":"Updated object liger method - involved dataset stored  ligerDataset updated featureMeta  slot varUnsharedFeatures slot (requested  useUnsharedDatasets), varFeatures(object)  updated final combined gene set. Seurat method - Final selection updated  Seurat::VariableFeatures(object). Per-dataset information  stored meta.features slot chosen Assay.","code":""},{"path":"/reference/selectGenes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select a subset of informative genes — selectGenes","text":"","code":"pbmc <- normalize(pbmc) #> ℹ Normalizing datasets \"ctrl\" #> ℹ Normalizing datasets \"stim\" #> ✔ Normalizing datasets \"stim\" ... done #>  #> ℹ Normalizing datasets \"ctrl\" #> ✔ Normalizing datasets \"ctrl\" ... done #>  # Select basing on thresholding the relative variance pbmc <- selectGenes(pbmc, thresh = .1) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 168 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 166 features selected out of 249 shared features. #> ✔ Finally 173 shared variable features are selected. # Select specified number for each dataset pbmc <- selectGenes(pbmc, nGenes = c(60, 60)) #> ℹ Selecting variable features for dataset \"ctrl\" #> ✔ ... 60 features selected out of 249 shared features. #> ℹ Selecting variable features for dataset \"stim\" #> ✔ ... 60 features selected out of 249 shared features. #> ✔ Finally 80 shared variable features are selected."},{"path":"/reference/selectGenesVST.html","id":null,"dir":"Reference","previous_headings":"","what":"Select variable genes from one dataset with Seurat VST method — selectGenesVST","title":"Select variable genes from one dataset with Seurat VST method — selectGenesVST","text":"Seurat FindVariableFeatures VST method. allows selection fixed number variable features, applies one dataset. normalization needed advance.","code":""},{"path":"/reference/selectGenesVST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select variable genes from one dataset with Seurat VST method — selectGenesVST","text":"","code":"selectGenesVST(   object,   useDataset,   n = 2000,   loessSpan = 0.3,   clipMax = \"auto\",   useShared = TRUE,   verbose = getOption(\"ligerVerbose\", TRUE) )"},{"path":"/reference/selectGenesVST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select variable genes from one dataset with Seurat VST method — selectGenesVST","text":"object liger object. useDataset names, numeric logical index dataset considered selection. n Number variable features needed. Default 2000. loessSpan Loess span parameter used fitting variance-mean relationship. Default 0.3. clipMax standardization values larger clipMax set clipMax. Default \"auto\" sets value square root number cells. useShared Logical. Whether select genes shared dataset. Default TRUE. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set.","code":""},{"path":"/reference/selectGenesVST.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Select variable genes from one dataset with Seurat VST method — selectGenesVST","text":"Seurat::FindVariableFeatures.default(selection.method = \"vst\")","code":""},{"path":"/reference/selectGenesVST.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select variable genes from one dataset with Seurat VST method — selectGenesVST","text":"","code":"pbmc <- selectGenesVST(pbmc, \"ctrl\", n = 50) #> ℹ Selecting top 50 HVGs with VST method for dataset: \"ctrl\" #> ℹ ... Totally 249 shared genes to be selected from."},{"path":"/reference/sub-liger.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset liger with brackets — sub-liger","title":"Subset liger with brackets — sub-liger","text":"Subset liger brackets","code":""},{"path":"/reference/sub-liger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset liger with brackets — sub-liger","text":"","code":"# S3 method for liger [(x, i, j, ...)"},{"path":"/reference/sub-liger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset liger with brackets — sub-liger","text":"x liger object Feature subscriptor, passed featureIdx subsetLiger. j Cell subscriptor, passed cellIdx subsetLiger. ... Additional arguments passed subsetLiger.","code":""},{"path":"/reference/sub-liger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset liger with brackets — sub-liger","text":"Subset x specified features cells.","code":""},{"path":[]},{"path":"/reference/sub-liger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset liger with brackets — sub-liger","text":"","code":"pbmcPlot[varFeatures(pbmcPlot)[1:10], 1:10] #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>  #> An object of class liger with 10 cells #> datasets(1): ctrl (10 cells)  #> cellMeta(3): dataset, nUMI, leiden_cluster  #> varFeatures(10): ISG15, ID3, RPL11, ..., S100A8  #> dimReds(1): UMAP"},{"path":"/reference/sub-ligerDataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset ligerDataset object — sub-ligerDataset","title":"Subset ligerDataset object — sub-ligerDataset","text":"Subset ligerDataset object","code":""},{"path":"/reference/sub-ligerDataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset ligerDataset object — sub-ligerDataset","text":"","code":"# S3 method for ligerDataset [(x, i, j, ...)"},{"path":"/reference/sub-ligerDataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset ligerDataset object — sub-ligerDataset","text":"x ligerDataset object Numeric, logical index character vector feature names subscribe. Leave missing features. j Numeric, logical index character vector cell IDs subscribe. Leave missing cells. ... Additional arguments passed subsetLigerDataset.","code":""},{"path":"/reference/sub-ligerDataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset ligerDataset object — sub-ligerDataset","text":"given, selected metadata returned; missing, whole cell metadata table S4Vectors::DataFrame class returned.","code":""},{"path":"/reference/sub-ligerDataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset ligerDataset object — sub-ligerDataset","text":"","code":"ctrl <- dataset(pbmc, \"ctrl\") ctrl[1:5, 1:5] #> An object of class ligerDataset with 5 cells #> rawData: 5 features"},{"path":"/reference/sub-sub-liger.html","id":null,"dir":"Reference","previous_headings":"","what":"Get cell metadata variable — sub-sub-liger","title":"Get cell metadata variable — sub-sub-liger","text":"Get cell metadata variable","code":""},{"path":"/reference/sub-sub-liger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get cell metadata variable — sub-sub-liger","text":"","code":"# S3 method for liger [[(x, i, ...)"},{"path":"/reference/sub-sub-liger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get cell metadata variable — sub-sub-liger","text":"x liger object Name numeric index cell meta data fetch ... Anything S4Vectors::DataFrame method allows.","code":""},{"path":"/reference/sub-sub-liger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get cell metadata variable — sub-sub-liger","text":"given, selected metadata returned; missing, whole cell metadata table S4Vectors::DataFrame class returned.","code":""},{"path":"/reference/sub-sub-liger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get cell metadata variable — sub-sub-liger","text":"","code":"# Retrieve whole cellMeta pbmc[[]] #> DataFrame with 600 rows and 7 columns #>                        dataset               barcode      nUMI     nGene #>                       <factor>           <character> <numeric> <integer> #> ctrl_AAACATACCTCGCT.1     ctrl ctrl_AAACATACCTCGCT.1      2151       102 #> ctrl_AAACGGCTCTTCGC.1     ctrl ctrl_AAACGGCTCTTCGC.1      1916       103 #> ctrl_AACACTCTAAGTAG.1     ctrl ctrl_AACACTCTAAGTAG.1      1869        95 #> ctrl_AACCGCCTCAGGAG.1     ctrl ctrl_AACCGCCTCAGGAG.1       733        84 #> ctrl_AACGTTCTTCCGTC.1     ctrl ctrl_AACGTTCTTCCGTC.1       573        76 #> ...                        ...                   ...       ...       ... #> stim_TTCATGACTTATCC.1     stim stim_TTCATGACTTATCC.1      1091       101 #> stim_TTCATGACTTCAGG.1     stim stim_TTCATGACTTCAGG.1       431        86 #> stim_TTCGGAGATTTCAC.1     stim stim_TTCGGAGATTTCAC.1      1344       102 #> stim_TTGACACTTCCTGC.1     stim stim_TTGACACTTCCTGC.1      1423       105 #> stim_TTTGCATGAACGAA.1     stim stim_TTTGCATGAACGAA.1      2818       120 #>                            mito      ribo      hemo #>                       <numeric> <numeric> <numeric> #> ctrl_AAACATACCTCGCT.1         0  10.83217         0 #> ctrl_AAACGGCTCTTCGC.1         0  20.25052         0 #> ctrl_AACACTCTAAGTAG.1         0   5.08293         0 #> ctrl_AACCGCCTCAGGAG.1         0  42.70123         0 #> ctrl_AACGTTCTTCCGTC.1         0  38.04538         0 #> ...                         ...       ...       ... #> stim_TTCATGACTTATCC.1         0   8.61595         0 #> stim_TTCATGACTTCAGG.1         0  41.29930         0 #> stim_TTCGGAGATTTCAC.1         0   8.85417         0 #> stim_TTGACACTTCCTGC.1         0  11.94659         0 #> stim_TTTGCATGAACGAA.1         0   9.43932         0 # Retrieve a variable pbmc[[\"dataset\"]] #>   [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #>  [16] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #>  [31] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #>  [46] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #>  [61] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #>  [76] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #>  [91] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [106] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [121] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [136] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [151] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [166] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [181] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [196] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [211] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [226] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [241] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [256] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [271] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [286] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl #> [301] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [316] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [331] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [346] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [361] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [376] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [391] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [406] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [421] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [436] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [451] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [466] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [481] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [496] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [511] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [526] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [541] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [556] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [571] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> [586] stim stim stim stim stim stim stim stim stim stim stim stim stim stim stim #> Levels: ctrl stim"},{"path":"/reference/subsetLiger.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset liger object — subsetLiger","title":"Subset liger object — subsetLiger","text":"function subsets liger object character feature index valid cell index. datasets based HDF5, filenames subset H5 files automatically generated now. Feature subsetting based intersection available features datasets involved cellIdx, featureIdx = NULL take intersection (.e. nothing done feature axis). ligerDataset object also allowed now meanwhile, setting filename supported.","code":""},{"path":"/reference/subsetLiger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset liger object — subsetLiger","text":"","code":"subsetLiger(   object,   featureIdx = NULL,   cellIdx = NULL,   useSlot = NULL,   chunkSize = 1000,   verbose = getOption(\"ligerVerbose\", TRUE),   newH5 = TRUE,   returnObject = TRUE,   ... )"},{"path":"/reference/subsetLiger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset liger object — subsetLiger","text":"object liger ligerDataset object. featureIdx Character vector. Missing NULL features. cellIdx Character, logical numeric index can subscribe cells. Missing NULL cells. useSlot slot(s) consider. Choose one \"rawData\", \"normData\" \"scaleData\". Default NULL subsets whole object including analysis result matrices. chunkSize Integer. Number maximum number cells chunk, Default 1000. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. newH5 Whether create new H5 files disk subset datasets involved datasets object HDF5 based. TRUE writes new ones, FALSE returns memory data. returnObject Logical, whether return liger object result. Default TRUE. FALSE returns list containing requested values. ... Arguments passed subsetLigerDataset","code":""},{"path":"/reference/subsetLiger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset liger object — subsetLiger","text":"Subset object","code":""},{"path":[]},{"path":"/reference/subsetLiger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset liger object — subsetLiger","text":"","code":"pbmc.small <- subsetLiger(pbmc, cellIdx = pbmc$nUMI > 200) #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>  pbmc.small <- pbmc[, pbmc$nGene > 50] #> ℹ Subsetting dataset: \"ctrl\" #> ℹ Subsetting dataset: \"stim\" #> ✔ Subsetting dataset: \"stim\" ... done #>  #> ℹ Subsetting dataset: \"ctrl\" #> ✔ Subsetting dataset: \"ctrl\" ... done #>"},{"path":"/reference/subsetLigerDataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset ligerDataset object — subsetLigerDataset","title":"Subset ligerDataset object — subsetLigerDataset","text":"function subsets ligerDataset object valid feature cell indices. HDF5 based object, options available subsetting data memory new -disk H5 file. Feature cell subscription always based size rawData. Therefore, feature subsetting scaled data, usually contains already subset features, select intersection wanted features set available scaled data.","code":""},{"path":"/reference/subsetLigerDataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset ligerDataset object — subsetLigerDataset","text":"","code":"subsetLigerDataset(   object,   featureIdx = NULL,   cellIdx = NULL,   useSlot = NULL,   newH5 = TRUE,   filename = NULL,   filenameSuffix = NULL,   chunkSize = 1000,   verbose = getOption(\"ligerVerbose\", TRUE),   returnObject = TRUE,   ... )  subsetH5LigerDataset(   object,   featureIdx = NULL,   cellIdx = NULL,   useSlot = NULL,   newH5 = TRUE,   filename = NULL,   filenameSuffix = NULL,   chunkSize = 1000,   verbose = getOption(\"ligerVerbose\", TRUE),   returnObject = TRUE )  subsetMemLigerDataset(   object,   featureIdx = NULL,   cellIdx = NULL,   useSlot = NULL,   returnObject = TRUE )"},{"path":"/reference/subsetLigerDataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset ligerDataset object — subsetLigerDataset","text":"object ligerDataset object. HDF5 based object using subsetH5LigerDataset, -memory data subsetMemLigerDataset. featureIdx Character, logical numeric index can subscribe features. Missing NULL features. cellIdx Character, logical numeric index can subscribe cells. Missing NULL cells. useSlot slot(s) consider. Choose one \"rawData\", \"normData\" \"scaleData\". Default NULL subsets whole object including analysis result matrices. newH5 Whether create new H5 file disk subset dataset object HDF5 based. TRUE writes new one, FALSE returns memory data. filename Filename new H5 file created. Default NULL adds suffix \".subset_{yymmdd_HHMMSS}.h5\" original name. filenameSuffix Instead specifying exact filename, set suffix new files new filename looks like original.h5.[suffix].h5. Default NULL. chunkSize Integer. Number maximum number cells chunk, Default 1000. verbose Logical. Whether show information progress. Default getOption(\"ligerVerbose\") TRUE users set. returnObject Logical, whether return ligerDataset object result. Default TRUE. FALSE returns list containing requested values. ... Arguments passed subsetH5LigerDataset","code":""},{"path":"/reference/subsetLigerDataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset ligerDataset object — subsetLigerDataset","text":"Subset object","code":""},{"path":"/reference/subsetLigerDataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset ligerDataset object — subsetLigerDataset","text":"","code":"ctrl <- dataset(pbmc, \"ctrl\") ctrl.small <- subsetLigerDataset(ctrl, cellIdx = 1:5) ctrl.tiny <- ctrl[1:5, 1:5]"},{"path":"/news/index.html","id":"rliger-199","dir":"Changelog","previous_headings":"","what":"rliger 1.9.9","title":"rliger 1.9.9","text":"Added ligerDataset class per-dataset information storage, inheritance specific modalities Added number plotting functions clear function names useful functionality Added Leiden clustering method, now default rather Louvain Added pseudo-bulk DEG method Added gene name pattern expression percentage QC metric Added native Seurat object support core integration workflow Added documentation website built pkgdown Changed liger object class structure Changed iNMF (previously optimizeALS()), UINMF (previously optimizeALS(unshared = TRUE)) online iNMF (previously online_iNMF()) implementation vastly improved performance. Now named runINMF(), runUINMF() runOnlineINMF() respectively, wrapped runIntegration().","code":""},{"path":"/news/index.html","id":"rliger-101","dir":"Changelog","previous_headings":"","what":"rliger 1.0.1","title":"rliger 1.0.1","text":"CRAN release: 2023-11-08 Allow setting mito pattern getMitoProportion() #271 Fix efficiency issue taking log norm.data (e.g. runWilcoxon) Add runable examples exported functions possible Fix typo online_iNMF matrix initialization Adapt Seurat5 minor fixes","code":""}]
