---
title: "Integrating STARmap spatial transcriptomic and scRNA datasets using UINMF"
author: "April Kriebel and Joshua Welch"
date: "12/03/2021"
output: html_document
---

```{r eval = FALSE}
options(rgl.useNULL=TRUE)
library(rgl)
library(rglwidget)
library(viridis)
knit_hooks$set(webgl = hook_webgl)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
options(rgl.useNULL=TRUE)
library(rgl)
library(rglwidget)
library(viridis)
```

Here we demonstrate integrating a scRNA (Dropviz) dataset of the mouse frontal cortex and a spatial transcriptomics (STARmap) dataset of the same region. For this tutorial, we prepared the two datasets at  https://www.dropbox.com/sh/y9kjoum8u469nj1/AADik2b2-Qo3os2QSWXdIAbna?dl=0

- The scRNA mouse dataset (Dropviz_starmap_vig.RDS) is 28,366 genes by 71,639 cells.
- The spatial transcriptomic STARmap dataset (STARmap_vig.RDS) is 28 genes by 31,294 cells. 
- The annotation data of the Dropviz mouse data (Dropviz_general_annotations.RDS).

## Step 1: Load the data

### 1. Create liger object

The datasets provided are presented in "dgCMatrix" class, which is a common form of sparse matrix in R. We can then create a liger object with a named list of the matrices. The unshared features should not be subsetted out, or submitted separately. Rather, they should be included in the matrix submitted for that dataset. This helps ensure proper normalization.

```{r load}
library(rliger2)

dropviz <- readRDS("starmap_data/Dropviz_starmap_vig.RDS")
starmap <- readRDS("starmap_data/STARmap_vig.RDS")

lig <- createLiger(list(starmap = starmap, dropviz = dropviz))
```

## Step 2: Preprocessing and normalization

### 2. Normalization

Normalize the datasets. The normalization is applied to the datasets in their entirety.

```{r normalize}
lig <- normalize(lig)
```

### 3. Select variable genes

Given that the STARmap dataset has only 28 genes available and these are also presented in the Dropviz dataset, we directly set all of them as shared variable genes. Please use `varFeatures<-()` method for accessing the shared variable genes. For the Dropviz dataset, we further select variable genes from the unshared part of it. To enable selection of unshared genes, users need to specify the name(s) of dataset(s) where unshared genes should be chosen from to `useUnsharedDatasets`. 

```{r selectvargenes, message=TRUE}
lig <- selectGenes(lig, thresh = 0.3, useUnsharedDatasets = "dropviz", unsharedThresh = 0.3)
varFeatures(lig) <- rownames(dataset(lig, "starmap"))
```

### 4. Scale not center

Then we scale the dataset. Three new matrices will be created under the hook, two containing the 28 shared variable features for both datasets, and one for the unshared variable features of Dropviz data. Note the LIGER does not center the scaled data because iNMF/UINMF methods require non-negative input. 

```{r scale}
lig <- scaleNotCenter(lig)
```

# Step 3: Joint Matrix Factorization

### 5. Mosaic integrative NMF

Unshared Integrative Non-negative Matrix Factorization (UINMF) can be applied with `runIntegration(..., method = "UINMF")`. A standalone function `runUINMF()` is also provided with more detailed documentation and initialization setup. This step produces factor gene loading matrices of the shared genes: $W$ for shared information across datasets, and $V$ for dataset specific information. Specific to UINMF method, additional factor gene loading matrix of unshared genes, $U$ is also produced. $H$ matrices, the cell factor loading matrices are produced for each dataset and can be interpreted as load rank representation of the cells.

In this tutorial, we set dataset specific lambda (regularization parameter) values to penalize the dataset specific effect differently. 

Another noteworthy advantage of UINMF is that we are able to use a larger number of factors than there are shared features. We captilize on this by changing the default value of `k` to 40. 

```{r factorization}
lig <- runUINMF(lig, k = 40, lambda = c(10, 1))
```
# Step 4: Quantile Normalization and Joint Clustering

After factorization, the resulting Liger object can used in all downstream LIGER functions without adjustment. The default reference dataset for quantile normalization is the larger dataset, but the user should select the higher quality dataset as the reference dataset, even if it is the smaller dataset. In this case, the Dropviz dataset is considered higher quality than the STARmap dataset, so we set the Dropviz dataset to be the reference dataset.


```{r quantilenorm, results = FALSE}
liger <- quantile_norm(liger, ref_dataset = "dropviz")
liger <- louvainCluster(liger)
```
# Step 5: Visualizations and Downstream processing

```{r runumap, results = FALSE, warnings = FALSE, message = FALSE}
liger <- runUMAP(liger, n_neighbors = 35)
```
Next, we can visualize our returned factorized object by dataset to check the alignment between datasets.
```{r visualizations, message = FALSE, warning = FALSE}
umap_plots <-plotByDatasetAndCluster(liger, axis.labels = c("UMAP1","UMAP2"), return.plots = TRUE)
umap_plots[[1]]
umap_plots[[2]] 
```
\
We can also use the Dropviz labels to help us annotate the clusters.

```{r loadmouse, eval = FALSE}
mouse_annies = readRDS("Dropviz_general_annotations.RDS")

```

```{r visualizationspt2, message = FALSE, warning = FALSE}
umap_plots <-plotByDatasetAndCluster(liger, axis.labels = c("UMAP1","UMAP2"), return.plots = TRUE, clusters = mouse_annies)
umap_plots[[2]] 
```
\
# Step 6: Annotations and visualization within a 3D space
Here we demonstrate how to use the annotation labels derived from the above analysis within the context of 3D space.
We provide the annotation labels for the sake of simplicity. These labels were generated using the high quality Dropviz annotationsto re-annotate the STARmap cells after completing the above analysis. We have provided the exact annotations and colors used in the publication such that the interested user may captilize on the 3D dimensional sample space. 
```{r loadlabels, include = FALSE}
coords_annotations_3d <- readRDS("C:/Users/april/OneDrive/Documents/UINMF_Final_backups/Vignette/Dropviz_Starmap/STARmap_3D_Annotations.RDS")

```

```{r eval = FALSE}
coords_annotations_3d <- readRDS("STARmap_3D_Annotations.RDS")
```
Here we graph all of the cells:
```{r testgl, webgl = TRUE, warning = FALSE}
rgl.viewpoint(theta = 25, phi = 5, zoom = 0.7)
plot3d(x=coords_annotations_3d$Coord1, y=coords_annotations_3d$Coord2, z=coords_annotations_3d$Coord3, xlab="", ylab = "", zlab ="",col = coords_annotations_3d$Cell_Type_Color, size = 2, axes= FALSE, labels = FALSE)
aspect3d(1.7,1.4,0.1)
first = c(0)
second = c(0)
bg3d("black", labels = FALSE)
axes3d(edges = "bbox",col='white', labels=FALSE, tick=FALSE)
```

Graph just the neuronal cells

```{r neuronal, webgl = TRUE, warning=FALSE}
neuronal_cells <- filter(coords_annotations_3d , coords_annotations_3d$General_Class == "Neuron")
plot3d(x=neuronal_cells$Coord1, y=neuronal_cells$Coord2, z=neuronal_cells$Coord3, xlab="", ylab = "", zlab ="", col = neuronal_cells$Sub_Color, size = 3, axes= FALSE, labels = FALSE)
aspect3d(1.7,1.4,0.1)
first = c(0)
second = c(0)
bg3d("black", labels = FALSE)
axes3d(edges = "bbox",col='white', labels=FALSE, tick=FALSE)
```
Graph just the interneurons
```{r interneurons, webgl = TRUE, warning=FALSE}
interneuron_cells <- filter(coords_annotations_3d , coords_annotations_3d$General_Class == "Interneuron")
plot3d(x=interneuron_cells$Coord1, y=interneuron_cells$Coord2, z=interneuron_cells$Coord3, xlab="", ylab = "", zlab ="", col = interneuron_cells$Sub_Color, size = 3, axes= FALSE, labels = FALSE)
aspect3d(1.7,1.4,0.1)
first = c(0)
second = c(0)
bg3d("black", labels = FALSE)
axes3d(edges = "bbox",col='white', labels=FALSE, tick=FALSE)
```
Graph just the oligodendrocytes and polydendrocytes
```{r polyol, webgl = TRUE, warning=FALSE}
oligo_poly_cells <- filter(coords_annotations_3d , coords_annotations_3d$General_Class == "Oligo_Poly")
plot3d(x=oligo_poly_cells$Coord1, y=oligo_poly_cells$Coord2, z=oligo_poly_cells$Coord3, xlab="", ylab = "", zlab ="", col = oligo_poly_cells$Sub_Color, size = 3, axes= FALSE, labels = FALSE)
aspect3d(1.7,1.4,0.1)
first = c(0)
second = c(0)
bg3d("black", labels = FALSE)
axes3d(edges = "bbox",col='white', labels=FALSE, tick=FALSE)
```
Graph only the endothelial cells
```{r endo, webgl = TRUE, warning = FALSE}
endo_cells <- filter(coords_annotations_3d , coords_annotations_3d$General_Class == "Endothelial")
plot3d(x=endo_cells$Coord1, y=endo_cells$Coord2, z=endo_cells$Coord3, xlab="", ylab = "", zlab ="", col = endo_cells$Sub_Color, size = 3, axes= FALSE, labels = FALSE)
aspect3d(1.7,1.4,0.1)
first = c(0)
second = c(0)
bg3d("black", labels = FALSE)
axes3d(edges = "bbox",col='white', labels=FALSE, tick=FALSE)
```

