---
title: "Joint definition of cell types from multiple scRNA-seq datasets"
author: "Joshua Sodicoff and Joshua Welch"
date: "2023-02-27"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)
```

This guide will demonstrate the usage of the Liger package in the style of the R Console, which can be accessed through an R development environment (e.g., RStudio) or directly from the R command line.

## Stage I: Preprocessing and Normalization (3 - 5 seconds)

### 1. Read data into memory

For the first portion of this protocol, we will be integrating data from control and interferon-stimulated PBMCs from [Kang et al, 2017](https://www.nature.com/articles/nbt.4042). The data can be found in the Gene Expression Omnibus, [Series GSE96583](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE96583). This dataset was originally in the form of output from the 10X Cellranger pipeline, though we will directly load downsampled versions of the control and stimulated DGEs here.

**For convenience, we have prepared the pre-processed data which are ready to use.** There are three datasets: "PBMC_control.RDS" and "PBMC_interferon-stimulated.RDS", which correspond to control and interferon-stimulated PBMCs individually. The data can be downloaded [here](https://www.dropbox.com/sh/u94ib3dkf9pb6nd/AABemvnxDgKDGRs8Ek5QGlXWa?dl=0).

```{r, results='hide'}
library(rliger)
ctrl_dge <- readRDS("../pbmcs_ctrl.RDS");
stim_dge <- readRDS("../pbmcs_stim.RDS");
```

For 10X CellRanger output, we can instead use the `read10X()` function, which generates a matrix or list of matrices directly from the output directories.

```{r Count, eval = FALSE}
matrix_list <- read10X(sample.dirs =c("10x_ctrl_outs", "10x_stim_outs"), sample.names = c("ctrl", "stim"), merge = F);
```

### 2. Create liger obejct

With the digital gene expression matrices for both datasets, we can initialize a Liger object using the `createLiger()` function.

```{r Count-3, results='hide'}
ifnb_liger <- createLiger(list(ctrl = ctrl_dge, stim = stim_dge))
```

`ifnb_liger` now contains two datasets in its raw.data slot, ctrl and stim. We can run the rest of the analysis on this Liger object.

### 3. Preprocess

Before we can run iNMF on our datasets, we must run several preprocessing steps to normalize expression data to account for differences in sequencing depth and efficiency between cells, identify variably expressed genes, and scale the data so that each gene has the same variance. Note that because nonnegative matrix factorization requires positive values, we do not center the data by subtracting the mean. We also do not log transform the data.

```{r Count-5,results='hide'}
ifnb_liger <- normalize(ifnb_liger)
ifnb_liger <- selectGenes(ifnb_liger)
ifnb_liger <- scaleNotCenter(ifnb_liger)
```

### 4. Determine the parameters 

We are now able to run integrative non-negative matrix factorization on the normalized and scaled datasets. The key parameter for this analysis is k, the number of matrix factors (analogous to the number of principal components in PCA). In general, we find that a value of k between 20 and 40 is suitable for most analyses and that results are robust for choice of k. Because LIGER is an unsupervised, exploratory approach, there is no single "right" value for k, and in practice, users choose k from a combination of biological prior knowledge and other information.

## Stage II: Joint Matrix Factorization (3 - 10 minutes)

```{r Count-6, results='hide'}
ifnb_liger <- optimizeALS(ifnb_liger, k = 20)
```

Important parameters are as follows:

* *k* - Integer value specifying the inner dimension of factorization, or number of factors. Higher k is recommended for datasets with more substructure. We find that a value of k in the range 20 - 40 works well for most datasets. Because this is an unsupervised, exploratory analysis, there is no single "right" value for k, and in practice, users choose k from a combination of biological prior knowledge and other information.
* *lambda* - This is a regularization parameter. Larger values penalize dataset-specific effects more strongly, causing the datasets to be better aligned, but possibly at the cost of higher reconstruction error. Default `5`. We recommend using this value for most analyses, but find that it can be lowered to 1 in cases where the dataset differences are expected to be relatively small, such as scRNA-seq data from the same tissue but different individuals.
* *thresh* - This sets the convergence threshold. Lower values cause the algorithm to run longer. Default `1e-6`.
* *maxIter* - This variable sets the maximum number of iterations to perform. Default `30`.

The optimization yields several lower dimension matrices, including the $H$ matrix of metagene loadings for each cell, the $W$ matrix of shared factor loadings and the $V$ matrices of dataset-specific factor loadings.

Please note that the time required of this step is highly dependent on the size of the datasets being used. In most cases, this step should not take much longer than 30 minutes.

## Stage III: Quantile Normalization and Joint Clustering (1 minute)

### 5. Align the factors

We can now use the resulting factors to jointly cluster cells and perform quantile normalization by dataset, factor, and cluster to fully integrate the datasets. All of this functionality is encapsulated within the `quantileNorm()` function, which uses max factor assignment followed by refinement using a k-nearest neighbors graph.

```{r loading-1, results='hide'}
ifnb_liger <- quantileNorm(ifnb_liger)
```

Important parameters of `quantileNorm()` are as follows:

* *`nNeighbors`* - This sets the number of nearest neighbors for within-dataset KNN graph. Default `20`.
* *`quantiles`* - This sets the number of quantiles to use for quantile normalization. Default `50`.
* *`minCells`* - This indicates the minimum number of cells to consider a cluster as shared across datasets. Default `20`.
* *`useDims`* - This sets the indices of factors to use for quantile normalization. The user can pass in a vector of indices indicating specific factors. This is helpful for excluding factors capturing biological signals such as the cell cycle or technical signals such as mitochondrial genes. The default is all k of the factors. 
* *`center`* - This indicates whether to center the data when scaling factors. Default `FALSE`. This option should be set to `TRUE` when metagene loadings have a mean above zero, as with dense data such as DNA methylation.
* *`maxSample`* - This sets the maximum number of cells used for quantile normalization of each cluster and factor. Default `1000`.
* *`refineKNN`* - This indicates whether to increase robustness of cluster assignments using KNN graph. Default `TRUE`.
* *`eps`* - This sets the error bound of the nearest neighbor search. The default is `0.9`. Lower values give more accurate nearest neighbor graphs but take much longer to computer.
* *`reference`* - This indicates the name of the dataset to be used as a reference for quantile normalization. By default, the dataset with the largest number of cells is used.

### 6. Clustering

The `quantileNorm()` procedure produces joint clustering assignments and a low-dimensional representation that integrates the datasets together. These joint clusters directly from iNMF can be used for downstream analyses (see below). Alternatively, you can also run Louvain community detection, an algorithm commonly used for single-cell data, on the normalized cell factors. The Louvain algorithm excels at merging small clusters into broad cell classes and thus may be more desirable in some cases than the maximum factor assignments produced directly by iNMF.

```{r loading-2, results='hide'}
ifnb_liger <- louvainCluster(ifnb_liger, resolution = 0.25, nNeighbors = 30)
```

## Stage IV: Visualization (2 - 3 minutes) and Downstream Analysis (25 - 40 seconds)

### 7. Generate dimensionality reduced embedding

To visualize the clustering of cells graphically, we can project the normalized cell factors to two or three dimensions. Liger supports both t-SNE and UMAP for this purpose. Note that if both techniques are run, the object will only hold the results from the most recent.

```{r pre-1, results='hide'}
ifnb_liger <- runUMAP(ifnb_liger, distance = 'cosine', n_neighbors = 30, min_dist = 0.3)
```

The `rliger` package implements a variety of utilities for visualization and analysis of clustering, gene expression across datasets, and comparisons of cluster assignments. We will summarize several here.

### 8. Create plots 

`plotByDatasetAndCluster()` returns two graphs, generated by t-SNE or UMAP in the previous step. The first colors cells by dataset of origin, and the second by cluster as determined by Liger. The plots provide visual confirmation that the datasets are well aligned and the clusters are consistent with the shape of the data as revealed by UMAP.

```{r 4-1, fig.align='center', fig.width=10}
plotByDatasetAndCluster(ifnb_liger)
```

To directly study the impact of factors on the clustering and determine what genes load most highly on each factor, we use the plotGeneLoadings function, which returns plots of factor loading on the dimensionally reduced graphs and highly loaded genes by dataset for each factor.

```{r, results='hide', fig.keep='all', fig.align='center', fig.height=7}
factorMarkers <- getFactorMarkers(ifnb_liger, dataset1 = "ctrl", dataset2 = "stim")
plotGeneLoadings(ifnb_liger, markerTable = factorMarkers, useFactor = 4)
```

Using the `runWilcoxon()` function, we can next identify gene markers for all clusters. We can also compare expression within each cluster across datasets, which in this case reveals markers of interferon-beta stimulation. The function returns a table of data that allows us to determine the significance of each geneâ€™s differential expression, including log fold change, area under the curve and p-value.

```{r 4-2}
cluster.results <- runWilcoxon(ifnb_liger, method = "clusters")
head(cluster.results)
```

```{r datasets}
datasets.results <- runWilcoxon(ifnb_liger, method = "datasets")
head(datasets.results)
```

The number of significant genes identified by `runWilcoxon()` varies and depends on the datasets used. You can then filter the markers which are statistically and biologically significant. For example, one strategy is to filter the output by taking markers which have padj (Benjamini-Hochberg adjusted p-value) less than 0.05 and logFC (log fold change between observations in group versus out) larger than 3:

```{r}
cluster.results <- cluster.results[cluster.results$padj < 0.05,]
cluster.results <- cluster.results[cluster.results$logFC > 3,]
```

You can then re-sort the markers by its padj value in ascending order and choose the top 100 for each cell type. For example, we can subset and re-sort the output for Cluster 3 and take the top 20 markers by typing these commands:

```{r}
wilcoxon.cluster_3 <- cluster.results[cluster.results$group == 3, ]
wilcoxon.cluster_3 <- wilcoxon.cluster_3[order(wilcoxon.cluster_3$padj), ]
markers <- wilcoxon.cluster_3[1:20, ]
head(markers)
```

We can then visualize the expression profiles of individual genes, such as the differentially expressed genes that we just identified. This allows us to visually confirm the cluster- or dataset-specific expression patterns of marker genes. `plotGeneDimRed()` returns graphs of gene loading on the dimensionality reduced graph for each dataset.

```{r, paged.print=FALSE, fig.align='center', fig.width=10}
PRF1 <- plotGeneDimRed(ifnb_liger, "PRF1", splitBy = "dataset")
cowplot::plot_grid(plotlist = PRF1, labels = names(ifnb_liger))
```

We can also use `plotGeneDimRed()` to compare the loading of cluster markers within and between datasets.

```{r, paged.print=FALSE, fig.align='center', fig.height=9, fig.width=9}
IFIT3 <- plotGeneDimRed(ifnb_liger, "IFIT3", splitBy = "dataset")
IFITM3 <- plotGeneDimRed(ifnb_liger, "IFITM3", splitBy = "dataset")
cowplot::plot_grid(IFIT3[[1]], IFIT3[[2]], IFITM3[[1]], IFITM3[[2]], ncol = 2, labels = c("ctrl", "stim", "ctrl", "stim"))
```

## R Session Info

```{r rsession, echo=FALSE}
utils::sessionInfo()
```
