#' @importFrom Matrix colSums
NULL

#' Read 10X alignment data (including V3)
#'
#' This function generates a sparse matrix (genes x cells) from the data generated by 10X's
#' cellranger count pipeline. It can process V2 and V3 data together, producing either a single
#' merged matrix or list of matrices. Also handles multiple data types produced by 10X V3 (Gene
#' Expression, Antibody Capture, CRISPR, CUSTOM).
#'
#' @param sample.dirs List of directories containing either matrix.mtx(.gz) file along with genes.tsv,
#'   (features.tsv), and barcodes.tsv, or outer level 10X output directory (containing outs directory).
#' @param sample.names Vector of names to use for samples (corresponding to sample.dirs)
#' @param merge Whether to merge all matrices of the same data type across samples or leave as list
#'   of matrices (default TRUE).
#' @param num.cells Optional limit on number of cells returned for each sample (only for Gene
#'   Expression data). Retains the cells with the highest numbers of transcripts (default NULL).
#' @param min.umis Minimum UMI threshold for cells (default 0).
#' @param use.filtered Whether to use 10X's filtered data (as opposed to raw). Only relevant for
#'   sample.dirs containing 10X outs directory (default FALSE).
#' @param reference For 10X V<3, specify which reference directory to use if sample.dir is outer
#'   level 10X directory (only necessary if more than one reference used for sequencing).
#'   (default NULL)
#' @param data.type Indicates the protocol of the input data. If not specified, input data will be
#' considered scRNA-seq data (default 'rna', alternatives: 'atac').
#' @param verbose Print messages (TRUE by default)
#'
#' @return List of merged matrices across data types (returns sparse matrix if only one data type
#'   detected), or nested list of matrices organized by sample if merge=F.
#'
#' @import Matrix
#' @importFrom utils read.delim read.table
#'
#' @export
#' @examples
#' \dontrun{
#' # 10X output directory V2 -- contains outs/raw_gene_bc_matrices/<reference>/...
#' sample.dir1 <- "path/to/outer/dir1"
#' # 10X output directory V3 -- for two data types, Gene Expression and CUSTOM
#' sample.dir2 <- "path/to/outer/dir2"
#' dges1 <- read10X(list(sample.dir1, sample.dir2), c("sample1", "sample2"), min.umis = 50)
#' ligerex <- createLiger(expr = dges1[["Gene Expression"]], custom = dges1[["CUSTOM"]])
#' }

read10X <-
    function(sample.dirs,
             sample.names,
             merge = TRUE,
             num.cells = NULL,
             min.umis = 0,
             use.filtered = FALSE,
             reference = NULL,
             data.type = "rna",
             verbose = TRUE) {
        datalist <- list()
        datatypes <- c("Gene Expression")

        if (length(num.cells) == 1) {
            num.cells <- rep(num.cells, length(sample.dirs))
        }
        for (i in seq_along(sample.dirs)) {
            print(paste0("Processing sample ", sample.names[i]))
            sample.dir <- sample.dirs[[i]]
            inner1 <- paste0(sample.dir, "/outs")
            if (dir.exists(inner1)) {
                sample.dir <- inner1
                is_v3 <-
                    dir.exists(paste0(sample.dir, "/filtered_feature_bc_matrix"))
                matrix.prefix <- ifelse(use.filtered, "filtered", "raw")
                if (is_v3) {
                    sample.dir <-
                        paste0(sample.dir,
                               "/",
                               matrix.prefix,
                               "_feature_bc_matrix")
                } else {
                    if (is.null(reference)) {
                        references <- list.dirs(
                            paste0(sample.dir, "/raw_gene_bc_matrices"),
                            full.names = FALSE,
                            recursive = FALSE
                        )
                        if (length(references) > 1) {
                            stop(
                                "Multiple reference genomes found. Please specify a single one."
                            )
                        } else {
                            reference <- references[1]
                        }
                    }
                    sample.dir <-
                        paste0(sample.dir,
                               "/",
                               matrix.prefix,
                               "_gene_bc_matrices/",
                               reference)
                }
            } else {
                is_v3 <- file.exists(paste0(sample.dir, "/features.tsv.gz"))
            }
            suffix <- ifelse(is_v3, ".gz", "")
            if (data.type == "rna") {
                features.file <-
                    ifelse(
                        is_v3,
                        paste0(sample.dir, "/features.tsv.gz"),
                        paste0(sample.dir, "/genes.tsv")
                    )
            } else if (data.type == "atac") {
                features.file <- ifelse(
                    is_v3,
                    paste0(sample.dir, "/peaks.bed.gz"),
                    paste0(sample.dir, "/peaks.bed")
                )
            }
            matrix.file <- paste0(sample.dir, "/matrix.mtx", suffix)
            barcodes.file <- paste0(sample.dir, "/barcodes.tsv", suffix)

            rawdata <- readMM(matrix.file)
            # convert to dgc matrix
            if (class(rawdata)[1] == "dgTMatrix") {
                rawdata <- as(rawdata, "CsparseMatrix")
            }

            # filter for UMIs first to increase speed
            umi.pass <- which(colSums(rawdata) > min.umis)
            if (length(umi.pass) == 0) {
                message("No cells pass UMI cutoff. Please lower it.")
            }
            rawdata <- rawdata[, umi.pass, drop = FALSE]

            barcodes <- readLines(barcodes.file)[umi.pass]
            # Remove -1 tag from barcodes
            if (all(grepl(barcodes, pattern = "\\-1$"))) {
                barcodes <- as.vector(sapply(barcodes, function(x) {
                    strsplit(x, "-")[[1]][1]
                }))
            }
            if (data.type == "rna") {
                features <-
                    read.delim(features.file,
                               header = FALSE,
                               stringsAsFactors = FALSE)
                rownames(rawdata) <- make.unique(features[, 2])
            } else if (data.type == "atac") {
                features <- read.table(features.file, header = FALSE)
                features <-
                    paste0(features[, 1], ":", features[, 2], "-", features[, 3])
                rownames(rawdata) <- features
            }
            # since some genes are only differentiated by ENSMBL
            colnames(rawdata) <- barcodes

            # split based on 10X datatype -- V3 has Gene Expression, Antibody Capture, CRISPR, CUSTOM
            # V2 has only Gene Expression by default and just two columns
            if (is.null(ncol(features))) {
                samplelist <- list(rawdata)
                names(samplelist) <- c("Chromatin Accessibility")
            } else if (ncol(features) < 3) {
                samplelist <- list(rawdata)
                names(samplelist) <- c("Gene Expression")
            } else {
                sam.datatypes <- features[, 3]
                sam.datatypes.unique <- unique(sam.datatypes)
                # keep track of all unique datatypes
                datatypes <- union(datatypes, unique(sam.datatypes))
                samplelist <- lapply(sam.datatypes.unique, function(x) {
                    rawdata[which(sam.datatypes == x),]
                })
                names(samplelist) <- sam.datatypes.unique
            }

            # num.cells filter only for gene expression data
            if (!is.null(num.cells)) {
                if (names(samplelist) == "Gene Expression" |
                    names(samplelist) == "Chromatin Accessibility") {
                    data_label <- names(samplelist)
                    cs <- colSums(samplelist[[data_label]])
                    limit <- ncol(samplelist[[data_label]])
                    if (num.cells[i] > limit) {
                        if (verbose) {
                            message(
                                "You selected more cells than are in matrix ",
                                i,
                                ". Returning all ",
                                limit,
                                " cells."
                            )
                        }
                        num.cells[i] <- limit
                    }
                    samplelist[[data_label]] <-
                        samplelist[[data_label]][, order(cs, decreasing = TRUE)
                                                 [1:num.cells[i]]]
                }

                # cs <- colSums(samplelist[["Gene Expression"]])
                # limit <- ncol(samplelist[["Gene Expression"]])
                # if (num.cells[i] > limit) {
                #   print(paste0(
                #     "You selected more cells than are in matrix ", i,
                #     ". Returning all ", limit, " cells."
                #   ))
                #   num.cells[i] <- limit
                # }
                # samplelist[["Gene Expression"]] <- samplelist[["Gene Expression"]][, order(cs, decreasing = TRUE)
                #                                                                    [1:num.cells[i]]]
            }

            datalist[[i]] <- samplelist
        }
        if (merge) {
            if (verbose) {
                message("Merging samples")
            }
            return_dges <- lapply(datatypes, function(x) {
                mergelist <- lapply(datalist, function(d) {
                    d[[x]]
                })
                mergelist <- mergelist[!sapply(mergelist, is.null)]
                sample.names.x <-
                    sample.names[!sapply(mergelist, is.null)]
                MergeSparseDataAll(mergelist, sample.names)
            })
            names(return_dges) <- datatypes

            # if only one type of data present
            if (length(return_dges) == 1) {
                if (verbose) {
                    message("Returning ", datatypes, " data matrix")
                }
                return(return_dges[[1]])
            }
            return(return_dges)
        } else {
            names(datalist) <- sample.names
            return(datalist)
        }
    }

#' Merge hdf5 files
#'
#' This function merges hdf5 files generated from different libraries (cell ranger by default)
#' before they are preprocessed through Liger pipeline.
#'
#' @param file.list List of path to hdf5 files.
#' @param library.names Vector of library names (corresponding to file.list)
#' @param new.filename String of new hdf5 file name after merging (default new.h5).
#' @param format.type string of HDF5 format (10X CellRanger by default).
#' @param data.name Path to the data values stored in HDF5 file.
#' @param indices.name Path to the indices of data points stored in HDF5 file.
#' @param indptr.name Path to the pointers stored in HDF5 file.
#' @param genes.name Path to the gene names stored in HDF5 file.
#' @param barcodes.name Path to the barcodes stored in HDF5 file.
#'
#' @return Directly generates newly merged hdf5 file.
#'
#' @export
#' @examples
#' \dontrun{
#' # For instance, we want to merge two datasets saved in HDF5 files (10X CellRanger)
#' # paths to datasets: "library1.h5","library2.h5"
#' # dataset names: "lib1", "lib2"
#' # name for output HDF5 file: "merged.h5"
#' mergeH5(list("library1.h5","library2.h5"), c("lib1","lib2"), "merged.h5")
#' }

mergeH5 <- function(file.list,
                    library.names,
                    new.filename,
                    format.type = "10X",
                    data.name = NULL,
                    indices.name = NULL,
                    indptr.name = NULL,
                    genes.name = NULL,
                    barcodes.name = NULL) {
    h5_merged = hdf5r::H5File$new(paste0(new.filename, ".h5"), mode = "w")
    h5_merged$create_group("matrix")
    h5_merged$create_group("matrix/features")
    num_data_prev = 0
    num_indptr_prev = 0
    num_cells_prev = 0
    last_inptr = 0
    for (i in 1:length(file.list)) {
        h5file = hdf5r::H5File$new(file.list[[i]], mode = "r")
        if (format.type == "10X") {
            data = h5file[["matrix/data"]][]
            indices = h5file[["matrix/indices"]][]
            indptr = h5file[["matrix/indptr"]][]
            barcodes = paste0(library.names[i], "_", h5file[["matrix/barcodes"]][])
            genes = h5file[["matrix/features/name"]][]
        } else if (format.type == "AnnData") {
            data = h5file[["raw.X/data"]][]
            indices = h5file[["raw.X/indices"]][]
            indptr = h5file[["raw.X/indptr"]][]
            barcodes = paste0(library.names[i], "_", h5file[["obs"]][]$cell)
            genes = h5file[["raw.var"]][]$index

        } else {
            data = h5file[[data.name]][]
            indices = h5file[[indices.name]][]
            indptr = h5file[[indptr.name]][]
            barcodes = paste0(library.names[i], "_", h5file[[barcodes.name]][])
            genes = h5file[[genes.name]][]
        }

        if (i != 1)
            indptr = indptr[2:length(indptr)]
        num_data = length(data)
        num_indptr = length(indptr)
        num_cells = length(barcodes)
        indptr = indptr + last_inptr
        last_inptr = indptr[num_indptr]
        if (i == 1) {
            h5_merged[["matrix/data"]] = data
            h5_merged[["matrix/indices"]] = indices
            h5_merged[["matrix/indptr"]] = indptr
            h5_merged[["matrix/barcodes"]] = barcodes
            h5_merged[["matrix/features/name"]] = genes
        } else {
            h5_merged[["matrix/data"]][(num_data_prev + 1):(num_data_prev + num_data)] = data
            h5_merged[["matrix/indices"]][(num_data_prev + 1):(num_data_prev + num_data)] = indices
            h5_merged[["matrix/indptr"]][(num_indptr_prev + 1):(num_indptr_prev + num_indptr)] = indptr
            h5_merged[["matrix/barcodes"]][(num_cells_prev + 1):(num_cells_prev + num_cells)] = barcodes
        }
        num_data_prev = num_data_prev + num_data
        num_indptr_prev = num_indptr_prev + num_indptr
        num_cells_prev = num_cells_prev + num_cells
        h5file$close_all()
    }
    h5_merged$close_all()
}


#' Restore links (to hdf5 files) for reloaded online Liger object
#'
#' When loading the saved online Liger object in a new R session, the links to hdf5 files may be corrupted. This functions enables
#' the restoration of those links so that new analyses can be carried out.
#'
#' @param object \code{liger} object.
#' @param file.path List of paths to hdf5 files.
#'
#' @return \code{liger} object with restored links.
#'
#' @export
#' @examples
#' \dontrun{
#' # We want to restore the ligerex (liger object based on HDF5 files)
#' # It has broken connections to HDF5 files
#' # Call the following function and provide the paths to the correspoinding files
#' ligerex = restoreOnlineLiger(ligerex, file.path = list("path1/library1.h5", "path2/library2.h5"))
#' }
restoreOnlineLigerWrong <- function(object, file.path = NULL) {
    if (is.null(file.path) &
        is.null(object@h5file.info[[1]][["file.path"]])) {
        # file path is not provided by file.path param or liger object
        stop(
            'File path information is not stored in the liger object. Please provide a list of file paths through file.path parameter.'
        )
    }

    if (!is.null(file.path)) {
        # if new file path is provided, update liger object h5file.info
        for (i in 1:length(object@h5file.info)) {
            object@h5file.info[[i]][["file.path"]] = file.path[[i]]
        }
    }
    # restore access to corresponding h5 files
    object@raw.data = lapply(object@h5file.info, function(x)
        hdf5r::H5File$new(x[["file.path"]], mode = "r+"))
    object@norm.data = lapply(object@raw.data, function(x)
        x[["norm.data"]])
    object@scale.data = lapply(object@raw.data, function(x)
        x[["scale.data"]])

    for (i in 1:length(object@raw.data)) {
        if (object@h5file.info[[i]][["format.type"]] == "10X") {
            barcodes.name = "matrix/barcodes"
            barcodes = object@raw.data[[i]][[barcodes.name]][]
            num_cells = object@raw.data[[i]][[barcodes.name]]$dims
            data.name = "matrix/data"
            indices.name = "matrix/indices"
            indptr.name = "matrix/indptr"
            genes.name = "matrix/features/name"
        } else if (format.type.list[i] == "AnnData") {
            barcodes.name = "obs"
            barcodes = object@raw.data[[i]][[barcodes.name]][]$cell
            num_cells = length(object@raw.data[[i]][[barcodes.name]][]$cell)
            data.name = "raw.X/data"
            indices.name = "raw.X/indices"
            indptr.name = "raw.X/indptr"
            genes.name = "raw.var"
        } else {
            barcodes = object@raw.data[[i]][[barcodes.name]][]
            num_cells = length(object@raw.data[[i]][[barcodes.name]][])
            data.name = data.name
            indices.name = indices.name
            indptr.name = indptr.name
        }
        object@h5file.info[[i]][["data"]] = object@raw.data[[i]][[data.name]]
        object@h5file.info[[i]][["indices"]] = object@raw.data[[i]][[indices.name]]
        object@h5file.info[[i]][["indptr"]] = object@raw.data[[i]][[indptr.name]]
        object@h5file.info[[i]][["barcodes"]] = object@raw.data[[i]][[barcodes.name]]
        object@h5file.info[[i]][["genes"]] = object@raw.data[[i]][[genes.name]]
    }
    return(object)
}
