#' Read 10X alignment data (including V3)
#'
#' This function generates a sparse matrix (genes x cells) from the data
#' generated by 10X's cellranger count pipeline. It can process V2 and V3 data
#' together, producing either a single merged matrix or list of matrices. Also
#' handles multiple data types produced by 10X V3 (Gene Expression, Antibody
#' Capture, CRISPR, CUSTOM).
#'
#' @param sampleDirs Character vector of directory paths to either
#' matrix.mtx(.gz) file along with genes.tsv (features.tsv.gz) and
#' barcodes.tsv(.gz), or 10X sample output directory (which contains "outs/").
#' @param sampleNames Character vector of names to use for each sample. Must
#' match \code{sampleDirs}.
#' @param maxNCells Numeric, limit on number of cells returned for each sample
#' (only for Gene Expression data). Retains the cells with the highest numbers
#' of transcripts. Default \code{NULL}.
#' @param useFiltered Logical, whether to use 10X's filtered data (as opposed to
#' raw). Only relevant if \code{sampleDirs} are 10X sample output directories (
#' which contain "outs/"). Default \code{FALSE}.
#' @param reference For 10X V<3, which reference directory to use if
#' \code{sampleDirs} is 10X sample output directory. Only use if more than one
#' reference is used for alignment. Default \code{NULL}.
#' @param modal Choose from \code{"rna"} or \code{"atac"}. The protocol of the
#' input data. If not specified, input data will be considered scRNA-seq data.
#' Default \code{"rna"}.
#' @param verbose Logical. Whether to show information of the progress. Default
#' \code{getOption("ligerVerbose")} which is \code{TRUE} if users have not set.
#' @param sample.dirs,sample.names,num.cells,use.filtered,data.type
#' \bold{Deprecated}. See Usage section for replacement.
#' @param merge \bold{Defuncted}. Whether to merge all matrices of the same data
#' type across samples or leave as list of matrices (default TRUE).
#' @param min.umis \bold{Defuncted}. Minimum UMI threshold for cells (default
#' 0).
#' @return List of samples. Each sample has a list of matrices across data
#' types.
#' @export
#' @examples
#' if (FALSE) {
#'     # 10X output directory V2 --
#'     #  contains outs/raw_gene_bc_matrices/<reference>/...
#'     sample.dir1 <- "home/welchjd/run/sample1" # folder "outs/" inside
#'     # 10X output directory V3 --
#'     #  for two data types, Gene Expression and CUSTOM
#'     sample.dir2 <- "home/welchjd/run/sample2" # folder "outs/" inside
#'     dataList <- read10X(sampleDirs = c(sample.dir1, sample.dir2),
#'                         sampleNames = c("sample1", "sample2"))
#'     lig <- createLiger(list(sample1 = dataList$sample1[["Gene Expression"]],
#'                             sample2 = dataList$sample2[["Gene Expression"]]))
#' }
read10X <- function(
        sampleDirs,
        sampleNames,
        maxNCells = NULL,
        useFiltered = FALSE,
        reference = NULL,
        modal = "rna",
        verbose = getOption("ligerVerbose"),
        # Deprecated coding style
        sample.dirs = sampleDirs,
        sample.names = sampleNames,
        num.cells = maxNCells,
        use.filtered = useFiltered,
        data.type = modal,
        # Defuncted
        merge = FALSE,
        min.umis = 0
) {
    .deprecateArgs(list(sample.dirs = "sampleDirs",
                        sample.names = "sampleNames",
                        num.cells = "maxNCells",
                        use.filtered = "useFiltered",
                        data.type = "modal"),
                   defunct = c("merge", "min.umis"))
    datalist <- list()
    datatypes <- c("Gene Expression")

    if (length(maxNCells) == 1) {
        maxNCells <- rep(maxNCells, length(sampleDirs))
    }
    for (i in seq_along(sampleDirs)) {
        .log("Processing sample ", sampleNames[i])
        sample.dir <- sampleDirs[i]
        inner1 <- paste0(sample.dir, "/outs")
        if (dir.exists(inner1)) {
            sample.dir <- inner1
            is_v3 <- dir.exists(paste0(sample.dir,
                                       "/filtered_feature_bc_matrix"))

            matrix.prefix <- ifelse(useFiltered, "filtered", "raw")
            if (is_v3) {
                sample.dir <-
                    paste0(sample.dir,
                           "/",
                           matrix.prefix,
                           "_feature_bc_matrix")
            } else {
                if (is.null(reference)) {
                    references <- list.dirs(
                        paste0(sample.dir, "/raw_gene_bc_matrices"),
                        full.names = FALSE,
                        recursive = FALSE
                    )
                    if (length(references) > 1) {
                        stop("Multiple reference genomes found. ",
                             "Please specify a single one.")
                    } else {
                        reference <- references[1]
                    }
                }
                sample.dir <- paste0(sample.dir, "/", matrix.prefix,
                                     "_gene_bc_matrices/", reference)
            }
        } else {
            is_v3 <- file.exists(paste0(sample.dir, "/features.tsv.gz"))
        }
        suffix <- ifelse(is_v3, ".gz", "")
        if (modal == "rna") {
            features.file <- ifelse(
                is_v3,
                paste0(sample.dir, "/features.tsv.gz"),
                paste0(sample.dir, "/genes.tsv")
            )
        } else if (modal == "atac") {
            features.file <- ifelse(
                is_v3,
                paste0(sample.dir, "/peaks.bed.gz"),
                paste0(sample.dir, "/peaks.bed")
            )
        }
        matrix.file <- paste0(sample.dir, "/matrix.mtx", suffix)
        barcodes.file <- paste0(sample.dir, "/barcodes.tsv", suffix)

        rawdata <- Matrix::readMM(matrix.file)
        # convert to dgc matrix
        if (class(rawdata)[1] == "dgTMatrix") {
            rawdata <- methods::as(rawdata, "CsparseMatrix")
        }

        # filter for UMIs first to increase speed
        umi.pass <- which(colSums(rawdata) > min.umis)
        if (length(umi.pass) == 0) {
            message("No cells pass UMI cutoff. Please lower it.")
        }
        rawdata <- rawdata[, umi.pass, drop = FALSE]

        barcodes <- readLines(barcodes.file)[umi.pass]
        # Remove -1 tag from barcodes
        if (all(grepl(barcodes, pattern = "\\-1$"))) {
            #barcodes <- as.vector(sapply(barcodes, function(x) {
            #    strsplit(x, "-")[[1]][1]
            #}))
            barcodes <- gsub("-1", ".1", barcodes)
        }
        if (modal == "rna") {
            features <- utils::read.delim(features.file, header = FALSE,
                                          stringsAsFactors = FALSE)
            rownames(rawdata) <- make.unique(features[, 2])
        } else if (modal == "atac") {
            features <- utils::read.table(features.file, header = FALSE)
            features <- paste0(features[, 1], ":", features[, 2],
                               "-", features[, 3])
            rownames(rawdata) <- features
        }
        # since some genes are only differentiated by ENSMBL
        colnames(rawdata) <- barcodes

        # split based on 10X datatype -- V3 has Gene Expression, Antibody
        # Capture, CRISPR, CUSTOM
        # V2 has only Gene Expression by default and just two columns
        if (is.null(ncol(features))) {
            samplelist <- list(rawdata)
            names(samplelist) <- c("Chromatin Accessibility")
        } else if (ncol(features) < 3) {
            samplelist <- list(rawdata)
            names(samplelist) <- c("Gene Expression")
        } else {
            sam.datatypes <- features[, 3]
            sam.datatypes.unique <- unique(sam.datatypes)
            # keep track of all unique datatypes
            datatypes <- union(datatypes, unique(sam.datatypes))
            samplelist <- lapply(sam.datatypes.unique, function(x) {
                rawdata[which(sam.datatypes == x),]
            })
            names(samplelist) <- sam.datatypes.unique
        }

        # maxNCells filter only for gene expression data
        if (!is.null(maxNCells)) {
            if (names(samplelist) == "Gene Expression" ||
                names(samplelist) == "Chromatin Accessibility") {
                data_label <- names(samplelist)
                cs <- colSums(samplelist[[data_label]])
                limit <- ncol(samplelist[[data_label]])
                if (maxNCells[i] > limit) {
                    warning("For dataset ", i, ", ", maxNCells[i], " cells ",
                            "are requested but only ", limit, " are ",
                            "available. Returning them all.", immediate. = TRUE)
                    maxNCells[i] <- limit
                }
                samplelist[[data_label]] <-
                    samplelist[[data_label]][, order(cs, decreasing = TRUE)
                                             [1:maxNCells[i]]]
            }
        }

        datalist[[i]] <- samplelist
    }
    # if (isTRUE(merge)) {
    #     if (isTRUE(verbose)) {
    #         .log("Merging samples")
    #     }
    #     return_dges <- lapply(datatypes, function(x) {
    #         mergelist <- lapply(datalist, function(d) d[[x]])
    #         mergelist <- mergelist[!sapply(mergelist, is.null)]
    #         sampleNames.x <- sampleNames[!sapply(mergelist, is.null)]
    #         mergeSparseAll(mergelist, sampleNames)
    #     })
    #     names(return_dges) <- datatypes

    #     # if only one type of data present
    #     if (length(return_dges) == 1) {
    #         if (isTRUE(verbose)) {
    #             .log("Returning ", datatypes, " data matrix")
    #         }
    #         return(return_dges[[1]])
    #     }
    #     return(return_dges)
    # } else {
    names(datalist) <- sampleNames
    return(datalist)
    # }
}



# read10X <- function(
#         runPath = NULL,
#         samplePaths = NULL,
#         sampleNames = NULL,
#         maxNCell = NULL,
#         removeMissing = TRUE,
#         useFiltered = FALSE,
#         reference = NULL,
#         modal = "rna",
#         verbose = getOption("ligerVerbose")
# ) {
#     if (!is.null(runPath)) {
#         pathList <- .read10X.searchSample(runPath)
#     } else {
#         if (length(samplePaths) != length(sampleNames)) {
#             stop()
#         }
#         maxNCell <- .checkVecParam(maxNCell, length(samplePaths), "maxNCell")
#         useFiltered <- .checkVecParam(useFiltered, length(samplePaths),
#                                       "useFiltered")
#         reference <- .checkVecParam(reference, length(samplePaths), "reference")
#         modal <- .checkVecParam(modal, length(samplePaths), "modal")

#         for (i in seq_along(samplePaths)) {
#             #yo
#         }
#     }
#     fullData <- list()
#     for (i in pathList) {
#         sampleName <- names(pathList)[i]
#         fullData[[sampleName]] <- .read10X.OneSample(pathList[[i]])
#     }
#     return(fullData)
# }

# .checkVecParam <- function(param, n, name) {
#     if (length(param) == 1) {
#         param <- rep(param, n)
#     } else if (length(param) != n) {
#         stop("Argument ", name, " should be either a scalar or a vector of ",
#              n, " values.")
#     }
#     return(param)
# }

# .read10X.searchSample <- function(runPath) {
#     # Find all sub directory that contains "outs/"
#     dirs <- normalizePath(file.path(runPath, dir(runPath)))
#     dirs <- dirs[dir.exists(file.path(dirs, "outs"))]
#     sampleNames <- basename(dirs)

#     return(dirs)
# }

# # path - Have to be the directory containing THE THREE FILES
# # geneCol - Integer index of the column containing the desired gene identifiers
# # in the V3 feature file.
# # barcodeCol - Integer index of the column containing the desired cell
# # identifiers in the barcode file.
# # Function mainly adopted from Seurat::Read10X
# .read10X.OneSample <- function(
#     path,
#     geneCol = 2,
#     barcodeCol = 1,
#     verbose = getOption("ligerVerbose")
# ) {
#     if (isTRUE(verbose)) {
#         .log("Processing the data at: ", normalizePath(path))
#     }
#     # Check whther pre-V3 or V3 and determine the paths
#     geneTSV <- file.path(path, "genes.tsv")
#     isV3 <- !file.exists(geneTSV)
#     if (isV3) {
#         featurePath <- normalizePath(file.path(path, "features.tsv.gz"))
#         if (!file.exists(featurePath))
#             stop("Gene name or features file missing. Expecting ",
#                  basename(featurePath))
#         barcodePath <- normalizePath(file.path(path, "barcodes.tsv.gz"))
#         matrixPath <- normalizePath(file.path(path, "matrix.mtx.gz"))
#     } else {
#         # Version < 3
#         featurePath <- normalizePath(geneTSV)
#         barcodePath <- normalizePath(file.path(path, "barcodes.tsv"))
#         matrixPath <- normalizePath(file.path(path, "matrix.mtx"))
#     }
#     if (!file.exists(barcodePath)) {
#         stop("Barcode file missing. Expecting ", basename(barcodePath))
#     }
#     if (!file.exists(matrixPath)) {
#         stop("Expression matrix file missing. Expecting ",
#              basename(matrixPath))
#     }
#     # Read the counts
#     data <- Matrix::readMM(matrixPath)

#     # Process barcodes
#     cell.barcodes <- utils::read.table(file = barcodePath, header = FALSE,
#                                        sep = "\t", row.names = NULL)
#     if (ncol(cell.barcodes) > 1) {
#         cell.names <- cell.barcodes[, barcodeCol]
#     } else {
#         cell.names <- readLines(barcodePath)
#     }
#     if (all(grepl("\\-1$", cell.names))) {
#         cell.names <- gsub("-", ".", cell.names)
#     }
#     colnames(data) <- cell.names

#     # Process features
#     feature.names <- utils::read.delim(featurePath, header = FALSE,
#                                        stringsAsFactors = FALSE)
#     if (geneCol > ncol(feature.names))
#         stop("`geneCol` more than what feature.tsv.gz (or genes.tsv) has.")
#     if (any(is.na(feature.names[, geneCol]))) {
#         warning("Some features names are NA. Replacing NA names with ID from ",
#                 "the opposite column requested",
#                 call. = FALSE, immediate. = TRUE)
#         na.features <- which(is.na(feature.names[, geneCol]))
#         replacement.column <- ifelse(geneCol == 2, 1, 2)
#         feature.names[na.features, geneCol] <-
#             feature.names[na.features, replacement.column]
#     }
#     rownames(data) <- make.unique(feature.names[, geneCol])

#     if (!inherits(data, "dgCMatrix")) data <- methods::as(data, "CsparseMatrix")

#     # Process feature type
#     if (ncol(feature.names) > 2) {
#         dataTypes <- factor(feature.names[, 3])
#         lvls <- levels(dataTypes)
#         # if (length(lvls) > 1 && length(fullData) == 0) {
#         #     .log("10X data contains more than one type and is being ",
#         #          "returned as a list containing matrices of each type.")
#         # }
#         exprName <- "Gene Expression"
#         if (exprName %in% lvls) {
#             lvls <- c(exprName, lvls[-which(lvls == exprName)])
#         }
#         data <- lapply(lvls, function(l) {
#             data[dataTypes == l, , drop = FALSE]
#         })
#         names(data) <- lvls
#     } else {
#         data <- list(`Gene Expression` = data)
#     }
#     if (isTRUE(verbose)) {
#         .log("Detected the matrix for: ",
#              paste0("\"", names(data), "\"", collapse = ", "))
#     }
#     return(data)
# }
