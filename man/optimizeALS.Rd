% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimizeALS.R
\name{optimizeALS}
\alias{optimizeALS}
\alias{optimizeALS,liger-method}
\alias{optimizeALS,list-method}
\title{Perform iNMF on scaled datasets}
\usage{
optimizeALS(
  object,
  k,
  lambda = 5,
  thresh = 1e-06,
  max.iters = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  use.unshared = FALSE,
  rand.seed = 1,
  print.obj = FALSE,
  readH5 = "auto",
  verbose = TRUE
)

\S4method{optimizeALS}{liger}(
  object,
  k,
  lambda = 5,
  thresh = 1e-06,
  max.iters = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  use.unshared = FALSE,
  rand.seed = 1,
  print.obj = FALSE,
  readH5 = "auto",
  verbose = TRUE
)

\S4method{optimizeALS}{list}(
  object,
  k,
  lambda = 5,
  thresh = 1e-06,
  max.iters = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  use.unshared = FALSE,
  rand.seed = 1,
  print.obj = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{object}{A \linkS4class{liger} object or a named list of matrix object,
where the names represents dataset names and matrices are scaled on the same
set of variable features, with rows as features and columns as cells.}

\item{k}{Inner dimension of factorization (number of factors). Run
\code{\link{suggestK}} to determine appropriate value; a general rule of
thumb is that a higher \code{k} will be needed for datasets with more
sub-structure.}

\item{lambda}{Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
\code{lambda} increases). Default \code{5}.}

\item{thresh}{Convergence threshold. Convergence occurs when
\eqn{|obj_0-obj|/(mean(obj_0,obj)) < thresh}. Default \code{1e-6}.}

\item{max.iters}{Maximum number of block coordinate descent iterations to
perform. Default \code{30}.}

\item{nrep}{Number of restarts to perform (iNMF objective function is
non-convex, so taking the best objective from multiple successive
initializations is recommended). For easier reproducibility, this increments
the random seed by 1 for each consecutive restart, so future factorizations
of the same dataset can be run with one rep if necessary. Default \code{1}.}

\item{H.init}{Initial values to use for \eqn{H} matrices. A list object where
each element is the initial \eqn{H} matrix of each dataset. Default
\code{NULL}.}

\item{W.init}{Initial values to use for \eqn{W} matrix. A matrix object.
Default \code{NULL}.}

\item{V.init}{Initial values to use for \eqn{V} matrices. A list object where
each element is the initial \eqn{V} matrix of each dataset. Default
\code{NULL}.}

\item{rand.seed}{Random seed to allow reproducible results. Default \code{1}.}

\item{print.obj}{Print objective function values after convergence when
\code{verbose = TRUE}. Default \code{FALSE}.}

\item{verbose}{Logical. Whether to show information of the progress. Default
\code{TRUE}.}
}
\value{
\code{object} with \code{W} slot updated with the result \eqn{W}
matrix, and the \code{H} and \code{V} slots of each
\linkS4class{ligerDataset} object in the \code{datasets} slot updated with
the dataset specific \eqn{H} and \eqn{V} matrix, respectively.
}
\description{
Performs integrative non-negative matrix (iNMF) factorization to return
factorized \eqn{H}, \eqn{W}, and \eqn{V} matrices. It optimizes the iNMF
objective function using block coordinate descent (alternating non-negative
least squares), where the number of factors is set by \code{k}. TODO: include
objective function equation here in documentation (using deqn)

For each dataset, this factorization produces an \eqn{H} matrix (cells by k),
a \eqn{V} matrix (k by genes), and a shared \eqn{W} matrix (k by genes). The
\eqn{H} matrices represent the cell factor loadings. \eqn{W} is held
consistent among all datasets, as it represents the shared components of the
metagenes across datasets. The \eqn{V} matrices represent the
dataset-specific components of the metagenes.
}
