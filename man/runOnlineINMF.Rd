% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runOnlineINMF.R
\name{runOnlineINMF}
\alias{runOnlineINMF}
\alias{runOnlineINMF.liger}
\alias{runOnlineINMF.list}
\alias{runOnlineINMF.Seurat}
\title{Perform online iNMF on scaled datasets}
\usage{
runOnlineINMF(
  object,
  k = 20,
  lambda = 5,
  newDatasets = NULL,
  projection = FALSE,
  maxEpochs = 5,
  HALSiter = 1,
  miniBatchSize = 5000,
  seed = 123,
  verbose = getOption("ligerVerbose"),
  ...
)

\method{runOnlineINMF}{liger}(
  object,
  k = 20,
  lambda = 5,
  newDatasets = NULL,
  projection = FALSE,
  maxEpochs = 5,
  HALSiter = 1,
  miniBatchSize = 5000,
  seed = 123,
  verbose = getOption("ligerVerbose"),
  ...
)

\method{runOnlineINMF}{list}(
  object,
  k = 20,
  lambda = 5,
  newDatasets = NULL,
  projection = FALSE,
  maxEpochs = 5,
  WInit = NULL,
  VInit = NULL,
  AInit = NULL,
  BInit = NULL,
  HALSiter = 1,
  miniBatchSize = 5000,
  seed = 123,
  verbose = getOption("ligerVerbose"),
  ...
)

\method{runOnlineINMF}{Seurat}(
  object,
  k = 20,
  lambda = 5,
  newDatasets = NULL,
  projection = FALSE,
  maxEpochs = 5,
  HALSiter = 1,
  miniBatchSize = 5000,
  seed = 123,
  verbose = getOption("ligerVerbose"),
  ...
)
}
\arguments{
\item{object}{\linkS4class{liger} object. Scaled data required.}

\item{k}{Inner dimension of factorization--number of metagenes. A value in
the range 20-50 works well for most analyses. Default \code{20}.}

\item{lambda}{Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
lambda increases). We recommend always using the default value except
possibly for analyses with relatively small differences (biological
replicates, male/female comparisons, etc.) in which case a lower value such
as 1.0 may improve reconstruction quality. Default \code{5.0}.}

\item{newDatasets}{New datasets for scenario 2 or scenario 3.}

\item{projection}{Perform data integration with scenario 3. See description.
Default \code{FALSE}.}

\item{maxEpochs}{The number of epochs to iterate through. See detail.
Default \code{5}.}

\item{miniBatchSize}{Total number of cells in each minibatch. See detail.
Default \code{5000}.}

\item{seed}{Random seed to allow reproducible results. Default \code{123}.}

\item{verbose}{Logical. Whether to show information of the progress. Default
\code{getOption("ligerVerbose")} which is \code{TRUE} if users have not set.}

\item{WInit}{Optional initialization for W. See detail. Default \code{NULL}.}

\item{VInit}{Optional initialization for V. See detail. Default \code{NULL}.}

\item{AInit}{Optional initialization for A. See detail. Default \code{NULL}.}

\item{BInit}{Optional initialization for B. See detail. Default \code{NULL}.}

\item{HALSiters}{Maximum number of block coordinate descent (HALS
algorithm) iterations to perform for each update of \eqn{W} and \eqn{V}.
Default \code{1}. Changing this parameter is not recommended.}
}
\value{
\code{object} with \code{W} slot updated with resulting \eqn{W}
matrix; the \code{H}, \code{V}, \code{A} and \code{B} slots of each
\linkS4class{ligerDataset} object in \code{datasets} slot is updated with the
corresponding result matrices.
}
\description{
Perform online integrative non-negative matrix factorization to
represent multiple single-cell datasets in terms of \eqn{H}, \eqn{W}, and
\eqn{V} matrices. It optimizes the iNMF objective function using online
learning (non-negative least squares for H matrix, hierarchical alternating
least squares for \eqn{W} and \eqn{V} matrices), where the number of factors
is set by \code{k}. The function allows online learning in 3 scenarios:

\enumerate{
 \item Fully observed datasets;
 \item Iterative refinement using continually arriving datasets;
 \item Projection of new datasets without updating the existing factorization
}

All three scenarios require fixed memory independent of the number of cells.

For each dataset, this factorization produces an \eqn{H} matrix (k by cell),
a \eqn{V} matrix (genes by k) \eqn{C^\mathsf{T}C}, and a shared \eqn{W} matrix (genes by k). The
\eqn{H} matrices represent the cell factor loadings. \eqn{W} is identical
among all datasets, as it represents the shared components of the metagenes
across datasets. The \eqn{V} matrices represent the dataset-specific
components of the metagenes.
}
\details{
For optional initialization, \code{W.init} must be a matrix object with
number of rows equal to number of variable genes (denoted as \code{g}) and
number of columns equal to \code{k}. Any of \code{V.init}, \code{A} and
\code{B} must be a list object of n matrices where n is the number of
datasets in \code{object}. For \code{V.init}, each matrix should be of size g
x k. For \code{A.init}, each matrix should be k x k and for \code{B.init},
each matrix should be g x k.

Minibatch iterations is performed on small subset of cells. The exact
minibatch size applied on each dataset is \code{miniBatch_size} multiplied by
the proportion of cells in this dataset out of all cells. The setting of
\code{miniBatch_size} is by default \code{5000}, which is reasonable.
However, a smaller value such as \code{1000} may be necessary for analyzing
very small datasets. In general, \code{miniBatch_size} should be no larger
than the number of cells in the smallest dataset. An epoch is one completion
of calculation on all cells after a number of iterations of minibatches.
Therefore, the total number of iterations is determined by the setting of
\code{max.epochs}, total number of cells, and \code{miniBatch_size}.
}
\examples{
pbmc <- normalize(pbmc)
pbmc <- selectGenes(pbmc)
pbmc <- scaleNotCenter(pbmc)
# Minibatch size has to be less than number of cell in the smallest dataset
# Scenario 1
pbmc <- online_iNMF(pbmc, miniBatch_size = 100)
# Scenario 2
# Fake new dataset by increasing all non-zero value in "ctrl" by 1
ctrl2 <- rawData(dataset(pbmc, "ctrl"))
ctrl2@x <- ctrl2@x + 1
colnames(ctrl2) <- paste0(colnames(ctrl2), 2)
pbmc2 <- online_iNMF(pbmc, k = 20, X_new = list(ctrl2 = ctrl2),
                     miniBatch_size = 100)
# Scenario 3
pbmc3 <- online_iNMF(pbmc, k = 20, X_new = list(ctrl2 = ctrl2),
                     miniBatch_size = 100, projection = TRUE)
}
