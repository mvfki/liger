% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runINMF_R.R
\name{runINMF_R}
\alias{runINMF_R}
\alias{runINMF_R,liger-method}
\alias{runINMF_R,list-method}
\title{Perform iNMF on scaled datasets}
\usage{
runINMF_R(
  object,
  k,
  lambda = 5,
  thresh = 1e-06,
  maxIter = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  method = c("planc", "liger", "rcppml"),
  useUnshared = FALSE,
  seed = 1,
  readH5 = "auto",
  verbose = getOption("ligerVerbose")
)

\S4method{runINMF_R}{liger}(
  object,
  k,
  lambda = 5,
  thresh = 1e-06,
  maxIter = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  useUnshared = FALSE,
  seed = 1,
  readH5 = "auto",
  verbose = getOption("ligerVerbose")
)

\S4method{runINMF_R}{list}(
  object,
  k,
  lambda = 5,
  maxIter = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  method = c("planc", "liger", "rcppml"),
  useUnshared = FALSE,
  seed = 1,
  readH5 = "auto",
  verbose = getOption("ligerVerbose")
)
}
\arguments{
\item{object}{A \linkS4class{liger} object or a named list of matrix object,
where the names represents dataset names and matrices are scaled on the same
set of variable features, with rows as features and columns as cells.}

\item{k}{Inner dimension of factorization (number of factors). Run
\code{\link{suggestK}} to determine appropriate value; a general rule of
thumb is that a higher \code{k} will be needed for datasets with more
sub-structure.}

\item{lambda}{Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
\code{lambda} increases). Default \code{5}.}

\item{thresh}{Convergence threshold. Convergence occurs when
\eqn{|obj_0-obj|/(mean(obj_0,obj)) < thresh}. Default \code{1e-6}.}

\item{maxIter}{Maximum number of block coordinate descent iterations to
perform. Default \code{30}.}

\item{nrep}{Number of restarts to perform (iNMF objective function is
non-convex, so taking the best objective from multiple successive
initialization is recommended). For easier reproducibility, this increments
the random seed by 1 for each consecutive restart, so future factorization
of the same dataset can be run with one rep if necessary. Default \code{1}.}

\item{H.init}{Initial values to use for \eqn{H} matrices. A list object where
each element is the initial \eqn{H} matrix of each dataset. Default
\code{NULL}.}

\item{W.init}{Initial values to use for \eqn{W} matrix. A matrix object.
Default \code{NULL}.}

\item{V.init}{Initial values to use for \eqn{V} matrices. A list object where
each element is the initial \eqn{V} matrix of each dataset. Default
\code{NULL}.}

\item{method}{NNLS subproblem solver. Choose from \code{"liger"} (default
original implementation), \code{"planc"} or \code{"rcppml"}.}

\item{useUnshared}{Logical, whether to include unshared variable features and
run optimizeUANLS algorithm. Defaul \code{FALSE}. Running
\code{\link{selectGenes}} with \code{unshared = TRUE} and then running
\code{\link{scaleNotCenter}} is required.}

\item{seed}{Random seed to allow reproducible results. Default \code{1}.}

\item{readH5}{\code{TRUE} to force reading H5 based data into memory and
conduct factorization. \code{"auto"} reads H5 dataset with less than 8000
cells. \code{FALSE} will stop users from running if H5 data presents.}

\item{verbose}{Logical. Whether to show information of the progress. Default
\code{getOption("ligerVerbose")} which is \code{TRUE} if users have not set.}

\item{max.iters, use.unshared, rand.seed}{\bold{Deprecated}. See Usage section
for replacement.}

\item{print.obj}{\bold{Defunct}. Whether to print objective function values
after convergence when \code{verbose = TRUE}. Now always print when verbose.}
}
\value{
\code{object} with \code{W} slot updated with the result \eqn{W}
matrix, and the \code{H} and \code{V} slots of each
\linkS4class{ligerDataset} object in the \code{datasets} slot updated with
the dataset specific \eqn{H} and \eqn{V} matrix, respectively.
}
\description{
Performs integrative non-negative matrix (iNMF) factorization to return
factorized \eqn{H}, \eqn{W}, and \eqn{V} matrices. It optimizes the iNMF
objective function using block coordinate descent (alternating non-negative
least squares), where the number of factors is set by \code{k}. TODO: include
objective function equation here in documentation (using deqn)

For each dataset, this factorization produces an \eqn{H} matrix (cells by k),
a \eqn{V} matrix (k by genes), and a shared \eqn{W} matrix (k by genes). The
\eqn{H} matrices represent the cell factor loadings. \eqn{W} is held
consistent among all datasets, as it represents the shared components of the
metagenes across datasets. The \eqn{V} matrices represent the
dataset-specific components of the metagenes.
}
\examples{
pbmc <- normalize(pbmc)
pbmc <- selectGenes(pbmc)
pbmc <- scaleNotCenter(pbmc)
# Only running a few iterations for fast examples
pbmc <- runINMF(pbmc, k = 20, maxIter = 2)
}
